.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::Listable 3"
.TH Bio::Phylo::Listable 3 "2014-02-08" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Phylo::Listable \- List of things, super class for many objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& No direct usage, parent class. Methods documented here 
\& are available for all objects that inherit from it.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A listable object is an object that contains multiple smaller objects of the
same type. For example: a tree contains nodes, so it's a listable object.
.PP
This class contains methods that are useful for all listable objects: Matrices
(i.e. sets of matrix objects), individual Matrix objects, Datum objects (i.e.
character state sequences), Taxa, Forest, Tree and Node objects.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1ARRAY METHODS\s0"
.IX Subsection "ARRAY METHODS"
.IP "\fIinsert()\fR" 4
.IX Item "insert()"
Pushes an object into its container.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : insert
\& Usage   : $obj\->insert($other_obj);
\& Function: Pushes an object into its container.
\& Returns : A Bio::Phylo::Listable object.
\& Args    : A Bio::Phylo::* object.
.Ve
.IP "\fIinsert_at_index()\fR" 4
.IX Item "insert_at_index()"
Inserts argument object in container at argument index.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : insert_at_index
\& Usage   : $obj\->insert_at_index($other_obj, $i);
\& Function: Inserts $other_obj at index $i in container $obj
\& Returns : A Bio::Phylo::Listable object.
\& Args    : A Bio::Phylo::* object.
.Ve
.IP "\fIdelete()\fR" 4
.IX Item "delete()"
Deletes argument from container.
.Sp
.Vb 10
\& Type    : Mutator
\& Title   : delete
\& Usage   : $obj\->delete($other_obj);
\& Function: Deletes an object from its container.
\& Returns : A Bio::Phylo::Listable object.
\& Args    : A Bio::Phylo::* object.
\& Note    : Be careful with this method: deleting 
\&           a node from a tree like this will 
\&           result in undefined references in its 
\&           neighbouring nodes. Its children will 
\&           have their parent reference become 
\&           undef (instead of pointing to their 
\&           grandparent, as collapsing a node would 
\&           do). The same is true for taxon objects 
\&           that reference datum objects: if the 
\&           datum object is deleted from a matrix 
\&           (say), the taxon will now hold undefined 
\&           references.
.Ve
.IP "\fIclear()\fR" 4
.IX Item "clear()"
Empties container object.
.Sp
.Vb 7
\& Type    : Mutator
\& Title   : clear
\& Usage   : $obj\->clear();
\& Function: Clears the container.
\& Returns : A Bio::Phylo::Listable object.
\& Args    : Note.
\& Note    :
.Ve
.IP "\fIkeep_entities()\fR" 4
.IX Item "keep_entities()"
Keeps the container's contents specified by an array reference of indices.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : keep_entities
\& Usage   : $list\->keep_entities([9,7,7,6]);
\& Function: Keeps a subset of contents
\& Returns : A Bio::Phylo::Listable object.
\& Args    : An array reference of indices
.Ve
.IP "\fIget_entities()\fR" 4
.IX Item "get_entities()"
Returns a reference to an array of objects contained by the listable object.
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : get_entities
\& Usage   : my @entities = @{ $obj\->get_entities };
\& Function: Retrieves all entities in the container.
\& Returns : A reference to a list of Bio::Phylo::* 
\&           objects.
\& Args    : none.
.Ve
.SS "\s-1ITERATOR METHODS\s0"
.IX Subsection "ITERATOR METHODS"
.IP "\fIfirst()\fR" 4
.IX Item "first()"
Jumps to the first element contained by the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : first
\& Usage   : my $first_obj = $obj\->first;
\& Function: Retrieves the first 
\&           entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fIlast()\fR" 4
.IX Item "last()"
Jumps to the last element contained by the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : last
\& Usage   : my $last_obj = $obj\->last;
\& Function: Retrieves the last 
\&           entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fIcurrent()\fR" 4
.IX Item "current()"
Returns the current focal element of the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : current
\& Usage   : my $current_obj = $obj\->current;
\& Function: Retrieves the current focal 
\&           entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fInext()\fR" 4
.IX Item "next()"
Returns the next focal element of the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : next
\& Usage   : my $next_obj = $obj\->next;
\& Function: Retrieves the next focal 
\&           entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fIprevious()\fR" 4
.IX Item "previous()"
Returns the previous element of the listable object.
.Sp
.Vb 7
\& Type    : Iterator
\& Title   : previous
\& Usage   : my $previous_obj = $obj\->previous;
\& Function: Retrieves the previous 
\&           focal entity in the container.
\& Returns : A Bio::Phylo::* object
\& Args    : none.
.Ve
.IP "\fIcurrent_index()\fR" 4
.IX Item "current_index()"
Returns the current internal index of the container.
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : current_index
\& Usage   : my $last_index = $obj\->current_index;
\& Function: Returns the current internal 
\&           index of the container or 0
\& Returns : An integer
\& Args    : none.
.Ve
.IP "\fIlast_index()\fR" 4
.IX Item "last_index()"
Returns the highest valid index of the container.
.Sp
.Vb 7
\& Type    : Generic query
\& Title   : last_index
\& Usage   : my $last_index = $obj\->last_index;
\& Function: Returns the highest valid 
\&           index of the container.
\& Returns : An integer
\& Args    : none.
.Ve
.SS "\s-1UTILITY METHODS\s0"
.IX Subsection "UTILITY METHODS"
.IP "\fIset_listener()\fR" 4
.IX Item "set_listener()"
Attaches a listener (code ref) which is executed when contents change.
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : set_listener
\& Usage   : $object\->set_listener( sub { my $object = shift; } );
\& Function: Attaches a listener (code ref) which is executed when contents change.
\& Returns : Invocant.
\& Args    : A code reference.
\& Comments: When executed, the code reference will receive $object
\&           (the container) as its first argument.
.Ve
.IP "\fInotify_listeners()\fR" 4
.IX Item "notify_listeners()"
Notifies listeners of changed contents.
.Sp
.Vb 7
\& Type    : Utility method
\& Title   : notify_listeners
\& Usage   : $object\->notify_listeners;
\& Function: Notifies listeners of changed contents.
\& Returns : Invocant.
\& Args    : NONE.
\& Comments:
.Ve
.SS "\s-1SETS MANAGEMENT\s0"
.IX Subsection "SETS MANAGEMENT"
Many Bio::Phylo objects are segmented, i.e. they contain one or more subparts 
of the same type. For example, a matrix contains multiple rows; each row 
contains multiple cells; a tree contains nodes, and so on. (Segmented objects
all inherit from Bio::Phylo::Listable, i.e. the class whose documentation you're
reading here.) In many cases it is useful to be able to define subsets of the 
contents of segmented objects, for example sets of taxon objects inside a taxa 
block. The Bio::Phylo::Listable object allows this through a number of methods 
(add_set, remove_set, add_to_set, remove_from_set etc.). Those methods delegate 
the actual management of the set contents to the Bio::Phylo::Set object. 
Consult the documentation for Bio::Phylo::Set for a code sample.
.IP "\fIadd_set()\fR" 4
.IX Item "add_set()"
.Vb 6
\& Type    : Mutator
\& Title   : add_set
\& Usage   : $obj\->add_set($set)
\& Function: Associates a Bio::Phylo::Set object with the container
\& Returns : Invocant
\& Args    : A Bio::Phylo::Set object
.Ve
.IP "\fIset_sets()\fR" 4
.IX Item "set_sets()"
.Vb 6
\& Type    : Mutator
\& Title   : set_sets
\& Usage   : $obj\->set_sets([ $s1, $s2, $s3 ])
\& Function: Assigns all Bio::Phylo::Set objects to the container
\& Returns : Invocant
\& Args    : An array ref of Bio::Phylo::Set objects
.Ve
.IP "\fIremove_set()\fR" 4
.IX Item "remove_set()"
.Vb 6
\& Type    : Mutator
\& Title   : remove_set
\& Usage   : $obj\->remove_set($set)
\& Function: Removes association between a Bio::Phylo::Set object and the container
\& Returns : Invocant
\& Args    : A Bio::Phylo::Set object
.Ve
.IP "\fIget_sets()\fR" 4
.IX Item "get_sets()"
.Vb 6
\& Type    : Accessor
\& Title   : get_sets
\& Usage   : my @sets = @{ $obj\->get_sets() };
\& Function: Retrieves all associated Bio::Phylo::Set objects
\& Returns : Invocant
\& Args    : None
.Ve
.IP "\fIis_in_set()\fR" 4
.IX Item "is_in_set()"
.Vb 10
\& Type    : Test
\& Title   : is_in_set
\& Usage   : @do_something if $listable\->is_in_set($obj,$set);
\& Function: Returns whether or not the first argument is listed in the second argument
\& Returns : Boolean
\& Args    : $obj \- an object that may, or may not be in $set
\&           $set \- the Bio::Phylo::Set object to query
\& Notes   : This method makes two assumptions:
\&           i) the $set object is associated with the container,
\&              i.e. add_set($set) has been called previously
\&           ii) the $obj object is part of the container
\&           If either assumption is violated a warning message
\&           is printed.
.Ve
.IP "\fIadd_to_set()\fR" 4
.IX Item "add_to_set()"
.Vb 10
\& Type    : Mutator
\& Title   : add_to_set
\& Usage   : $listable\->add_to_set($obj,$set);
\& Function: Adds first argument to the second argument
\& Returns : Invocant
\& Args    : $obj \- an object to add to $set
\&           $set \- the Bio::Phylo::Set object to add to
\& Notes   : this method assumes that $obj is already 
\&           part of the container. If that assumption is
\&           violated a warning message is printed.
.Ve
.IP "\fIremove_from_set()\fR" 4
.IX Item "remove_from_set()"
.Vb 10
\& Type    : Mutator
\& Title   : remove_from_set
\& Usage   : $listable\->remove_from_set($obj,$set);
\& Function: Removes first argument from the second argument
\& Returns : Invocant
\& Args    : $obj \- an object to remove from $set
\&           $set \- the Bio::Phylo::Set object to remove from
\& Notes   : this method assumes that $obj is already 
\&           part of the container. If that assumption is
\&           violated a warning message is printed.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There is a mailing list at <https://groups.google.com/forum/#!forum/bio\-phylo> 
for any user or developer questions and discussions.
.PP
Also see the manual: Bio::Phylo::Manual and <http://rutgervos.blogspot.com>.
.SS "Objects inheriting from Bio::Phylo::Listable"
.IX Subsection "Objects inheriting from Bio::Phylo::Listable"
.IP "Bio::Phylo::Forest" 4
.IX Item "Bio::Phylo::Forest"
Iterate over a set of trees.
.IP "Bio::Phylo::Forest::Tree" 4
.IX Item "Bio::Phylo::Forest::Tree"
Iterate over nodes in a tree.
.IP "Bio::Phylo::Forest::Node" 4
.IX Item "Bio::Phylo::Forest::Node"
Iterate of children of a node.
.IP "Bio::Phylo::Matrices" 4
.IX Item "Bio::Phylo::Matrices"
Iterate over a set of matrices.
.IP "Bio::Phylo::Matrices::Matrix" 4
.IX Item "Bio::Phylo::Matrices::Matrix"
Iterate over the datum objects in a matrix.
.IP "Bio::Phylo::Matrices::Datum" 4
.IX Item "Bio::Phylo::Matrices::Datum"
Iterate over the characters in a datum.
.IP "Bio::Phylo::Taxa" 4
.IX Item "Bio::Phylo::Taxa"
Iterate over a set of taxa.
.SS "Superclasses"
.IX Subsection "Superclasses"
.IP "Bio::Phylo::NeXML::Writable" 4
.IX Item "Bio::Phylo::NeXML::Writable"
This object inherits from Bio::Phylo::NeXML::Writable, so methods
defined there are also applicable here.
.SH "CITATION"
.IX Header "CITATION"
If you use Bio::Phylo in published research, please cite it:
.PP
\&\fBRutger A Vos\fR, \fBJason Caravas\fR, \fBKlaas Hartmann\fR, \fBMark A Jensen\fR
and \fBChase Miller\fR, 2011. Bio::Phylo \- phyloinformatic analysis using Perl.
\&\fI\s-1BMC\s0 Bioinformatics\fR \fB12\fR:63.
<http://dx.doi.org/10.1186/1471\-2105\-12\-63>
