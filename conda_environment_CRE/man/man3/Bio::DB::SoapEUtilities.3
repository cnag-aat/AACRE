.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::SoapEUtilities 3"
.TH Bio::DB::SoapEUtilities 3 "2019-10-28" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::SoapEUtilities \- Interface to the NCBI Entrez web service *BETA*
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Bio::DB::SoapEUtilities;
\&
\& # factory construction
\&
\& my $fac = Bio::DB::SoapEUtilities\->new()
\&
\& # executing a utility call
\&
\& #get an iteratable adaptor
\& my $links = $fac\->elink( 
\&               \-dbfrom => \*(Aqprotein\*(Aq,
\&               \-db => \*(Aqtaxonomy\*(Aq,
\&               \-id => \e@protein_ids )\->run(\-auto_adapt => 1);
\&
\& # get a Bio::DB::SoapEUtilities::Result object
\& my $result = $fac\->esearch(
\&               \-db => \*(Aqgene\*(Aq,
\&               \-term => \*(Aqsonic and human\*(Aq)\->run;
\&
\& # get the raw XML message
\& my $xml = $fac\->efetch(
\&             \-db => \*(Aqgene\*(Aq,
\&             \-id => \e@gids )\->run( \-raw_xml => 1 );
\&
\& # change parameters 
\& my $new_result = $fac\->efetch(
\&                   \-db => \*(Aqgene\*(Aq,
\&                   \-id => \e@more_gids)\->run;
\& # reset parameters
\& $fac\->efetch\->reset_parameters( \-db => \*(Aqnucleotide\*(Aq,
\&                                 \-id => $nucid );
\& $result = $fac\->efetch\->run;
\&                
\& # parsing and iterating the results
\&
\& $count = $result\->count;
\& @ids = $result\->ids;
\& 
\& while ( my $linkset = $links\->next_link ) {
\&    $submitted = $linkset\->submitted_id;
\& }
\& 
\& ($taxid) = $links\->id_map($submitted_prot_id);
\& $species_io = $fac\->efetch( \-db => \*(Aqtaxonomy\*(Aq,
\&                             \-id => $taxid )\->run( \-auto_adapt => 1);
\& $species = $species_io\->next_species;
\& $linnaeus = $species\->binomial;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows the user to query the \s-1NCBI\s0 Entrez database via its
\&\s-1SOAP\s0 (Simple Object Access Protocol) web service (described at
<http://eutils.ncbi.nlm.nih.gov/entrez/eutils/soap/v2.0/DOC/esoap_help.html>).
The basic tools (\f(CW\*(C`einfo, esearch, elink, efetch, espell, epost\*(C'\fR) are
available as methods off a \f(CW\*(C`SoapEUtilities\*(C'\fR factory
object. Parameters for each tool can be queried, set and reset for
each method through the Bio::ParameterBaseI standard calls
(\f(CW\*(C`available_parameters(), set_parameters(), get_parameters(),
reset_parameters()\*(C'\fR). Returned data can be retrieved, accessed and
parsed in several ways, according to user preference. Adaptors and
object iterators are available for \f(CW\*(C`efetch\*(C'\fR, \f(CW\*(C`egquery\*(C'\fR, \f(CW\*(C`elink\*(C'\fR,
and \f(CW\*(C`esummary\*(C'\fR results.
.SH "USAGE"
.IX Header "USAGE"
The \f(CW\*(C`SoapEU\*(C'\fR system has been designed to be as easy (few includes,
available parameter facilities, reasonable defaults, intuitive
aliases, built-in pipelines) or as complex (accessors for underlying
low-level objects, all parameters accessible, custom hooks for builder
objects, facilities for providing local copies of WSDLs) as the user
requires or desires. (To the extent that it does not succeed in either
direction, it is up to the user to report to the mailing list
(\*(L"\s-1FEEDBACK\*(R"\s0)!)
.SS "Factory"
.IX Subsection "Factory"
To begin, make a factory:
.PP
.Vb 1
\& my $fac = Bio::DB::SoapEUtilities\->new();
.Ve
.PP
From the factory, utilities are called, parameters are set, and
results or adaptors are retrieved.
.PP
If you have your own copy of the wsdl, use
.PP
.Vb 1
\& my $fac = Bio::Db::SoapEUtilities\->new( \-wsdl_file => $my_wsdl );
.Ve
.PP
otherwise, the correct one will be obtained over the network (by
Bio::DB::ESoap and friends).
.SS "Utilities and parameters"
.IX Subsection "Utilities and parameters"
To run any of the standard \s-1NCBI\s0 EUtilities (\f(CW\*(C`einfo, esearch, esummary, 
elink, egquery, epost, espell\*(C'\fR), call the desired utility from the factory.
To use a utility, you must set its parameters and run it to get a result. 
\&\s-1TMTOWTDI:\s0
.PP
.Vb 4
\& # verbose
\& my $fetch = $fac\->efetch();
\& $fetch\->set_parameters( \-db => \*(Aqgene\*(Aq, \-id => [828392, 790]);
\& my $result = $fetch\->run;
\&
\& # compact
\& my $result = $fac\->efetch(\-db =>\*(Aqgene\*(Aq,\-id => [828392,790])\->run;
\&
\& # change ids
\& $fac\->efetch\->set_parameters( \-id => 470338 );
\& $result = $fac\->run;
\&
\& # another util
\& $result = $fac\->esearch(\-db => \*(Aqprotein\*(Aq, \-term => \*(AqBRCA and human\*(Aq)\->run;
\& 
\& # the utilities are kept separate
\& %search_params = $fac\->esearch\->get_parameters;
\& %fetch_params = $fac\->efetch\->get_parameters;
\& $search_param{db}; # is \*(Aqprotein\*(Aq
\& $fetch_params{db}; # is \*(Aqgene\*(Aq
.Ve
.PP
The factory is Bio::ParameterBaseI compliant: that means you can
find out what you can set with
.PP
.Vb 2
\& @available_search = $fac\->esearch\->available_parameters;
\& @available_egquery = $fac\->egquery\->available_parameters;
.Ve
.PP
For more information on parameters, see
<http://www.ncbi.nlm.nih.gov/entrez/query/static/eutils_help.html>.
.SS "Results"
.IX Subsection "Results"
The \*(L"intermediate\*(R" object for \f(CW\*(C`SoapEU\*(C'\fR query results is the
Bio::DB::SoapEUtilities::Result. This is a BioPerly parsing of the
\&\s-1SOAP\s0 message sent by \s-1NCBI\s0 when a query is \f(CW\*(C`run()\*(C'\fR. This can be very
useful on it's own, but most users will likely want to proceed
directly to \*(L"Adaptors\*(R", which take a \f(CW\*(C`Result\*(C'\fR and turn it into more
intuitive/familiar BioPerl objects. Go there if the following details
are too gory.
.PP
Results can be highly\- or lowly-parsed, depending on the parameters
passed to the factory \f(CW\*(C`run()\*(C'\fR method. To get the raw \s-1XML\s0 message with
no parsing, do
.PP
.Vb 1
\& my $xml = $fac\->$util\->run(\-raw_xml => 1); # $xml is a scalar string
.Ve
.PP
To retrieve a Bio::DB::SoapEUtilities::Result object with limited
parsing, but with accessors to the \s-1SOAP::SOM\s0 message (provided by
SOAP::Lite), do
.PP
.Vb 3
\& my $result = $fac\->$util\->run(\-no_parse => 1);
\& my $som = $result\->som;
\& my $method_hash = $som\->method; # etc...
.Ve
.PP
To retrieve a \f(CW\*(C`Result\*(C'\fR object with message elements parsed into
accessors, including \f(CW\*(C`count()\*(C'\fR and \f(CW\*(C`ids()\*(C'\fR, run without arguments:
.PP
.Vb 6
\& my $result = $fac\->esearch\->run()
\& my $count = $result\->count;
\& my @Count = $result\->Count; # counts for each member of 
\&                             # the translation stack
\& my @ids = $result\->IdList_Id; # from automatic message parsing
\& @ids = $result\->ids; # a convenient alias
.Ve
.PP
See Bio::DB::SoapEUtilities::Result for more, even gorier details.
.SS "Adaptors"
.IX Subsection "Adaptors"
Adaptors convert EUtility \f(CW\*(C`Result\*(C'\fRs into convenient objects, via a
handle that usually provides an iterator, in the spirit of
Bio::SeqIO. These are probably more useful than the \f(CW\*(C`Result\*(C'\fR to
the typical user, and so you can retrieve them automatically by
setting the \f(CW\*(C`run()\*(C'\fR parameter \f(CW\*(C`\-auto_adapt =\*(C'\fR 1>.
.PP
In general, retrieve an adaptor like so:
.PP
.Vb 5
\& $adp = $fac\->$util\->run( \-auto_adapt => 1 );
\& # iterate...
\& while ( my $obj = $adp\->next_obj ) {
\&    # do stuff with $obj
\& }
.Ve
.PP
The adaptor itself occasionally possesses useful methods besides the
iterator. The method \f(CW\*(C`next_obj\*(C'\fR always works, but a natural alias is
also always available:
.PP
.Vb 4
\& $seqio = $fac\->esearch\->run( \-auto_adapt => 1 );
\& while ( my $seq = $seqio\->next_seq ) {
\&    # do stuff with $seq
\& }
.Ve
.PP
In the above example, \f(CW\*(C`\-auto_adapt =\*(C'\fR 1> also instructs the factory
to perform an \f(CW\*(C`efetch\*(C'\fR based on the ids returned by the \f(CW\*(C`esearch\*(C'\fR
(if any), so that the adaptor returned iterates over Bio::SeqI
objects.
.PP
Here is a rundown of the different adaptor flavors:
.IP "\(bu" 4
\&\f(CW\*(C`efetch\*(C'\fR, Fetch Adaptors, and BioPerl object iterators
.Sp
The \f(CW\*(C`FetchAdaptor\*(C'\fR creates bona fide BioPerl objects. Currently,
there are FetchAdaptor subclasses for sequence data (both Genbank and
\&\s-1FASTA\s0 rettypes) and taxonomy data. The choice of FetchAdaptor is based
on information in the result message, and should be transparent to the
user.
.Sp
.Vb 12
\& $seqio = $fac\->efetch( \-db =>\*(Aqnucleotide\*(Aq,
\&                        \-id => \e@ids,
\&                        \-rettype => \*(Aqgb\*(Aq )\->run( \-auto_adapt => 1 );
\& while (my $seq = $seqio\->next_seq) {
\&    my $taxio = $fac\->efetch( 
\&        \-db => \*(Aqtaxonomy\*(Aq, 
\&        \-id => $seq\->species\->ncbi_taxid )\->run(\-auto_adapt => 1);
\&    my $tax = $taxio\->next_species;
\&    unless ( $tax\->TaxId == $seq\->species\->ncbi_taxid ) {
\&      print "more work for MAJ"
\&    }
\& }
.Ve
.Sp
See the pod for the FetchAdaptor subclasses (e.g.,
Bio::DB::SoapEUtilities::FetchAdaptor::seq) for more detail.
.IP "\(bu" 4
\&\f(CW\*(C`elink\*(C'\fR, the Link adaptor, and the \f(CW\*(C`linkset\*(C'\fR iterator
.Sp
The \f(CW\*(C`LinkAdaptor\*(C'\fR manages LinkSets. In \f(CW\*(C`SoapEU\*(C'\fR, an \f(CW\*(C`elink\*(C'\fR call
\&\fBalways\fR preserves the correspondence between submitted and retrieved
ids. The mapping between these can be accessed from the adaptor object
directly as \f(CW\*(C`id_map()\*(C'\fR
.Sp
.Vb 3
\& my $links = $fac\->elink( \-db => \*(Aqprotein\*(Aq, 
\&                          \-dbfrom => \*(Aqnucleotide\*(Aq,
\&                          \-id => \e@nucids )\->run( \-auto_adapt => 1 );
\&
\& # maybe more than one associated id...
\& my @prot_0 = $links\->id_map( $nucids[0] );
.Ve
.Sp
Or iterate over the linksets:
.Sp
.Vb 5
\& while ( my $ls = $links\->next_linkset ) {
\&    @ids = $ls\->ids;
\&    @submitted_ids = $ls\->submitted_ids;
\&    # etc.
\& }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`esummary\*(C'\fR, the DocSum adaptor, and the \f(CW\*(C`docsum\*(C'\fR iterator
.Sp
The \f(CW\*(C`DocSumAdaptor\*(C'\fR manages docsums, the \f(CW\*(C`esummary\*(C'\fR return type.
The objects returned by iterating with a \f(CW\*(C`DocSumAdaptor\*(C'\fR have
accessors that let you obtain field information directly. Docsums
contain lots of easy-to-forget fields; use \f(CW\*(C`item_names()\*(C'\fR to remind yourself.
.Sp
.Vb 10
\& my $docs = $fac\->esummary( \-db => \*(Aqtaxonomy\*(Aq,
\&                            \-id => 527031 )\->run(\-auto_adapt=>1);
\& # iterate over docsums
\& while (my $d = $docs\->next_docsum) {
\&    @available_items = $docsum\->item_names;
\&    # any available item can be called as an accessor
\&    # from the docsum object...watch your case...
\&    $sci_name = $d\->ScientificName;
\&    $taxid = $d\->TaxId;
\& }
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`egquery\*(C'\fR, the GQuery adaptor, and the \f(CW\*(C`query\*(C'\fR iterator
.Sp
The \f(CW\*(C`GQueryAdaptor\*(C'\fR manages global query items returned by calls to
\&\f(CW\*(C`egquery\*(C'\fR, which identifies all \s-1NCBI\s0 databases containing hits for
your query term. The databases actually containing hits can be
retrieved directly from the adaptor with \f(CW\*(C`found_in_dbs\*(C'\fR:
.Sp
.Vb 4
\& my $queries = $fac\->egquery( 
\&     \-term => \*(AqBRCA and human\*(Aq
\&    )\->run(\-auto_adapt=>1);
\& my @dbs = $queries\->found_in_dbs;
.Ve
.Sp
Retrieve the global query info returned for \fBany\fR database with \f(CW\*(C`query_by_db\*(C'\fR:
.Sp
.Vb 4
\& my $prot_q = $queries\->query_by_db(\*(Aqprotein\*(Aq);
\& if ($prot_q\->count) {
\&    #do something
\& }
.Ve
.Sp
Or iterate as usual:
.Sp
.Vb 5
\& while ( my $q = $queries\->next_query ) {
\&    if ($q\->status eq \*(AqOk\*(Aq) {
\&      # do sth
\&    }
\& }
.Ve
.SS "Web environments and query keys"
.IX Subsection "Web environments and query keys"
To make large or complex requests for data, or to share queries, it
may be helpful to use the \s-1NCBI\s0 WebEnv system to manage your
queries. Each EUtility accepts the following parameters:
.PP
.Vb 3
\& \-usehistory
\& \-WebEnv
\& \-QueryKey
.Ve
.PP
for this purpose. These store the details of your queries serverside.
.PP
\&\f(CW\*(C`SoapEU\*(C'\fR attempts to make using these relatively straightforward. Use
\&\f(CW\*(C`Result\*(C'\fR objects to obtain the correct parameters, and don't forget
\&\f(CW\*(C`\-usehistory\*(C'\fR:
.PP
.Vb 4
\& my $result1 = $fac\->esearch( 
\&     \-term => \*(AqBRCA and human\*(Aq, 
\&     \-db => \*(Aqnucleotide\*(Aq,
\&     \-usehistory => 1 )\->run( \-no_parse=>1 );
\&
\& my $result = $fac\->esearch( 
\&     \-term => \*(AqAND early onset\*(Aq, 
\&     \-QueryKey => $result1\->query_key,
\&     \-WebEnv => $result1\->webenv )\->run( \-no_parse => 1 );
\&
\& my $result = $fac\->esearch(
\&    \-db => \*(Aqprotein\*(Aq,
\&    \-term => \*(Aqsonic\*(Aq, 
\&    \-usehistory => 1 )\->run( \-no_parse => 1 );
\&
\& # later (but not more than 8 hours later) that day...
\&
\& $result = $fac\->esearch(
\&    \-WebEnv => $result\->webenv,
\&    \-QueryKey => $result\->query_key,
\&    \-RetMax => 800 # get \*(Aqem all
\&    )\->run; # note we\*(Aqre parsing the result...
\& @all_ids = $result\->ids;
.Ve
.SS "Error checking"
.IX Subsection "Error checking"
Two kinds of errors can ensue on an Entrez \s-1SOAP\s0 run. One is a \s-1SOAP\s0
fault, and the other is an error sent in non-faulted \s-1SOAP\s0 message from
the server. The distinction is probably systematic, and I would
welcome an explanation of it. To check for result errors, try something like:
.PP
.Vb 10
\& unless ( $result = $fac\->$util\->run ) {
\&    die $fac\->errstr; # this will catch a SOAP fault
\& }
\& # a valid result object was returned, but it may carry an error
\& if ($result\->count == 0) {
\&    warn "No hits returned";
\&    if ($result\->ERROR) {
\&      warn "Entrez error : ".$result\->ERROR;
\&    }
\& }
.Ve
.PP
Error handling will be improved in the package eventually.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::DB::EUtilities, Bio::DB::SoapEUtilities::Result,
Bio::DB::ESoap.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
bioperl\-l@bioperl.org
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Mark A. Jensen"
.IX Header "AUTHOR - Mark A. Jensen"
Email maj \-at\- fortinbras \-dot\- us
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : my $eutil = new Bio::DB::SoapEUtilities();
\& Function: Builds a new Bio::DB::SoapEUtilities object
\& Returns : an instance of Bio::DB::SoapEUtilities
\& Args    :
.Ve
.SS "\fIrun()\fP"
.IX Subsection "run()"
.Vb 11
\& Title   : run
\& Usage   : $fac\->$eutility\->run(@args)
\& Function: Execute the EUtility
\& Returns : true on success, false on fault or error
\&           (reason in errstr(), for more detail check the SOAP message
\&            in last_result() )
\& Args    : named params appropriate to utility
\&           \-auto_adapt => boolean ( return an iterator over results as 
\&                                    appropriate to util if true)
\&           \-raw_xml => boolean ( return raw xml result; no processing )
\&           Bio::DB::SoapEUtilities::Result constructor parms
.Ve
.SS "Useful Accessors"
.IX Subsection "Useful Accessors"
.SS "\fIresponse_message()\fP"
.IX Subsection "response_message()"
.Vb 6
\& Title   : response_message
\& Aliases : last_response, last_result
\& Usage   : $som = $fac\->response_message
\& Function: get the last response message
\& Returns : a SOAP::SOM object
\& Args    : none
.Ve
.SS "\fIwebenv()\fP"
.IX Subsection "webenv()"
.Vb 6
\& Title   : webenv
\& Usage   : 
\& Function: contains WebEnv key referencing the session
\&           (set after run() )
\& Returns : scalar
\& Args    : none
.Ve
.SS "\fIerrstr()\fP"
.IX Subsection "errstr()"
.Vb 6
\& Title   : errstr
\& Usage   : $fac\->errstr
\& Function: get the last error, if any
\& Example : 
\& Returns : value of errstr (a scalar)
\& Args    : none
.Ve
.SS "Bio::ParameterBaseI compliance"
.IX Subsection "Bio::ParameterBaseI compliance"
.SS "\fIavailable_parameters()\fP"
.IX Subsection "available_parameters()"
.Vb 7
\& Title   : available_parameters
\& Usage   : 
\& Function: get available request parameters for calling
\&           utility
\& Returns : 
\& Args    : \-util => $desired_utility [optional, default is
\&           caller utility]
.Ve
.SS "\fIset_parameters()\fP"
.IX Subsection "set_parameters()"
.Vb 7
\& Title   : set_parameters
\& Usage   : 
\& Function: 
\& Returns : none
\& Args    : \-util => $desired_utility [optional, default is 
\&            caller utility],
\&           named utility arguments
.Ve
.SS "\fIget_parameters()\fP"
.IX Subsection "get_parameters()"
.Vb 6
\& Title   : get_parameters
\& Usage   : 
\& Function: 
\& Returns : array of named parameters
\& Args    : utility (scalar string) [optional]
\&           (default is caller utility)
.Ve
.SS "\fIreset_parameters()\fP"
.IX Subsection "reset_parameters()"
.Vb 7
\& Title   : reset_parameters
\& Usage   : 
\& Function: 
\& Returns : none
\& Args    : \-util => $desired_utility [optional, default is 
\&            caller utility],
\&           named utility arguments
.Ve
.SS "\fIparameters_changed()\fP"
.IX Subsection "parameters_changed()"
.Vb 6
\& Title   : parameters_changed
\& Usage   : 
\& Function: 
\& Returns : boolean
\& Args    : utility (scalar string) [optional]
\&           (default is caller utility)
.Ve
.SS "\fI_soap_facs()\fP"
.IX Subsection "_soap_facs()"
.Vb 7
\& Title   : _soap_facs
\& Usage   : $self\->_soap_facs($util, $fac)
\& Function: caches Bio::DB::ESoap factories for the 
\&           eutils in use by this instance
\& Example : 
\& Returns : Bio::DB::ESoap object
\& Args    : $eutility, [optional on set] $esoap_factory_object
.Ve
.SS "\fI_caller_util()\fP"
.IX Subsection "_caller_util()"
.Vb 7
\& Title   : _caller_util
\& Usage   : $self\->_caller_util($newval)
\& Function: the utility requested off the main SoapEUtilities 
\&           object
\& Example : 
\& Returns : value of _caller_util (a scalar string, a valid eutility)
\& Args    : on set, new value (a scalar string [optional])
.Ve
