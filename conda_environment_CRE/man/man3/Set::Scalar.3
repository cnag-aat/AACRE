.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Set::Scalar 3"
.TH Set::Scalar 3 "2014-03-24" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Set::Scalar \- basic set operations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use Set::Scalar;
\&    $s = Set::Scalar\->new;
\&    $s\->insert(\*(Aqa\*(Aq, \*(Aqb\*(Aq);
\&    $s\->delete(\*(Aqb\*(Aq);
\&    $t = Set::Scalar\->new(\*(Aqx\*(Aq, \*(Aqy\*(Aq, $z);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Creating"
.IX Subsection "Creating"
.Vb 2
\&    $s = Set::Scalar\->new;
\&    $s = Set::Scalar\->new(@members);
\&
\&    $t = $s\->clone;
\&    $t = $s\->copy;         # Clone of clone.
\&    $t = $s\->empty_clone;  # Like clone() but with no members.
.Ve
.SS "Modifying"
.IX Subsection "Modifying"
.Vb 3
\&    $s\->insert(@members);
\&    $s\->delete(@members);
\&    $s\->invert(@members);  # Insert if hasn\*(Aqt, delete if has.
\&
\&    $s\->clear;  # Removes all the elements.
.Ve
.PP
Note that \fIclear()\fR only releases the memory used by the set to
be reused by Perl; it will not reduce the overall memory use.
.SS "Displaying"
.IX Subsection "Displaying"
.Vb 1
\&    print $s, "\en";
.Ve
.PP
The display format of a set is the members of the set separated by
spaces and enclosed in parentheses (), for example:
.PP
.Vb 3
\&   my $s = Set::Scalar\->new();
\&   $s\->insert("a".."e");
\&   print $s, "\en";
.Ve
.PP
will output
.PP
.Vb 1
\&   a b c d e
.Ve
.PP
You can even display recursive sets.
.PP
See \*(L"Customising Display\*(R" for customising the set display.
.SS "Querying"
.IX Subsection "Querying"
Assuming a set \f(CW$s\fR:
.PP
.Vb 2
\&    @members  = $s\->members;
\&    @elements = $s\->elements;  # Alias for members.
\&
\&    @$s  # Overloaded alias for members.
\&
\&    $size = $s\->size;  # The number of members.
\&
\&    $s\->has($m)        # Return true if has that member.
\&    $s\->contains($m)   # Alias for has().
\&
\&    if ($s\->has($member)) { ... }
\&
\&    $s\->member($m)     # Returns the member if has that member.
\&    $s\->element($m)    # Alias for member.
\&
\&    $s\->is_null        # Returns true if the set is empty.
\&    $s\->is_empty       # Alias for is_null.
\&
\&    $s\->is_universal   # Returns true if the set is universal.
\&
\&    $s\->null           # The null set.
\&    $s\->empty          # Alias for null.
\&    $s\->universe       # The universe of the set.
.Ve
.SS "Deriving"
.IX Subsection "Deriving"
.Vb 6
\&    $u = $s\->union($t);
\&    $i = $s\->intersection($t);
\&    $d = $s\->difference($t);
\&    $e = $s\->symmetric_difference($t);
\&    $v = $s\->unique($t);
\&    $c = $s\->complement;
.Ve
.PP
These methods have operator overloads:
.PP
.Vb 6
\&    $u = $s + $t;  # union
\&    $i = $s * $t;  # intersection
\&    $d = $s \- $t;  # difference
\&    $e = $s % $t;  # symmetric_difference
\&    $v = $s / $t;  # unique
\&    $c = \-$s;      # complement
.Ve
.PP
Both the \f(CW\*(C`symmetric_difference\*(C'\fR and \f(CW\*(C`unique\*(C'\fR are symmetric on all
their arguments.  For two sets they are identical but for more than
two sets beware: \f(CW\*(C`symmetric_difference\*(C'\fR returns true for elements
that are in an odd number (1, 3, 5, ...) of sets, \f(CW\*(C`unique\*(C'\fR returns
true for elements that are in one set.
.PP
Some examples of the various set differences below
(the _ is just used to align the elements):
.PP
.Vb 1
\&    set or difference                   value
\&
\&    $a                                  (a b c d e _ _ _ _)
\&    $b                                  (_ _ c d e f g _ _)
\&    $c                                  (_ _ _ _ e f g h i)
\&
\&    $a\->difference($b)                  (a b _ _ _ _ _ _ _)
\&    $a\->symmetric_difference($b)        (a b _ _ _ f g _ _)
\&    $a\->unique($b)                      (a b _ _ _ f g _ _)
\&
\&    $b\->difference($a)                  (_ _ _ _ _ f g _ _)
\&    $b\->symmetric_difference($a)        (a b _ _ _ f g _ _)
\&    $b\->unique($a)                      (a b _ _ _ f g _ _)
\&
\&    $a\->difference($b, $c)              (a b _ _ _ _ _ _ _)
\&    $a\->symmetric_difference($b, $c)    (a b _ _ e _ _ h i)
\&    $a\->unique($b, $c)                  (a b _ _ _ _ _ h i)
.Ve
.SS "Comparing"
.IX Subsection "Comparing"
.Vb 7
\&    $eq = $s\->is_equal($t);
\&    $dj = $s\->is_disjoint($t);
\&    $pi = $s\->is_properly_intersecting($t);
\&    $ps = $s\->is_proper_subset($t);
\&    $pS = $s\->is_proper_superset($t);
\&    $is = $s\->is_subset($t);
\&    $iS = $s\->is_superset($t);
\&
\&    $cmp = $s\->compare($t);
.Ve
.PP
The \f(CW\*(C`compare\*(C'\fR method returns a string from the following list:
\&\*(L"equal\*(R", \*(L"disjoint\*(R", \*(L"proper subset\*(R", \*(L"proper superset\*(R", \*(L"proper
intersect\*(R", and in future (once I get around implementing it),
\&\*(L"disjoint universes\*(R".
.PP
These methods have operator overloads:
.PP
.Vb 7
\&    $eq = $s == $t;  # is_equal
\&    $dj = $s != $t;  # is_disjoint
\&    # No operator overload for is_properly_intersecting.
\&    $ps = $s < $t;   # is_proper_subset
\&    $pS = $s > $t;   # is_proper_superset
\&    $is = $s <= $t;  # is_subset
\&    $iS = $s >= $t;  # is_superset
\&
\&    $cmp = $s <=> $t;
.Ve
.SS "Boolean contexts"
.IX Subsection "Boolean contexts"
In Boolean contexts such as
.PP
.Vb 2
\&    if ($set) { ... }
\&    while ($set1 && $set2) { ... }
.Ve
.PP
the size of the \f(CW$set\fR is tested, so empty sets test as false,
and non-empty sets as true.
.SS "Iterating"
.IX Subsection "Iterating"
.Vb 1
\&    while (defined(my $e = $s\->each)) { ... }
.Ve
.PP
This is more memory-friendly than
.PP
.Vb 1
\&    for my $e ($s\->elements) { ... }
.Ve
.PP
which would first construct the full list of elements and then
walk through it: the \f(CW\*(C`$s\->each\*(C'\fR handles one element at a time.
.PP
Analogously to using normal \f(CW\*(C`each(%hash)\*(C'\fR in scalar context,
using \f(CW\*(C`$s\->each\*(C'\fR has the following caveats:
.IP "\(bu" 4
The elements are returned in (apparently) random order.
So don't expect any particular order.
.IP "\(bu" 4
When no more elements remain \f(CW\*(C`undef\*(C'\fR is returned.  Since you may one
day have elements named \f(CW0\fR don't test just like this
.Sp
.Vb 1
\&    while (my $e = $s\->each) { ... }           # WRONG!
.Ve
.Sp
but instead like this
.Sp
.Vb 1
\&    while (defined(my $e = $s\->each)) { ... }  # Right.
.Ve
.Sp
(An \f(CW\*(C`undef\*(C'\fR as a set element doesn't really work, you get \f(CW""\fR.)
.IP "\(bu" 4
There is one iterator per one set which is shared by many
element-accessing interfaces\*(-- using the following will reset the
iterator: \f(CW\*(C`elements()\*(C'\fR, \f(CW\*(C`insert()\*(C'\fR, \f(CW\*(C`members()\*(C'\fR, \f(CW\*(C`size()\*(C'\fR,
\&\f(CW\*(C`unique()\*(C'\fR.  \f(CW\*(C`insert()\*(C'\fR causes the iterator of the set being
inserted (not the set being the target of insertion) becoming reset.
\&\f(CW\*(C`unique()\*(C'\fR causes the iterators of all the participant sets becoming
reset.  \fBThe iterator getting reset most probably causes an endless
loop.\fR So avoid doing that.
.Sp
For \f(CW\*(C`delete()\*(C'\fR the story is a little bit more complex: it depends
on what element you are deleting and on the version of Perl.  On modern
Perls you can safely delete the element you just deleted.  But deleting
random elements can affect the iterator, so beware.
.IP "\(bu" 4
Modifying the set during the iteration may cause elements to be missed
or duplicated, or in the worst case, an endless loop; so don't do
that, either.
.SS "Cartesian Product and Power Set"
.IX Subsection "Cartesian Product and Power Set"
.IP "\(bu" 4
Cartesian product is a product of two or more sets.  For two sets, it
is the set consisting of \fBordered pairs\fR of members from each set.
For example for the sets
.Sp
.Vb 2
\&  (a b)
\&  (c d e)
.Ve
.Sp
The Cartesian product of the above is the set
.Sp
.Vb 1
\&  ([a, c] [a, d] [a, e] [b, c] [b, d] [b, e])
.Ve
.Sp
The [,] notation is for the ordered pairs, which sets are not.
This means two things: firstly, that [e, b] is \fBnot\fR in the above
Cartesian product, and secondly, [b, b] is a possibility:
.Sp
.Vb 2
\&  (a b)
\&  (b c e)
\&
\&  ([a, b] [a, c] [a, e] [b, b] [b, c] [b, d])
.Ve
.Sp
For example:
.Sp
.Vb 4
\&  my $a = Set::Scalar\->new(1..2);
\&  my $b = Set::Scalar\->new(3..5);
\&  my $c = $a\->cartesian_product($b);  # As an object method.
\&  my $d = Set::Scalar\->cartesian_product($a, $b);  # As a class method.
.Ve
.Sp
The \f(CW$c\fR and \f(CW$d\fR will be of the same class as \f(CW$a\fR.  The members of \f(CW$c\fR and
\&\f(CW$c\fR in the above will be anonymous arrays (array references), not sets,
since sets wouldn't be able to represent the ordering or that a member
can be present more than once.  Also note that since the members of
the input sets are unordered, the ordered pairs themselves are
unlikely to be in any particular order.
.Sp
If you don't want to construct the Cartesian product set, you can
construct an iterator and call it while it returns more members:
.Sp
.Vb 4
\&   my $iter = Set::Scalar\->cartesian_product_iterator($a, $b, $c);
\&   while (my @m = $iter\->()) {
\&     process(@m);
\&   }
.Ve
.IP "\(bu" 4
Power set is the set of all the subsets of a set.  If the set has N
members, its power set has 2**N members.  For example for the set
.Sp
.Vb 1
\&    (a b c)
.Ve
.Sp
size 3, its power set is
.Sp
.Vb 1
\&    (() (a) (b) (c) (a b) (a c) (b c) (a b c))
.Ve
.Sp
size 8.  Note that since the elements of the power set are sets, they
are unordered, and therefore (b c) is equal to (c b).  For example:
.Sp
.Vb 3
\&    my $a = Set::Scalar\->new(1..3);
\&    my $b = $a\->power_set;               # As an object method.
\&    my $c = Set::Scalar\->power_set($a);  # As a class method.
.Ve
.Sp
Even the empty set has a power set, of size one.
.Sp
If you don't want to construct the power set, you can construct an
iterator and call it until it returns no more members:
.Sp
.Vb 6
\&   my $iter = Set::Scalar\->power_set_iterator($a);
\&   my @m;
\&   do {
\&     @m = $iter\->();
\&     process(@m);
\&   } while (@m);
.Ve
.SS "Customising Display"
.IX Subsection "Customising Display"
If you want to customise the display routine you will have to
modify the \f(CW\*(C`as_string\*(C'\fR callback.  You can modify it either
for all sets by using \f(CW\*(C`as_string_callback()\*(C'\fR as a class method:
.PP
.Vb 1
\&    my $class_callback = sub { ... };
\&
\&    Set::Scalar\->as_string_callback($class_callback);
.Ve
.PP
or for specific sets by using \f(CW\*(C`as_string_callback()\*(C'\fR as an object
method:
.PP
.Vb 1
\&    my $callback = sub  { ... };
\&
\&    $s1\->as_string_callback($callback);
\&    $s2\->as_string_callback($callback);
.Ve
.PP
The anonymous subroutine gets as its first (and only) argument the
set to display as a string.  For example to display the set \f(CW$s\fR
as \f(CW\*(C`a\-b\-c\-d\-e\*(C'\fR instead of \f(CW\*(C`(a b c d e)\*(C'\fR
.PP
.Vb 1
\&    $s\->as_string_callback(sub{join("\-",sort $_[0]\->elements)});
.Ve
.PP
If called without an argument, the current callback is returned.
.PP
If called as a class method with undef as the only argument, the
original callback (the one returning \f(CW\*(C`(a b c d e)\*(C'\fR) for all the sets
is restored, or if called for a single set the callback is removed
(and the callback for all the sets will be used).
.SH "CAVEATS"
.IX Header "CAVEATS"
The first priority of Set::Scalar is to be a convenient interface to sets.
While not designed to be slow or big, neither has it been designed to
be fast or compact.
.PP
Using references (or objects) as set members has not been extensively
tested.  The desired semantics are not always clear: what should
happen when the elements behind the references change? Especially
unclear is what should happen when the objects start having their
own stringification overloads.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Set::Bag for bags (multisets, counted sets), and Bit::Vector for fast
set operations (you have to take care of the element name to bit
number and back mappings yourself), or Set::Infinite for sets of
intervals, and many more.  \s-1CPAN\s0 is your friend.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi <jhi@iki.fi>
David Oswald <davido@cpan.org> is the current maintainer.
The GitHub repo is at <https://github.com/daoswald/Set\-Scalar>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2001,2002,2003,2004,2005,2007,2009,2013 by Jarkko Hietaniemi
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
