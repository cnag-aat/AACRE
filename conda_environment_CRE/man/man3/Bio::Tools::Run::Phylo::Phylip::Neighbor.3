.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Run::Phylo::Phylip::Neighbor 3"
.TH Bio::Tools::Run::Phylo::Phylip::Neighbor 3 "2019-10-28" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::Run::Phylo::Phylip::Neighbor \- Wrapper for the phylip
program neighbor by Joseph Felsenstein for creating a phylogenetic
tree(either through Neighbor or UPGMA) based on protein distances
based on amino substitution rate.
.PP
14 Nov 2002 Shawn
Works with Phylip version 3.6
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  #Create a SimpleAlign object
\&  @params = (\*(Aqktuple\*(Aq => 2, \*(Aqmatrix\*(Aq => \*(AqBLOSUM\*(Aq);
\&  $factory = Bio::Tools::Run::Alignment::Clustalw\->new(@params);
\&  $inputfilename = \*(Aqt/data/cysprot.fa\*(Aq;
\&  $aln = $factory\->run($inputfilename); # $aln is a SimpleAlign object.
\&
\&  # Create the Distance Matrix
\&  # using a default PAM matrix and id name lengths limit of 30 note to
\&  # use id name length greater than the standard 10 in neighbor, you
\&  # will need to modify the neighbor source code
\&
\&  $protdist_factory = Bio::Tools::Run::Phylo::Phylip::ProtDist\->new(@params);
\&  my $matrix  = $protdist_factory\->run($aln);
\&
\&  #Create the tree passing in the distance matrix
\&  @params = (\*(Aqtype\*(Aq=>\*(AqNJ\*(Aq,\*(Aqoutgroup\*(Aq=>2,\*(Aqlowtri\*(Aq=>1,
\&             \*(Aqupptri\*(Aq=>1,\*(Aqsubrep\*(Aq=>1);
\&
\&  my $neighbor_factory = 
\&     Bio::Tools::Run::Phylo::Phylip::Neighbor\->new(@params);
\&
\&  #you can set your outgroup using either a number specifying
\&  #the rank in the matrix or you can just use the name of the
\&  #species
\&
\&  $neighbor_factory\->outgroup(\*(AqENSP00001\*(Aq);
\&  #or
\&  $neighbor_factory\->outgroup(1);
\&
\&  my ($tree) = $neighbor_factory\->run($matrix);
\&
\&  # Alternatively, one can create the tree by passing in a file name 
\&  # containing a phylip formatted distance matrix(using protdist)
\&  my $neighbor_factory = 
\&    Bio::Tools::Run::Phylo::Phylip::Neighbor\->new(@params);
\&  my ($tree) = $neighbor_factory\->run(\*(Aq/home/shawnh/prot.dist\*(Aq);
\&
\&  # To prevent PHYLIP from truncating sequence names:
\&  # Step 1. Shelf the original names:
\&    my ($aln_safe, $ref_name)=                    #   $aln_safe has serial names
\&               $aln\->set_displayname_safe();      #   $ref_name holds original names
\&  # Step 2. Run ProtDist and Neighbor:
\&    $matrix  = $protdist_factory\->
\&                creat_distance_matrix($aln_safe); #  Use $aln_safe instead of $aln
\&    $tree = $neighbor_factory\->run($matrix);
\&  # Step 3. Retrieve orgininal OTU names:
\&    use Bio::Tree::Tree;
\&    my @nodes=$tree\->get_nodes();
\&    foreach my $nd (@nodes){
\&       $nd\->id($ref_name\->{$nd\->id_output}) if $nd\->is_Leaf;
\&    }
.Ve
.SH "PARAMTERS FOR NEIGHBOR COMPUTATION"
.IX Header "PARAMTERS FOR NEIGHBOR COMPUTATION"
.SS "\s-1TYPE\s0"
.IX Subsection "TYPE"
.Vb 4
\&  Title         : TYPE
\&  Description   : (optional)
\&                  This sets the type of tree to construct, using
\&                  neighbor joining or UPGMA.
\&
\&                  NJ    Neighbor Joining
\&                  UPGMA UPGMA
\&
\&  Usage         : @params = (\*(Aqtype\*(Aq=>\*(AqX\*(Aq);#where X is one of the values above
\&                  Defaults to NJ 
\&
\&                  For more information on the usage of the different
\&                  models, please refer to the documentation found in
\&                  the phylip package.
.Ve
.SS "\s-1OUTGROUP\s0 (*ONLY \s-1AVAILABLE FOR NEIGHBOR JOINING\s0)"
.IX Subsection "OUTGROUP (*ONLY AVAILABLE FOR NEIGHBOR JOINING)"
.Vb 8
\&  Title         : OUTGROUP 
\&  Description   : (optional)
\&                  This option selects the species to be used as the outgroup
\&  Acceptable Values: integer 
\&  Usage         : @params = (\*(Aqoutgroup\*(Aq=>\*(AqX\*(Aq); 
\&                  where X is an positive integer not more than the 
\&                  number of sequences 
\&                  Defaults to 1
.Ve
.SS "\s-1LOWTRI\s0"
.IX Subsection "LOWTRI"
.Vb 8
\&  Title         : LOWTRI
\&  Description   : (optional)
\&                  This indicates that the distance matrix is 
\&                  input  in  Lower\-triangular form  (the  lower\-left 
\&                  half of the distance matrix only, without the zero 
\&                  diagonal elements)
\&  Usage         : @params = (\*(Aqlowtri\*(Aq=>\*(AqX\*(Aq); where X is either 1 or 0 
\&                  Defaults to 0
.Ve
.SS "\s-1UPPTRI\s0"
.IX Subsection "UPPTRI"
.Vb 7
\&  Title         : UPPTRI 
\&  Description   : (optional)
\&                  This indicates that the distance matrix is input  in  
\&                  upper\-triangular form  (the  upper\-right half of the 
\&                  distance matrix only, without the zero diagonal elements.)
\&Usage           : @params = (\*(Aqupptri\*(Aq=>\*(AqX\*(Aq); where X is either 1 or 0 
\&                  Defaults to 0
.Ve
.SS "\s-1SUBREP\s0"
.IX Subsection "SUBREP"
.Vb 3
\&  Title         : SUBREP 
\&  Description   : (optional)
\&                  This is the Subreplication option.  
\&
\&                  It informs the program that after each distance will
\&                  be provided an integer indicating that the distance
\&                  is a mean of that many replicates.
\&
\&  Usage         : @params = (\*(Aqsubrep\*(Aq=>\*(AqX\*(Aq); where X is either 1 or 0 
\&                  Defaults to 0
.Ve
.SS "\s-1JUMBLE\s0"
.IX Subsection "JUMBLE"
.Vb 2
\&  Title        : JUMBLE 
\&  Description  : (optional)
\&
\&                 This enables you to tell the program to use a random
\&                 number generator to choose the input order of
\&                 species.  seed: an integer between 1 and 32767 and of
\&                 the form 4n+1 which means that it must give a
\&                 remainder of 1 when divided by 4.  Each different
\&                 seed leads to a different sequence of addition of
\&                 species.  By simply changing the random number seed
\&                 and re\-running programs one can look for other, and
\&                 better trees.  iterations:
\&
\&  Usage        : @params = (\*(Aqjumble\*(Aq=>\*(Aq17); where 17 is the random seed
\&                 Defaults to no jumble
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Shawn Hoon"
.IX Header "AUTHOR - Shawn Hoon"
Email shawnh@fugu\-sg.org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Email:jason\-at\-bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "program_name"
.IX Subsection "program_name"
.Vb 5
\& Title   : program_name
\& Usage   : >program_name()
\& Function: holds the program name
\& Returns:  string
\& Args    : None
.Ve
.SS "program_dir"
.IX Subsection "program_dir"
.Vb 5
\& Title   : program_dir
\& Usage   : \->program_dir()
\& Function: returns the program directory, obtained from ENV variable.
\& Returns:  string
\& Args    :
.Ve
.SS "idlength"
.IX Subsection "idlength"
.Vb 5
\& Title   : idlength 
\& Usage   : $obj\->idlength ($newval)
\& Function: 
\& Returns : value of idlength 
\& Args    : newvalue (optional)
.Ve
.SS "run"
.IX Subsection "run"
.Vb 8
\& Title   : run 
\& Usage   :
\&        $inputfilename = \*(Aqt/data/prot.dist\*(Aq;
\&        $tree = $neighborfactory\->run($inputfilename);
\& or
\&        $protdist_factory = Bio::Tools::Run::Phylo::Phylip::ProtDist\->new(@params);
\&        $matrix  = $protdist_factory\->create_distance_matrix($aln);
\&        $tree= $neighborfactory\->run($matrix);
\&
\& Function: a Bio:Tree from a protein distance matrix created by protidst 
\& Example :
\& Returns : Bio::Tree 
\& Args    : Name of a file containing a protein distance matrix in Phylip format
\&           or a hash ref to a matrix 
\&
\& Throws an exception if argument is not either a string (eg a
\& filename) or a Hash. If argument is string, throws exception 
\& if file corresponding to string name can not be found.
.Ve
.SS "create_tree"
.IX Subsection "create_tree"
.Vb 7
\& Title   : create_tree
\& Usage   : my $file = $app\->create_tree($treefile);
\& Function: This method is deprecated. Please use run method. 
\& Returns : File containing the rendered tree 
\& Args    : either a Bio::Tree::TreeI 
\&            OR
\&           filename of a tree in newick format
.Ve
.SS "_run"
.IX Subsection "_run"
.Vb 7
\& Title   :  _run
\& Usage   :  Internal function, not to be called directly        
\& Function:   makes actual system call to neighbor program
\& Example :
\& Returns : Bio::Tree object
\& Args    : Name of a file containing protein distances in Phylip format 
\&           and a parameter string to be passed to neighbor
.Ve
.SS "\fI_setinput()\fP"
.IX Subsection "_setinput()"
.Vb 7
\& Title   : _setinput
\& Usage   : Internal function, not to be called directly 
\& Function: Create input file for neighbor program
\& Example :
\& Returns : name of file containing the protein distance matrix in Phylip format 
\& Args    : name of file created by protdist or ref to hash created by 
\&           Bio::Tools:Run::Phylo::Phylip::ProtDist
.Ve
.SS "\fInames()\fP"
.IX Subsection "names()"
.Vb 7
\& Title   :  names
\& Usage   :  $tree\->names(\e%names)
\& Function:  get/set for a hash ref for storing names in matrix
\&            with rank as values.
\& Example :
\& Returns : hash reference 
\& Args    : hash reference
.Ve
.SS "\fI_setparams()\fP"
.IX Subsection "_setparams()"
.Vb 6
\& Title   :  _setparams
\& Usage   :  Internal function, not to be called directly        
\& Function:   Create parameter inputs for neighbor program
\& Example :
\& Returns : parameter string to be passed to neighbor
\& Args    : name of calling object
.Ve
.SS "outfile"
.IX Subsection "outfile"
.Vb 5
\& Title   : outfile
\& Usage   : $obj\->outfile($newval)
\& Function: Get/Set default PHYLIP outfile name (\*(Aqoutfile\*(Aq usually)
\& Returns : value of outfile
\& Args    : newvalue (optional)
.Ve
.SS "treefile"
.IX Subsection "treefile"
.Vb 5
\& Title   : treefile
\& Usage   : $obj\->treefile($newval)
\& Function: Get/Set the default PHYLIP treefile name (\*(Aqtreefile\*(Aq usually)
\& Returns : value of treefile
\& Args    : newvalue (optional)
.Ve
