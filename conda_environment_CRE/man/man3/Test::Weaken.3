.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Test::Weaken 3"
.TH Test::Weaken 3 "2012-12-01" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Weaken \- Test that freed memory objects were, indeed, freed
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Test::Weaken qw(leaks);
\&
\& # basic leaks detection
\& my $leaks = leaks(sub {
\&                    my $obj = { one => 1,
\&                                two => [],
\&                                three => [3,3,3] };
\&                    return $obj;
\&                   });
\& if ($leaks) {
\&     print "There were memory leaks from test 1!\en";
\&     printf "%d of %d original references were not freed\en",
\&         $leaks\->unfreed_count(), $leaks\->probe_count();
\& } else {
\&     print "No leaks in test 1\en";
\& }
\&
\& # or with various options
\& $leaks = Test::Weaken::leaks(
\&    { constructor => sub {
\&        my @array = (42, 711);
\&        push @array, \e@array;  # circular reference
\&        return \e@array;
\&      },
\&      destructor  => sub {
\&        print "This could invoke an object destructor\en";
\&      },
\&      ignore  => sub {
\&        my ($ref) = @_;
\&        if (some_condition($ref)) {
\&          return 1;  # ignore
\&        }
\&        return 0; # don\*(Aqt ignore
\&      },
\&      contents  => sub {
\&        my ($ref) = @_;
\&        return extract_more_from($ref);
\&      },
\&    });
\& if ($leaks) {
\&     print "There were memory leaks from test 2!\en";
\&     my $unfreed_proberefs = $leaks\->unfreed_proberefs();
\&     print "These are the probe references to the unfreed objects:\en";
\&     require Data::Dumper;
\&     foreach my $ref (@$unfreed_proberefs) {
\&         print "ref $ref\en";
\&         print Data::Dumper\->Dump([$ref], [\*(Aqunfreed\*(Aq]);
\&     }
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Test::Weaken\*(C'\fR helps detect unfreed Perl data in arrays, hashes, scalars,
objects, etc, by descending recursively through structures and watching that
everything is freed.  Unfreed data is a useless overhead and may cause an
application to abend due to lack of memory.
.PP
Normally if the last reference to something is discarded then it and
anything in it is freed automatically.  But this might not occur due to
circular references, unexpected global variables or closures, or reference
counting mistakes in XSUBs.
.PP
\&\f(CW\*(C`Test::Weaken\*(C'\fR is named for the strategy used to detect leaks.  References
are taken to the test objects and all their contents, then those references
are weakened and expected to be then freed.
.PP
There's options to ignore intentional globals, or include extra associated
data held elsewhere, or invoke an explicit destructor.  Unfreed parts are
reported and can be passed to other modules such as Devel::FindRef to try
to discover why they weren't freed.
.PP
\&\f(CW\*(C`Test::Weaken\*(C'\fR examines structures to an unlimited depth and is safe on
circular structures.
.SS "Tracking and Children"
.IX Subsection "Tracking and Children"
\&\f(CW\*(C`Test::Weaken\*(C'\fR determines the contents of a data structure by the contents
of the top object of the test data structure, and recursively into the
contents of those sub-parts.  The following data types are tracked and their
contents examined,
.PP
.Vb 5
\&    ARRAY       each of its values
\&    HASH        each of its values
\&    SCALAR      if a reference then the target thing
\&    CODE        no contents as yet
\&    tie ANY     the associated tie object from tied()
.Ve
.PP
In an array or hash each scalar value has an independent existence and
\&\f(CW\*(C`Test::Weaken\*(C'\fR tracks each individually (see \*(L"Array and Hash Keys and
Values\*(R" below).
.PP
\&\f(CW\*(C`CODE\*(C'\fR objects, ie. subroutines, are not examined for children.  This is a
limitation, because closures do hold internal references to data objects.
Future versions of \f(CW\*(C`Test::Weaken\*(C'\fR might descend into \s-1CODE\s0 objects.
.PP
The following types are not tracked by default and not examined for
contents,
.PP
.Vb 4
\&    GLOB
\&    IO         underlying a file handle
\&    FORMAT     always global
\&    LVALUE
.Ve
.PP
GLOBs are usually either an entry in the Perl symbol table or a filehandle.
An \s-1IO\s0 is the file object underlying a filehandle.  Perl symbol tables are
usually permanent and shouldn't be tracked, but see \*(L"File Handles\*(R" below
for tracking open files.
.PP
Builtin types added to Perl in the future and not known to \f(CW\*(C`Test::Weaken\*(C'\fR
will not be tracked by default but could be requested with \f(CW\*(C`tracked_types\*(C'\fR
below.
.PP
A variable of builtin type \s-1GLOB\s0 may be
a scalar which was assigned a \s-1GLOB\s0 value
(a scalar-GLOB) or it may simply be a \s-1GLOB\s0 (a pure-GLOB).
The issue that arises for
\&\f(CW\*(C`Test::Weaken\*(C'\fR is that,
in the case of a scalar-GLOB,
the scalar and the \s-1GLOB\s0 may be tied separately.
At present,
the underlying tied variable of the scalar side of a
scalar-GLOB is ignored.
Only the underlying tied variable of the \s-1GLOB\s0
is a child for
\&\f(CW\*(C`Test::Weaken\*(C'\fR's purposes.
.SS "Returns and Exceptions"
.IX Subsection "Returns and Exceptions"
The methods of \f(CW\*(C`Test::Weaken\*(C'\fR do not return errors.
Errors are always thrown as exceptions.
.SH "EXPORTS"
.IX Header "EXPORTS"
By default, \f(CW\*(C`Test::Weaken\*(C'\fR exports nothing.  Optionally, \f(CW\*(C`leaks()\*(C'\fR may be
requested in usual \f(CW\*(C`Exporter\*(C'\fR style (see Exporter).  (And \f(CW\*(C`poof()\*(C'\fR from
\&\*(L"\s-1OLD FUNCTIONS\*(R"\s0 too if desired.)
.PP
.Vb 2
\&    use Test::Weaken \*(Aqleaks\*(Aq;   # import
\&    my $tester = leaks (...);
.Ve
.SH "PORCELAIN METHODS"
.IX Header "PORCELAIN METHODS"
.SS "leaks"
.IX Subsection "leaks"
.Vb 8
\&    my $leaks = Test::Weaken::leaks(
\&        {   constructor => sub { Buggy_Object\->new() },
\&            destructor  => \e&destroy_buggy_object,
\&        }
\&    );
\&    if ($leaks) {
\&        print "There are leaks\en";
\&    }
.Ve
.PP
Check for leaks in the object created by the constructor function and return
either an evaluated \f(CW\*(C`Test::Weaken\*(C'\fR object instance if there are leaks, or
Perl false if there are no leaks.
.PP
Instances of the \f(CW\*(C`Test::Weaken\*(C'\fR class are called \fBtesters\fR.
An \fBevaluated\fR tester is one on which the
tests have been run
and for which results are available.
.PP
Users who only want to know if there were unfreed data objects can
check the return value of \f(CW\*(C`leaks()\*(C'\fR for Perl true or false.
Arguments to \f(CW\*(C`leaks()\*(C'\fR are passed as a
hashref of named arguments.
\&\f(CW\*(C`leaks()\*(C'\fR can also be called in a \*(L"short form\*(R",
where the constructor and destructor
are passed directly as code references.
.ie n .IP """constructor => $coderef""" 4
.el .IP "\f(CWconstructor => $coderef\fR" 4
.IX Item "constructor => $coderef"
The \f(CW\*(C`constructor\*(C'\fR argument is required.
Its value must be a coderef returning a reference to the test data structure.
.Sp
.Vb 4
\&    my $leaks = leaks ({ constructor => sub {
\&                           return Some::Object\->new(123);
\&                         },
\&                       });
.Ve
.Sp
For \*(L"short form\*(R" the constructor coderef is the first
argument,
.Sp
.Vb 3
\&    leaks (sub {
\&             return Some::Object\->new(123);
\&          });
.Ve
.Sp
If the constructor returns a list of objects then all are checked.
.Sp
.Vb 3
\&    leaks (sub {
\&             return (Foo\->new(), Bar\->new());
\&          });
.Ve
.Sp
Usually this is when two objects are somehow inter-related and should weaken
away together, or perhaps sub-parts of an object not reached by the contents
tracing (or see \f(CW\*(C`contents\*(C'\fR below for a more general way to reach such
sub-parts.)
.ie n .IP """destructor => $coderef""" 4
.el .IP "\f(CWdestructor => $coderef\fR" 4
.IX Item "destructor => $coderef"
.PD 0
.ie n .IP """destructor_method => $methodname""" 4
.el .IP "\f(CWdestructor_method => $methodname\fR" 4
.IX Item "destructor_method => $methodname"
.PD
An optional destructor is called just before \f(CW\*(C`Test::Weaken\*(C'\fR tries to free
everything.  Some test objects or structures might require explicit
destruction when they're to be freed.
.Sp
\&\f(CW\*(C`destructor\*(C'\fR is called with the objects returned by the constructor
.Sp
.Vb 1
\&    &$destructor ($obj, ...)
.Ve
.Sp
For example,
.Sp
.Vb 6
\&    leaks ({ constructor => sub { return make_some_thing() },
\&             destructor  => sub {
\&                              my ($thing) = @_;
\&                              delete $thing\->{\*(Aqcircular_ref\*(Aq};
\&                            },
\&          });
.Ve
.Sp
For \*(L"short form\*(R" the destructor is an optional second argument,
.Sp
.Vb 5
\&    leaks (sub { Foo\->new },
\&           sub {
\&             my ($foo) = @_;
\&             $foo\->destroy;
\&           });
.Ve
.Sp
\&\f(CW\*(C`destructor_method\*(C'\fR is called as a method on each object returned by the
constructor,
.Sp
.Vb 1
\&    $obj\->$methodname();
.Ve
.Sp
For example if the constructed object (or objects) require an explicit
\&\f(CW\*(C`$foo\->destroy()\*(C'\fR then
.Sp
.Vb 2
\&    leaks ({ constructor => sub { Foo\->new },
\&             destructor_method => \*(Aqdestroy\*(Aq });
.Ve
.Sp
If both \f(CW\*(C`destructor\*(C'\fR and \f(CW\*(C`destructor_method\*(C'\fR are given then
\&\f(CW\*(C`destructor_method\*(C'\fR calls are first, then \f(CW\*(C`destructor\*(C'\fR.
.Sp
An explicit destructor may be needed for things like toplevel windows in \s-1GUI\s0
toolkits such as Wx and Gtk (and perhaps also some main loop iterations if
actual destruction is delayed).  Some object-oriented tree structures may
need explicit destruction too if parent and child nodes keep hard references
to each other, though it's usually more convenient if child\->parent is
only a weak reference.  (See also Object::Destroyer.)
.ie n .IP """ignore => $coderef""" 4
.el .IP "\f(CWignore => $coderef\fR" 4
.IX Item "ignore => $coderef"
.PD 0
.ie n .IP """ignore_preds => [ $coderef, $coderef, ...]""" 4
.el .IP "\f(CWignore_preds => [ $coderef, $coderef, ...]\fR" 4
.IX Item "ignore_preds => [ $coderef, $coderef, ...]"
.ie n .IP """ignore_class => $classname""" 4
.el .IP "\f(CWignore_class => $classname\fR" 4
.IX Item "ignore_class => $classname"
.ie n .IP """ignore_classes => [ $classname, $classname, ... ]""" 4
.el .IP "\f(CWignore_classes => [ $classname, $classname, ... ]\fR" 4
.IX Item "ignore_classes => [ $classname, $classname, ... ]"
.ie n .IP """ignore_object => $ref""" 4
.el .IP "\f(CWignore_object => $ref\fR" 4
.IX Item "ignore_object => $ref"
.ie n .IP """ignore_objects => [ $ref, $ref, ... ]""" 4
.el .IP "\f(CWignore_objects => [ $ref, $ref, ... ]\fR" 4
.IX Item "ignore_objects => [ $ref, $ref, ... ]"
.PD
Ignore some things.  When a thing is ignored it's not tracked for leaks and
its contents are not examined.
.Sp
\&\f(CW\*(C`ignore\*(C'\fR and \f(CW\*(C`ignore_preds\*(C'\fR take predicate functions.  If any of them
return true then the thing \f(CW$ref\fR refers to is ignored.
.Sp
.Vb 1
\&    $bool = &$coderef ($ref);
.Ve
.Sp
For example
.Sp
.Vb 9
\&    sub ignore_all_tied_hashes {
\&        my ($ref) = @_;
\&        return (ref $ref eq \*(AqHASH\*(Aq
\&                && defined (tied %$ref));
\&    }
\&    my $tester = Test::Weaken::leaks(
\&        { constructor => sub { MyObject\->new() },
\&          ignore      => \e&ignore_all_tied_hashes,
\&        });
.Ve
.Sp
\&\f(CW\*(C`ignore_class\*(C'\fR and \f(CW\*(C`ignore_classes\*(C'\fR ignore blessed objects which are of
the given class or classes.  For example,
.Sp
.Vb 4
\&    my $leaks = Test::Weaken::leaks(
\&        { constructor => sub { MyObject\->new() },
\&          ignore_class => \*(AqMy::Singleton\*(Aq,
\&        }
\&
\&    my $leaks = Test::Weaken::leaks(
\&        { constructor => sub { MyObject\->new() },
\&          ignore_classes => [ \*(AqMy::Singleton\*(Aq,
\&                              \*(AqMy::PrinterDriver\*(Aq ],
\&        }
.Ve
.Sp
Objects are checked with
.Sp
.Vb 1
\&    blessed($ref) && $ref\->isa($classname)
.Ve
.Sp
which reaches any class-specific \f(CW\*(C`isa()\*(C'\fR in the object in the usual way.
That allows classes to masquerade or have a dynamic \*(L"isa\*(R".  That's normally
fine and can be highly desirable in things like lazy loaders.
.Sp
\&\f(CW\*(C`ignore_object\*(C'\fR and \f(CW\*(C`ignore_objects\*(C'\fR ignore the particular things referred
to by the each given \f(CW$ref\fR.  For example,
.Sp
.Vb 4
\&    my $leaks = Test::Weaken::leaks(
\&        { constructor => sub { MyObject\->new() },
\&          ignore_object => \e%global_data,
\&        }
\&
\&    my $leaks = Test::Weaken::leaks(
\&        { constructor => sub { MyObject\->new() },
\&          ignore_objects => [ $obj1, $obj2 ],
\&        }
.Ve
.Sp
For both \f(CW\*(C`ignore_object\*(C'\fR and \f(CW\*(C`ignore_objects\*(C'\fR any \f(CW\*(C`undef\*(C'\fRs among the refs
are ignored.  This is handy if a global might or might not have been
initialized yet.  These options are called \*(L"object\*(R" because they're most
often used with blessed objects, but unblessed things are fine too.
.Sp
\&\f(CW\*(C`ignore\*(C'\fR callbacks should not change the contents of \f(CW$ref\fR.  Doing so
might cause an exception, an infinite loop, or erroneous results.  See
\&\*(L"Debugging Ignore Subroutines\*(R" for a little help against bad \f(CW\*(C`ignore\*(C'\fR.
.Sp
When comparing references in a predicate it's good to use
\&\f(CW\*(C`Scalar::Util::refaddr()\*(C'\fR.  Plain \f(CW\*(C`$ref==$something\*(C'\fR can be tricked if
\&\f(CW$ref\fR is an object with overloaded numize or \f(CW\*(C`==\*(C'\fR (see overload).
.Sp
Another way to ignore is let globals etc go through as leaks and then filter
them from the \f(CW\*(C`$leaks\->unfreed_proberefs()\*(C'\fR afterwards.  The benefit of
\&\f(CW\*(C`ignore\*(C'\fR is that it excludes object contents too.
.IP "contents" 4
.IX Item "contents"
An optional \f(CW\*(C`contents\*(C'\fR function can tell \f(CW\*(C`Test::Weaken\*(C'\fR about additional
Perl data objects which should be checked.
.Sp
.Vb 12
\&    sub my_extra_contents {
\&      my ($ref) = @_;
\&      if (blessed($ref) && $ref\->isa(\*(AqMyObject\*(Aq)) {
\&        return $ref\->data, $ref\->moredata;
\&      } else {
\&        return;
\&      }
\&    }
\&    my $leaks = Test::Weaken::leaks(
\&        { constructor => sub { return MyObject\->new },
\&          contents    => \e&my_extra_contents
\&        });
.Ve
.Sp
The given \f(CW$coderef\fR is called for each Perl data object.  It should return
a list of additional Perl data objects, or an empty list if no extra
contents.
.Sp
.Vb 1
\&    @extra_contents = &$coderef ($ref);
.Ve
.Sp
\&\f(CW\*(C`contents\*(C'\fR allows OOPery such as \*(L"inside-out\*(R" where object contents are
held separately.  It can also be used on wrappers for C\-code objects where
some of the contents of a widget etc are not in Perl level structures but
only available through object method calls etc.
.Sp
\&\f(CW\*(C`contents\*(C'\fR and \f(CW\*(C`ignore\*(C'\fR can be used together.  \f(CW\*(C`ignore\*(C'\fR is called first
and if not ignored then \f(CW\*(C`contents\*(C'\fR is called.
.IP "tracked_types" 4
.IX Item "tracked_types"
Optional \f(CW\*(C`tracked_types\*(C'\fR is an arrayref of additional builtin types to
track.
.Sp
.Vb 8
\&    my $test = Test::Weaken::leaks(
\&        {   constructor => sub {
\&                my $obj = MyObject\->new;
\&                return $obj;
\&            },
\&            tracked_types => [\*(AqGLOB\*(Aq],
\&        }
\&    );
.Ve
.Sp
The default tracking is per \*(L"Tracking and Children\*(R" above.  The additional
types which may be tracked are
.Sp
.Vb 4
\&    GLOB
\&    IO
\&    FORMAT
\&    LVALUE
.Ve
.Sp
These names are per \f(CW\*(C`reftype()\*(C'\fR of Scalar::Util.  See \*(L"File Handles\*(R"
below for setting up to track GLOBs as filehandles.
.SS "unfreed_proberefs"
.IX Subsection "unfreed_proberefs"
.Vb 7
\&    my $tester = Test::Weaken::leaks( sub { Buggy_Object\->new() } );
\&    if ($tester) {
\&        my $unfreed_proberefs = $tester\->unfreed_proberefs();
\&        foreach my $ref (@$unfreed_proberefs) {
\&            print "unfreed: $ref\en";
\&        }
\&    }
.Ve
.PP
Return an arrayref of references to unfreed data objects.  Throws an
exception if there is a problem, for example if the tester has not yet been
evaluated.
.PP
The return value can be examined to pinpoint the source of a leak or produce
statistics about unfreed data objects.
.SS "unfreed_count"
.IX Subsection "unfreed_count"
.Vb 5
\&    my $tester = Test::Weaken::leaks( sub { Buggy_Object\->new() } );
\&    if ($tester) {
\&      printf "%d objects were not freed\en",
\&        $tester\->unfreed_count();
\&    }
.Ve
.PP
Return the count of unfreed data objects.
This is the  length of the \f(CW\*(C`unfreed_proberefs()\*(C'\fR arrayref.
Throws an exception if there is a problem,
for example if the tester has not yet been evaluated.
.SS "probe_count"
.IX Subsection "probe_count"
.Vb 8
\&        my $tester = Test::Weaken::leaks(
\&            {   constructor => sub { Buggy_Object\->new() },
\&                destructor  => \e&destroy_buggy_object,
\&            }
\&        );
\&        next TEST if not $tester;
\&        printf "%d of %d objects were not freed\en",
\&            $tester\->unfreed_count(), $tester\->probe_count();
.Ve
.PP
Return the total number of probe references in the test,
including references to freed data objects.
This is the count of probe references
after \f(CW\*(C`Test::Weaken\*(C'\fR was finished finding the descendants of
the test structure reference,
but before \f(CW\*(C`Test::Weaken\*(C'\fR called the test structure destructor or reset the
test structure reference to \f(CW\*(C`undef\*(C'\fR.
Throws an exception if there is a problem,
for example if the tester has not yet been evaluated.
.SH "PLUMBING METHODS"
.IX Header "PLUMBING METHODS"
Most users can skip this section.
The plumbing methods exist to satisfy object-oriented purists,
and to accommodate the rare user who wants to access the probe counts
even when the test did find any unfreed data objects.
.SS "new"
.IX Subsection "new"
.Vb 6
\&    my $tester        = Test::Weaken\->new( sub { My_Object\->new() } );
\&    my $unfreed_count = $tester\->test();
\&    my $proberefs     = $tester\->unfreed_proberefs();
\&    printf "%d of %d objects freed\en",
\&        $unfreed_count,
\&        $tester\->probe_count();
.Ve
.PP
The \*(L"new\*(R" method takes the same arguments as the \*(L"leaks\*(R" method, described above.
Unlike the \*(L"leaks\*(R" method, it always returns an \fBunevaluated\fR tester.
An \fBunevaluated\fR tester is one on which the test has not yet
been run and for which results are not yet available.
If there are any problems, the \*(L"new\*(R"
method throws an exception.
.PP
The \*(L"test\*(R" method is the only method that can be called successfully on
an unevaluated tester.
Calling any other method on an unevaluated tester causes an exception to be thrown.
.SS "test"
.IX Subsection "test"
.Vb 6
\&    my $tester = Test::Weaken\->new(
\&        {   constructor => sub { My_Object\->new() },
\&            destructor  => \e&destroy_my_object,
\&        }
\&    );
\&    printf "There are %s\en", ( $tester\->test() ? \*(Aqleaks\*(Aq : \*(Aqno leaks\*(Aq );
.Ve
.PP
Converts an unevaluated tester into an evaluated tester.
It does this by performing the test
specified
by the arguments to the \*(L"new\*(R" constructor
and recording the results.
Throws an exception if there is a problem,
for example if the tester had already been evaluated.
.PP
The \*(L"test\*(R" method returns the count of unfreed data objects.
This will be identical to the length of the array
returned by \*(L"unfreed_proberefs\*(R" and
the count returned by \*(L"unfreed_count\*(R".
.SH "ADVANCED TECHNIQUES"
.IX Header "ADVANCED TECHNIQUES"
.SS "File Handles"
.IX Subsection "File Handles"
File handles are references to GLOBs and by default are not tracked.  If a
handle is a package global like \f(CW\*(C`open FH, "</file/name"\*(C'\fR then that's
probably what you want.  But if you use anonymous handles either from the
Symbol module or Perl 5.6 autovivified then it's good to check the handle
is freed.  This can be done by asking for \s-1GLOB\s0 and \s-1IO\s0 in \f(CW\*(C`tracked_types\*(C'\fR,
and extracting the \s-1IO\s0 from any \s-1GLOB\s0 encountered,
.PP
.Vb 8
\&    sub contents_glob_IO {
\&      my ($ref) = @_;
\&      if (ref($ref) eq \*(AqGLOB\*(Aq) {
\&        return *$ref{IO};
\&      } else {
\&        return;
\&      }
\&    }
\&
\&    my $leaks = Test::Weaken::leaks
\&      ({ constructor => sub { return MyFileObject\->new },
\&         contents => \e&contents_glob_IO,
\&         tracked_types => [ \*(AqGLOB\*(Aq, \*(AqIO\*(Aq ],
\&       });
.Ve
.PP
It's good to check the \s-1IO\s0 too since it's possible for a reference elsewhere
to keep it alive, in particular a Perl-level \*(L"dup\*(R" can make another handle
\&\s-1GLOB\s0 pointing to that same \s-1IO,\s0
.PP
.Vb 2
\&    open my $dupfh, \*(Aq<\*(Aq, $fh;
\&    # $dupfh holds and uses *$fh{IO}
.Ve
.PP
See Test::Weaken::ExtraBits for such a \f(CW\*(C`contents_glob_IO()\*(C'\fR, if you want
to use a module rather than copying couple of lines for that function.
.SS "Array and Hash Keys and Values"
.IX Subsection "Array and Hash Keys and Values"
As noted above each value in a hash or array is a separate scalar and is
tracked separately.  Usually such scalars are only used in their containing
hash or array, but it's possible to hold a reference to a particular element
and \f(CW\*(C`leaks()\*(C'\fR can notice if that causes it to be unfreed.
.PP
.Vb 2
\&    my %hash = (foo => 123);
\&    my $ref = \e$hash{\*(Aqfoo\*(Aq};  # ref to hash value
.Ve
.PP
It's possible to put specific scalars as the values in a hash or array.
They might be globals or whatever.  Usually that would arise from \s-1XSUB\s0 code,
but Array::RefElem can do the same from Perl code,
.PP
.Vb 4
\&    use Array::RefElem \*(Aqav_store\*(Aq;
\&    my $global;
\&    my @array;
\&    av_store (@array, 0, $global);
.Ve
.PP
In \s-1XSUB\s0 code a little care is needed that refcounts are correct after
\&\f(CW\*(C`av_store()\*(C'\fR or \f(CW\*(C`hv_store()\*(C'\fR takes ownership of one count etc.  In all
cases \f(CW\*(C`Test::Weaken\*(C'\fR can notice when an array or hash element doesn't
destroy with its container.  \f(CW\*(C`ignore\*(C'\fR etc will be needed for those which
are intentionally persistent.
.PP
Hash keys are not separate scalars.  They're strings managed entirely by the
hash and there's nothing separate for \f(CW\*(C`Test::Weaken\*(C'\fR to track.
.PP
Tie::RefHash and similar which allow arbitrary objects as keys of a hash
do so by using the object \f(CW\*(C`refaddr()\*(C'\fR internally as the string key but
presenting objects in \f(CW\*(C`keys()\*(C'\fR, \f(CW\*(C`each()\*(C'\fR, etc.  As of Tie::RefHash 1.39
and Tie::RefHash::Weak 0.09 those two modules hold the key objects within
their tie object and therefore those key objects are successfully reached by
\&\f(CW\*(C`Test::Weaken\*(C'\fR for leak checking in the usual way.
.SS "Tracing Leaks"
.IX Subsection "Tracing Leaks"
\fIAvoidance\fR
.IX Subsection "Avoidance"
.PP
\&\f(CW\*(C`Test::Weaken\*(C'\fR makes tracing leaks easier, but avoidance is
still by far the best way,
and \f(CW\*(C`Test::Weaken\*(C'\fR helps with that.
You need to use test-driven development, Test::More,
modular tests in a \f(CW\*(C`t/\*(C'\fR subdirectory,
and revision control.
These are all very good ideas for many other reasons.
.PP
Make \f(CW\*(C`Test::Weaken\*(C'\fR part of your test suite.
Test frequently, so that when a leak occurs,
you'll have a good idea of what changes were made since
the last successful test.
Often, examining these changes is enough to
tell where the leak was introduced.
.PP
\fIAdding Tags\fR
.IX Subsection "Adding Tags"
.PP
The \*(L"unfreed_proberefs\*(R" method returns an array containing
probes to
the unfreed
data objects.
This can be used
to find the source of leaks.
If circumstances allow it,
you might find it useful to add \*(L"tag\*(R" elements to arrays and hashes
to aid in identifying the source of a leak.
.PP
\fIUsing Referent Addresses\fR
.IX Subsection "Using Referent Addresses"
.PP
You can quasi-uniquely identify data objects using
the referent addresses of the probe references.
A referent address
can be determined by using \f(CW\*(C`refaddr()\*(C'\fR from
Scalar::Util.
You can also obtain the referent address of a reference by adding 0
to the reference.
.PP
Note that in other Perl documentation, the term \*(L"reference address\*(R" is often
used when a referent address is meant.
Any given reference has both a reference address and a referent address.
The \fBreference address\fR is the reference's own location in memory.
The \fBreferent address\fR is the address of the Perl data object to which the reference refers.
It is the referent address that interests us here and,
happily, it is
the referent address that both zero addition
and refaddr return.
.PP
\fIOther Techniques\fR
.IX Subsection "Other Techniques"
.PP
Sometimes, when you are interested in why an object is not being freed,
you want to seek out the reference
that keeps the object's refcount above 0.
Devel::FindRef can be useful for this.
.SS "More About Quasi-Unique Addresses"
.IX Subsection "More About Quasi-Unique Addresses"
I call referent addresses \*(L"quasi-unique\*(R", because they are only
unique at a
specific point in time.
Once an object is freed, its address can be reused.
Absent other evidence,
a data object with a given referent address
is not 100% certain to be
the same data object
as the object that had the same address earlier.
This can bite you
if you're not careful.
.PP
To be sure an earlier data object and a later object with the same address
are actually the same object,
you need to know that the earlier object will be persistent,
or to compare the two objects.
If you want to be really pedantic,
even an exact match from a comparison doesn't settle the issue.
It is possible that two indiscernable
(that is, completely identical)
objects with the same referent address are different in the following
sense:
the first data object might have been destroyed
and a second, identical,
object created at the same address.
But for most practical programming purposes,
two indiscernable data objects can be regarded as the same object.
.SS "Debugging Ignore Subroutines"
.IX Subsection "Debugging Ignore Subroutines"
\fIcheck_ignore\fR
.IX Subsection "check_ignore"
.PP
.Vb 5
\&    $tester = Test::Weaken::leaks(
\&        {   constructor => sub { MyObject\->new() },
\&            ignore => Test::Weaken::check_ignore( \e&ignore_my_global ),
\&        }
\&    );
.Ve
.PP
.Vb 7
\&    $tester = Test::Weaken::leaks(
\&        {   constructor => sub { DeepObject\->new() },
\&            ignore      => Test::Weaken::check_ignore(
\&                \e&cause_deep_problem, 99, 0, $reporting_depth
\&            ),
\&        }
\&    );
.Ve
.PP
It can be hard to determine if
\&\f(CW\*(C`ignore\*(C'\fR callback subroutines
are inadvertently
modifying the test structure.
The
Test::Weaken::check_ignore
static method is
provided to make this task easier.
Test::Weaken::check_ignore
constructs
a debugging wrapper from
four arguments, three of which are optional.
The first argument must be the ignore callback
that you are trying to debug.
This callback is called the test subject, or
\&\fBlab rat\fR.
.PP
The second, optional argument, is the maximum error count.
Below this count, errors are reported as warnings using Carp::carp.
When the maximum error count is reached, an
exception is thrown using Carp::croak.
The maximum error count, if defined,
must be an number greater than or equal to 0.
By default the maximum error count is 1,
which means that the first error will be thrown
as an exception.
.PP
If the maximum error count is 0, all errors will be reported
as warnings and no exception will ever be thrown.
Infinite loops are a common behavior of
buggy lab rats,
and setting the maximum error
count to 0 will usually not be something you
want to do.
.PP
The third, optional, argument is the \fBcompare depth\fR.
It is the depth to which the probe referents will be checked,
as described below.
It must be a number greater than or equal to 0.
If the compare depth is 0, the probe referent is checked
to unlimited depth.
By default the compare depth is 0.
.PP
This fourth, optional, argument is the \fBreporting depth\fR.
It is the depth to which the probe referents are dumped
in
check_ignore's
error messages.
It must be a number greater than or equal to \-1.
If the reporting depth is 0, the object is dumped to unlimited depth.
If the reporting depth is \-1, there is no dump in the error message.
By default, the reporting depth is \-1.
.PP
Test::Weaken::check_ignore
returns a reference to the wrapper callback.
If no problems are detected,
the wrapper callback behaves exactly like the lab rat callback,
except that the wrapper is slower.
.PP
To discover when and if the lab rat callback is
altering its arguments,
Test::Weaken::check_ignore
compares the test structure
before the lab rat is called,
to the test structure after the lab rat returns.
Test::Weaken::check_ignore
compares the before and after test structures in two ways.
First, it dumps the contents of each test structure using
Data::Dumper.
For comparison purposes,
the dump using Data::Dumper is performed with \f(CW\*(C`Maxdepth\*(C'\fR
set to the compare depth as described above.
Second, if the immediate probe referent has builtin type \s-1REF,\s0
Test::Weaken::check_ignore
determines whether the immediate probe referent
is a weak reference or a strong one.
.PP
If either comparison shows a difference,
the wrapper treats it as a problem, and
produces an error message.
This error message is either a Carp::carp warning or a
Carp::croak exception, depending on the number of error
messages already reported and the setting of the
maximum error count.
If the reporting depth is a non-negative number, the error
message includes a dump from Data::Dumper of the
test structure.
\&\f(CW\*(C`Data::Dumper\*(C'\fR's \f(CW\*(C`Maxdepth\*(C'\fR
for reporting purposes is the reporting depth as described above.
.PP
A user who wants other features, such as deep checking
of the test structure
for strengthened references,
can easily 
copy
\&\f(CW\*(C`check_ignore()\*(C'\fR
from the \f(CW\*(C`Test::Weaken\*(C'\fR source
and hack it up.
\&\f(CW\*(C`check_ignore()\*(C'\fR
is a static method
that does not use any \f(CW\*(C`Test::Weaken\*(C'\fR
package resources.
The hacked version can reside anywhere,
and does not need to
be part of the \f(CW\*(C`Test::Weaken\*(C'\fR package.
.SH "XSUB Mortalizing"
.IX Header "XSUB Mortalizing"
When a C code \s-1XSUB\s0 returns a newly created scalar it should \*(L"mortalize\*(R" so
the scalar is freed once the caller has finished with it.  See
\&\*(L"Reference Counts and Mortality\*(R" in perlguts.  Failing to do so leaks memory.
.PP
.Vb 3
\&    SV *ret = newSViv(123);
\&    sv_2mortal (ret);   /* must mortalize */
\&    XPUSHs (ret);
.Ve
.PP
\&\f(CW\*(C`Test::Weaken\*(C'\fR can check this by taking a reference to the returned
scalar,
.PP
.Vb 4
\&    my $leaks = leaks (sub {
\&                         return \e( somexsub() );
\&                       });
\&    if ($leaks) ...
.Ve
.PP
Don't store to a new local scalar and then return that since doing so will
only check the local scalar, not the one made by \f(CW\*(C`somexsub()\*(C'\fR.
.PP
If you want the value for further calculations then first take a reference
to the return and then look through that for the value.
.PP
.Vb 6
\&    leaks (sub {
\&             my $ref = \e( somexsub() );
\&             my $value = $$ref;
\&             # ... do something with $value
\&             return $ref;
\&           });
.Ve
.PP
If an \s-1XSUB\s0 returns a list of values then take a reference to each as
follows.  This works because \f(CW\*(C`map\*(C'\fR and \f(CW\*(C`for\*(C'\fR make the loop variable (\f(CW$_\fR
or named) an alias to each value successively (see \*(L"map\*(R" in perlfunc and
\&\*(L"Foreach Loops\*(R" in perlsyn).
.PP
.Vb 3
\&    leaks (sub {
\&             return [ map {\e$_} somexsub() ];
\&           });
\&
\&    # or with a for loop
\&    leaks (sub {
\&             my @refs;
\&             foreach my $value (somexsub()) {
\&               push @refs, \e$value;
\&             }
\&             return \e@refs;
\&           });
.Ve
.PP
Don't store a returned list to an array (named or anonymous) since this
copies into new scalars in that array and the returned ones from
\&\f(CW\*(C`somexsub()\*(C'\fR then aren't checked.
.PP
If you want the returned values for extra calculations then take the
references first and look through them for the values, as in the single case
above.  For example,
.PP
.Vb 7
\&    leaks (sub {
\&             my @refs = map {\e$_} somexsub();
\&             my $first_ref = $refs[0]
\&             my $value = $$first_ref;
\&             # ... do something with $value
\&             return \e@refs;
\&           });
.Ve
.PP
An \s-1XSUB\s0 might deliberately return the same scalar each time, perhaps a
pre-calculated constant or a global variable it maintains.  In that case the
scalar intentionally won't weaken away and this \f(CW\*(C`leaks()\*(C'\fR checking is not
applicable.
.PP
Returning the same scalar every time occurs in pure Perl too with an
anonymous constant subr such as created by the \f(CW\*(C`constant\*(C'\fR module (see
constant).  This is unlikely to arise directly, but might be seen through
a scalar ref within an object etc.
.PP
.Vb 2
\&    # FOO() returns same scalar every time
\&    *FOO = sub () { 123 };
\&
\&    # same from the constant module
\&    use constant BAR => 456;
.Ve
.PP
It's up to an \s-1XSUB\s0 etc how long return values are supposed to live.  But
generally if the code has any sort of \f(CW\*(C`newSV()\*(C'\fR or \f(CW\*(C`sv_newmortal()\*(C'\fR etc to
make a new scalar as its return then that ought to weaken away.
.PP
The details of an \s-1XSUB\s0 return are often hidden in a \fItypemap\fR file for
brevity and consistency (see \*(L"The Typemap\*(R" in perlxs).  The standard typemap
conversions of \fIExtutils/typemap\fR are easy to use correctly.  But code with
explicit \f(CW\*(C`PUSHs()\*(C'\fR etc is worth checking.  The reference counting rules for
\&\f(CW\*(C`av_push()\*(C'\fR etc are slightly subtle too if building nested structures in
\&\s-1XS.\s0  Usually missing mortalizing or ref count sinking will leak objects
which \f(CW\*(C`Test::Weaken\*(C'\fR can detect.  Too much mortalizing or ref count sinking
will cause negative refcounts and probable segfaults.
.SH "OLD FUNCTIONS"
.IX Header "OLD FUNCTIONS"
The following \f(CW\*(C`poof()\*(C'\fR was from \f(CW\*(C`Test::Weaken\*(C'\fR 1.0 and has been superseded
in 2.0 by \f(CW\*(C`leaks()\*(C'\fR which is easier to use.
.ie n .IP """my $unfreed_count = Test::Weaken::poof(sub { return $obj });""" 4
.el .IP "\f(CWmy $unfreed_count = Test::Weaken::poof(sub { return $obj });\fR" 4
.IX Item "my $unfreed_count = Test::Weaken::poof(sub { return $obj });"
.PD 0
.ie n .IP """my ($weak_count, $strong_count, $weak_unfreed_aref, $strong_unfreed_aref) = Test::Weaken::poof(sub { return $obj });""" 4
.el .IP "\f(CWmy ($weak_count, $strong_count, $weak_unfreed_aref, $strong_unfreed_aref) = Test::Weaken::poof(sub { return $obj });\fR" 4
.IX Item "my ($weak_count, $strong_count, $weak_unfreed_aref, $strong_unfreed_aref) = Test::Weaken::poof(sub { return $obj });"
.PD
Check that \f(CW$obj\fR returned by the given constructor subroutine is freed
when weakened.  This is the same as \f(CW\*(C`leaks()\*(C'\fR except for the style of the
return values.
.Sp
In scalar context the return is a count of unfreed references.  If
everything is freed then this is 0.
.Sp
.Vb 6
\&    my $unfreed_count = Test::Weaken::poof(sub { return [1,2,3] });
\&    if ($unfreed_count == 0 {
\&      print "No leaks\en";
\&    } else {
\&      print "There were leaks\en";
\&    }
.Ve
.Sp
In array context the return is four values
.Sp
.Vb 3
\&    my ($weak_count, $strong_count,
\&        $weak_unfreed_aref, $strong_unfreed_aref)
\&      = Test::Weaken::poof (sub { return $obj });
\&
\&    $weak_count             count of weak refs examined
\&    $strong_count           count of strong refs examined
\&    $weak_unfreed_aref      arrayref of unfreed weak refs
\&    $strong_unfreed_aref    arrayref of unfreed strong refs
.Ve
.Sp
The counts are total references examined.  The arrayrefs give the unfreed
ones.  A distinction is made between strong references and weak references
in the test structure.  If there's no leaks then both \f(CW$weak_unfreed_aref\fR
and \f(CW$strong_unfreed_aref\fR are empty arrays.
.Sp
There's usually not much interest in whether an unfreed thing was from a
weak or strong reference.  In the new \f(CW\*(C`leaks()\*(C'\fR the \f(CW\*(C`unfreed_proberefs()\*(C'\fR
gives both together.  The could be separated there by checking \f(CW\*(C`isweak()\*(C'\fR
on each if desired.
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
.SS "Overview"
.IX Subsection "Overview"
\&\f(CW\*(C`Test::Weaken\*(C'\fR first recurses through the test structure.
Starting from the test structure reference,
it examines data objects for children recursively,
until it has found the complete contents of the test structure.
The test structure is explored to unlimited depth.
For each tracked Perl data object, a
probe reference is created.
Tracked data objects are recorded.
In the recursion, no object is visited twice,
and infinite loops will not occur,
even in the presence of cycles.
.PP
Once recursion through the test structure is complete,
the probe references are weakened.
This prevents the probe references from interfering
with the normal deallocation of memory.
Next, the test structure destructor is called,
if there is one.
.PP
Finally, the test structure reference is set to \f(CW\*(C`undef\*(C'\fR.
This should trigger the deallocation of the entire contents of the test structure.
To check that this happened, \f(CW\*(C`Test::Weaken\*(C'\fR dereferences the probe references.
If the referent of a probe reference was deallocated,
the value of that probe reference will be \f(CW\*(C`undef\*(C'\fR.
If a probe reference is still defined at this point,
it refers to an unfreed Perl data object.
.SS "Why the Test Structure is Passed Via a Closure"
.IX Subsection "Why the Test Structure is Passed Via a Closure"
\&\f(CW\*(C`Test::Weaken\*(C'\fR gets its test structure reference
indirectly,
as the return value from a
\&\fBtest structure constructor\fR.
Why so roundabout?
.PP
Because the indirect way is the easiest.
When you
create the test structure
in \f(CW\*(C`Test::Weaken\*(C'\fR's calling environment,
it takes a lot of craft to avoid
leaving
unintended references to the test structure in that calling environment.
It is easy to get this wrong.
Those unintended references will
create memory leaks that are artifacts of the test environment.
Leaks that are artifacts of the test environment
are very difficult to sort out from the real thing.
.PP
The \fBclosure-local strategy\fR is the easiest way
to avoid leaving unintended references to the
contents of Perl data objects.
Using the closure-local strategy means working
entirely within a closure,
using only data objects local to that closure.
Data objects local to a closure will be destroyed when the
closure returns, and any references they held will be released.
The closure-local strategy makes
it relatively easy to be sure that nothing is left behind
that will hold an unintended reference
to any of the contents
of the test structure.
.PP
Nothing prevents a user from
subverting the closure-local strategy.
A test structure constructor
can return a reference to a test structure
created from Perl data objects in any scope the user desires.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jeffrey Kegler
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-test\-weaken at
rt.cpan.org\*(C'\fR, or through the web interface at
.PP
.Vb 1
\&    http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Weaken
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Test::Weaken
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Test\-Weaken>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Test\-Weaken>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test\-Weaken>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Test\-Weaken>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Weaken::ExtraBits, miscellaneous extras
.PP
Test::Weaken::Gtk2, extras for use with Gtk2\-Perl
.PP
Scalar::Util,
Scalar::Util::Instance
.PP
\&\f(CW\*(C`Test::Weaken\*(C'\fR
at this point is robust
and has 
seen extensive use.
Its tracking of memory is careful enough
that it has even stumbled upon
a bug in perl 
itself <http://rt.perl.org/rt3/Public/Bug/Display.html?id=67838>.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to jettero, Juerd, morgon and perrin of Perlmonks for their advice.
Thanks to Lincoln Stein (developer of Devel::Cycle) for
test cases and other ideas.
Kevin Ryde made many important suggestions
and provided the test cases which
provided the impetus
for the versions 2.000000 and after.
For version 3.000000, Kevin also provided patches.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012 Jeffrey Kegler, all rights reserved.
.PP
Copyright 2012 Kevin Ryde
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl 5.10.
