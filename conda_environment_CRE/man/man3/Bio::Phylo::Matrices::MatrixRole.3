.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::Matrices::MatrixRole 3"
.TH Bio::Phylo::Matrices::MatrixRole 3 "2014-03-27" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Phylo::Matrices::MatrixRole \- Extra behaviours for a character state matrix
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Bio::Phylo::Factory;
\& my $fac = Bio::Phylo::Factory\->new;
\&
\& # instantiate taxa object
\& my $taxa = $fac\->create_taxa;
\& for ( \*(AqHomo sapiens\*(Aq, \*(AqPan paniscus\*(Aq, \*(AqPan troglodytes\*(Aq ) {
\&     $taxa\->insert( $fac\->create_taxon( \*(Aq\-name\*(Aq => $_ ) );
\& }
\&
\& # instantiate matrix object, \*(Aqstandard\*(Aq data type. All categorical
\& # data types follow semantics like this, though with different
\& # symbols in lookup table and matrix
\& my $standard_matrix = $fac\->create_matrix(
\&     \*(Aq\-type\*(Aq   => \*(AqSTANDARD\*(Aq,
\&     \*(Aq\-taxa\*(Aq   => $taxa,
\&     \*(Aq\-lookup\*(Aq => { 
\&         \*(Aq\-\*(Aq => [],
\&         \*(Aq0\*(Aq => [ \*(Aq0\*(Aq ],
\&         \*(Aq1\*(Aq => [ \*(Aq1\*(Aq ],
\&         \*(Aq?\*(Aq => [ \*(Aq0\*(Aq, \*(Aq1\*(Aq ],
\&     },
\&     \*(Aq\-labels\*(Aq => [ \*(AqOpposable big toes\*(Aq, \*(AqOpposable thumbs\*(Aq, \*(AqNot a pygmy\*(Aq ],
\&     \*(Aq\-matrix\*(Aq => [
\&         [ \*(AqHomo sapiens\*(Aq    => \*(Aq0\*(Aq, \*(Aq1\*(Aq, \*(Aq1\*(Aq ],
\&         [ \*(AqPan paniscus\*(Aq    => \*(Aq1\*(Aq, \*(Aq1\*(Aq, \*(Aq0\*(Aq ],
\&         [ \*(AqPan troglodytes\*(Aq => \*(Aq1\*(Aq, \*(Aq1\*(Aq, \*(Aq1\*(Aq ],
\&     ],
\& );
\& 
\& # note: complicated constructor for mixed data!
\& my $mixed_matrix = Bio::Phylo::Matrices::Matrix\->new( 
\&    
\&    # if you want to create \*(Aqmixed\*(Aq, value for \*(Aq\-type\*(Aq is array ref...
\&    \*(Aq\-type\*(Aq =>  [ 
\&    
\&        # ...with first field \*(Aqmixed\*(Aq...                
\&        \*(Aqmixed\*(Aq,
\&        
\&        # ...second field is an array ref...
\&        [
\&            
\&            # ...with _ordered_ key/value pairs...
\&            \*(Aqdna\*(Aq      => 10, # value is length of type range
\&            \*(Aqstandard\*(Aq => 10, # value is length of type range
\&            
\&            # ... or, more complicated, value is a hash ref...
\&            \*(Aqrna\*(Aq      => {
\&                \*(Aq\-length\*(Aq => 10, # value is length of type range
\&                
\&                # ...value for \*(Aq\-args\*(Aq is an array ref with args 
\&                # as can be passed to \*(Aqunmixed\*(Aq datatype constructors,
\&                # for example, here we modify the lookup table for
\&                # rna to allow both \*(AqU\*(Aq (default) and \*(AqT\*(Aq
\&                \*(Aq\-args\*(Aq   => [
\&                    \*(Aq\-lookup\*(Aq => {
\&                        \*(AqA\*(Aq => [ \*(AqA\*(Aq                     ],
\&                        \*(AqC\*(Aq => [ \*(AqC\*(Aq                     ],
\&                        \*(AqG\*(Aq => [ \*(AqG\*(Aq                     ],
\&                        \*(AqU\*(Aq => [ \*(AqU\*(Aq                     ],
\&                        \*(AqT\*(Aq => [ \*(AqT\*(Aq                     ],
\&                        \*(AqM\*(Aq => [ \*(AqA\*(Aq, \*(AqC\*(Aq                ],
\&                        \*(AqR\*(Aq => [ \*(AqA\*(Aq, \*(AqG\*(Aq                ],
\&                        \*(AqS\*(Aq => [ \*(AqC\*(Aq, \*(AqG\*(Aq                ],
\&                        \*(AqW\*(Aq => [ \*(AqA\*(Aq, \*(AqU\*(Aq, \*(AqT\*(Aq           ],
\&                        \*(AqY\*(Aq => [ \*(AqC\*(Aq, \*(AqU\*(Aq, \*(AqT\*(Aq           ],
\&                        \*(AqK\*(Aq => [ \*(AqG\*(Aq, \*(AqU\*(Aq, \*(AqT\*(Aq           ],
\&                        \*(AqV\*(Aq => [ \*(AqA\*(Aq, \*(AqC\*(Aq, \*(AqG\*(Aq           ],
\&                        \*(AqH\*(Aq => [ \*(AqA\*(Aq, \*(AqC\*(Aq, \*(AqU\*(Aq, \*(AqT\*(Aq      ],
\&                        \*(AqD\*(Aq => [ \*(AqA\*(Aq, \*(AqG\*(Aq, \*(AqU\*(Aq, \*(AqT\*(Aq      ],
\&                        \*(AqB\*(Aq => [ \*(AqC\*(Aq, \*(AqG\*(Aq, \*(AqU\*(Aq, \*(AqT\*(Aq      ],
\&                        \*(AqX\*(Aq => [ \*(AqG\*(Aq, \*(AqA\*(Aq, \*(AqU\*(Aq, \*(AqT\*(Aq, \*(AqC\*(Aq ],
\&                        \*(AqN\*(Aq => [ \*(AqG\*(Aq, \*(AqA\*(Aq, \*(AqU\*(Aq, \*(AqT\*(Aq, \*(AqC\*(Aq ],
\&                    },
\&                ],
\&            },
\&        ],
\&    ],
\& );
\& 
\& # prints \*(Aqmixed(Dna:1\-10, Standard:11\-20, Rna:21\-30)\*(Aq
\& print $mixed_matrix\->get_type;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines a container object that holds
Bio::Phylo::Matrices::Datum objects. The matrix
object inherits from Bio::Phylo::Listable, so the
methods defined there apply here.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1CONSTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR"
.IP "\fInew()\fR" 4
.IX Item "new()"
Matrix constructor.
.Sp
.Vb 9
\& Type    : Constructor
\& Title   : new
\& Usage   : my $matrix = Bio::Phylo::Matrices::Matrix\->new;
\& Function: Instantiates a Bio::Phylo::Matrices::Matrix
\&           object.
\& Returns : A Bio::Phylo::Matrices::Matrix object.
\& Args    : \-type   => optional, but if used must be FIRST argument, 
\&                      defines datatype, one of dna|rna|protein|
\&                      continuous|standard|restriction|[ mixed => [] ]
\&
\&           \-taxa   => optional, link to taxa object
\&           \-lookup => character state lookup hash ref
\&           \-labels => array ref of character labels
\&           \-matrix => two\-dimensional array, first element of every
\&                      row is label, subsequent are characters
.Ve
.IP "\fInew_from_bioperl()\fR" 4
.IX Item "new_from_bioperl()"
Matrix constructor from Bio::Align::AlignI argument.
.Sp
.Vb 10
\& Type    : Constructor
\& Title   : new_from_bioperl
\& Usage   : my $matrix = 
\&           Bio::Phylo::Matrices::Matrix\->new_from_bioperl(
\&               $aln           
\&           );
\& Function: Instantiates a 
\&           Bio::Phylo::Matrices::Matrix object.
\& Returns : A Bio::Phylo::Matrices::Matrix object.
\& Args    : An alignment that implements Bio::Align::AlignI
.Ve
.SS "\s-1MUTATORS\s0"
.IX Subsection "MUTATORS"
.IP "set_special_symbols" 4
.IX Item "set_special_symbols"
Sets three special symbols in one call
.Sp
.Vb 10
\& Type    : Mutator
\& Title   : set_special_symbols
\& Usage   : $matrix\->set_special_symbols( 
\&                       \-missing   => \*(Aq?\*(Aq, 
\&                       \-gap       => \*(Aq\-\*(Aq, 
\&                       \-matchchar => \*(Aq.\*(Aq 
\&                   );
\& Function: Assigns state labels.
\& Returns : $self
\& Args    : Three args (with distinct $x, $y and $z):
\&                       \-missing   => $x, 
\&                       \-gap       => $y, 
\&                       \-matchchar => $z
\& Notes   : This method is here to ensure
\&           you don\*(Aqt accidentally use the
\&           same symbol for missing AND gap
.Ve
.IP "\fIset_charlabels()\fR" 4
.IX Item "set_charlabels()"
Sets argument character labels.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : set_charlabels
\& Usage   : $matrix\->set_charlabels( [ \*(Aqchar1\*(Aq, \*(Aqchar2\*(Aq, \*(Aqchar3\*(Aq ] );
\& Function: Assigns character labels.
\& Returns : $self
\& Args    : ARRAY, or nothing (to reset);
.Ve
.IP "\fIset_raw()\fR" 4
.IX Item "set_raw()"
Set contents using two-dimensional array argument.
.Sp
.Vb 7
\& Type    : Mutator
\& Title   : set_raw
\& Usage   : $matrix\->set_raw( [ [ \*(Aqtaxon1\*(Aq => \*(Aqacgt\*(Aq ], [ \*(Aqtaxon2\*(Aq => \*(Aqacgt\*(Aq ] ] );
\& Function: Syntax sugar to define $matrix data contents.
\& Returns : $self
\& Args    : A two\-dimensional array; first dimension contains matrix rows,
\&           second dimension contains taxon name / character string pair.
.Ve
.SS "\s-1ACCESSORS\s0"
.IX Subsection "ACCESSORS"
.IP "\fIget_special_symbols()\fR" 4
.IX Item "get_special_symbols()"
Retrieves hash ref for missing, gap and matchchar symbols
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_special_symbols
\& Usage   : my %syms = %{ $matrix\->get_special_symbols };
\& Function: Retrieves special symbols
\& Returns : HASH ref, e.g. { \-missing => \*(Aq?\*(Aq, \-gap => \*(Aq\-\*(Aq, \-matchchar => \*(Aq.\*(Aq }
\& Args    : None.
.Ve
.IP "\fIget_charlabels()\fR" 4
.IX Item "get_charlabels()"
Retrieves character labels.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_charlabels
\& Usage   : my @charlabels = @{ $matrix\->get_charlabels };
\& Function: Retrieves character labels.
\& Returns : ARRAY
\& Args    : None.
.Ve
.IP "\fIget_nchar()\fR" 4
.IX Item "get_nchar()"
Calculates number of characters.
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : get_nchar
\& Usage   : my $nchar = $matrix\->get_nchar;
\& Function: Calculates number of characters (columns) in matrix (if the matrix
\&           is non\-rectangular, returns the length of the longest row).
\& Returns : INT
\& Args    : none
.Ve
.IP "\fIget_ntax()\fR" 4
.IX Item "get_ntax()"
Calculates number of taxa (rows) in matrix.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_ntax
\& Usage   : my $ntax = $matrix\->get_ntax;
\& Function: Calculates number of taxa (rows) in matrix
\& Returns : INT
\& Args    : none
.Ve
.IP "\fIget_raw()\fR" 4
.IX Item "get_raw()"
Retrieves a 'raw' (two-dimensional array) representation of the matrix's contents.
.Sp
.Vb 8
\& Type    : Accessor
\& Title   : get_raw
\& Usage   : my $rawmatrix = $matrix\->get_raw;
\& Function: Retrieves a \*(Aqraw\*(Aq (two\-dimensional array) representation
\&           of the matrix\*(Aqs contents.
\& Returns : A two\-dimensional array; first dimension contains matrix rows,
\&           second dimension contains taxon name and characters.
\& Args    : NONE
.Ve
.SS "\s-1CALCULATIONS\s0"
.IX Subsection "CALCULATIONS"
.IP "\fIcalc_prop_invar()\fR" 4
.IX Item "calc_prop_invar()"
Calculates proportion of invariant sites.
.Sp
.Vb 12
\& Type    : Calculation
\& Title   : calc_prop_invar
\& Usage   : my $pinvar = $matrix\->calc_prop_invar;
\& Function: Calculates proportion of invariant sites.
\& Returns : Scalar: a number
\& Args    : Optional:
\&           # if true, counts missing (usually the \*(Aq?\*(Aq symbol) as a state
\&           # in the final tallies. Otherwise, missing states are ignored
\&           \-missing => 1
\&           # if true, counts gaps (usually the \*(Aq\-\*(Aq symbol) as a state
\&           # in the final tallies. Otherwise, gap states are ignored
\&           \-gap => 1
.Ve
.IP "\fIcalc_state_counts()\fR" 4
.IX Item "calc_state_counts()"
Calculates occurrences of states.
.Sp
.Vb 6
\& Type    : Calculation
\& Title   : calc_state_counts
\& Usage   : my %counts = %{ $matrix\->calc_state_counts };
\& Function: Calculates occurrences of states.
\& Returns : Hashref: keys are states, values are counts
\& Args    : Optional \- one or more states to focus on
.Ve
.IP "\fIcalc_state_frequencies()\fR" 4
.IX Item "calc_state_frequencies()"
Calculates the frequencies of the states observed in the matrix.
.Sp
.Vb 10
\& Type    : Calculation
\& Title   : calc_state_frequencies
\& Usage   : my %freq = %{ $object\->calc_state_frequencies() };
\& Function: Calculates state frequencies
\& Returns : A hash, keys are state symbols, values are frequencies
\& Args    : Optional:
\&           # if true, counts missing (usually the \*(Aq?\*(Aq symbol) as a state
\&           # in the final tallies. Otherwise, missing states are ignored
\&           \-missing => 1
\&           # if true, counts gaps (usually the \*(Aq\-\*(Aq symbol) as a state
\&           # in the final tallies. Otherwise, gap states are ignored
\&           \-gap => 1
\& Comments: Throws exception if matrix holds continuous values
.Ve
.IP "\fIcalc_distinct_site_patterns()\fR" 4
.IX Item "calc_distinct_site_patterns()"
Identifies the distinct distributions of states for all characters and
counts their occurrences. Returns an array-of-arrays, where the first cell
of each inner array holds the occurrence count, the second cell holds the
pattern, i.e. an array of states. For example, for a matrix like this:
.Sp
.Vb 7
\& taxon1 GTGTGTGTGTGTGTGTGTGTGTG
\& taxon2 AGAGAGAGAGAGAGAGAGAGAGA
\& taxon3 TCTCTCTCTCTCTCTCTCTCTCT
\& taxon4 TCTCTCTCTCTCTCTCTCTCTCT
\& taxon5 AAAAAAAAAAAAAAAAAAAAAAA
\& taxon6 CGCGCGCGCGCGCGCGCGCGCGC
\& taxon7 AAAAAAAAAAAAAAAAAAAAAAA
.Ve
.Sp
The following data structure will be returned:
.Sp
.Vb 4
\& [
\&        [ 12, [ \*(AqG\*(Aq, \*(AqA\*(Aq, \*(AqT\*(Aq, \*(AqT\*(Aq, \*(AqA\*(Aq, \*(AqC\*(Aq, \*(AqA\*(Aq ] ],
\&        [ 11, [ \*(AqT\*(Aq, \*(AqG\*(Aq, \*(AqC\*(Aq, \*(AqC\*(Aq, \*(AqA\*(Aq, \*(AqG\*(Aq, \*(AqA\*(Aq ] ]
\& ]
.Ve
.Sp
The patterns are sorted from most to least frequently occurring, the states
for each pattern are in the order of the rows in the matrix. (In other words,
the original matrix can more or less be reconstructed by inverting the patterns,
and multiplying them by their occurrence, although the order of the columns
will be lost.)
.Sp
.Vb 7
\& Type    : Calculation
\& Title   : calc_distinct_site_patterns
\& Usage   : my $patterns = $object\->calc_distinct_site_patterns;
\& Function: Calculates distinct site patterns.
\& Returns : A multidimensional array, see above.
\& Args    : NONE
\& Comments:
.Ve
.IP "\fIcalc_gc_content()\fR" 4
.IX Item "calc_gc_content()"
Calculates the G+C content as a fraction on the total
.Sp
.Vb 10
\& Type    : Calculation
\& Title   : calc_gc_content
\& Usage   : my $fraction = $obj\->calc_gc_content;
\& Function: Calculates G+C content
\& Returns : A number between 0 and 1 (inclusive)
\& Args    : Optional:
\&           # if true, counts missing (usually the \*(Aq?\*(Aq symbol) as a state
\&           # in the final tallies. Otherwise, missing states are ignored
\&           \-missing => 1
\&           # if true, counts gaps (usually the \*(Aq\-\*(Aq symbol) as a state
\&           # in the final tallies. Otherwise, gap states are ignored
\&           \-gap => 1
\& Comments: Throws \*(AqBadArgs\*(Aq exception if matrix holds anything other than DNA
\&           or RNA. The calculation also takes the IUPAC symbol S (which is C|G)
\&           into account, but no other symbols (such as V, for A|C|G);
.Ve
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "\fIkeep_chars()\fR" 4
.IX Item "keep_chars()"
Creates a cloned matrix that only keeps the characters at 
the supplied (zero-based) indices.
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : keep_chars
\& Usage   : my $clone = $object\->keep_chars([6,3,4,1]);
\& Function: Creates spliced clone.
\& Returns : A spliced clone of the invocant.
\& Args    : Required, an array ref of integers
\& Comments: The columns are retained in the order in 
\&           which they were supplied.
.Ve
.IP "\fIprune_chars()\fR" 4
.IX Item "prune_chars()"
Creates a cloned matrix that omits the characters at 
the supplied (zero-based) indices.
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : prune_chars
\& Usage   : my $clone = $object\->prune_chars([6,3,4,1]);
\& Function: Creates spliced clone.
\& Returns : A spliced clone of the invocant.
\& Args    : Required, an array ref of integers
\& Comments: The columns are retained in the order in 
\&           which they were supplied.
.Ve
.IP "\fIprune_invariant()\fR" 4
.IX Item "prune_invariant()"
Creates a cloned matrix that omits the characters for which all taxa
have the same state (or missing);
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : prune_invariant
\& Usage   : my $clone = $object\->prune_invariant;
\& Function: Creates spliced clone.
\& Returns : A spliced clone of the invocant.
\& Args    : None
\& Comments: The columns are retained in the order in 
\&           which they were supplied.
.Ve
.IP "\fIprune_uninformative()\fR" 4
.IX Item "prune_uninformative()"
Creates a cloned matrix that omits all uninformative characters. Uninformative
are considered characters where all non-missing values are either invariant
or autapomorphies.
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : prune_uninformative
\& Usage   : my $clone = $object\->prune_uninformative;
\& Function: Creates spliced clone.
\& Returns : A spliced clone of the invocant.
\& Args    : None
\& Comments: The columns are retained in the order in 
\&           which they were supplied.
.Ve
.IP "\fIprune_missing_and_gaps()\fR" 4
.IX Item "prune_missing_and_gaps()"
Creates a cloned matrix that omits all characters for which the invocant only
has missing and/or gap states.
.Sp
.Vb 8
\& Type    : Utility method
\& Title   : prune_missing_and_gaps
\& Usage   : my $clone = $object\->prune_missing_and_gaps;
\& Function: Creates spliced clone.
\& Returns : A spliced clone of the invocant.
\& Args    : None
\& Comments: The columns are retained in the order in 
\&           which they were supplied.
.Ve
.IP "\fIbootstrap()\fR" 4
.IX Item "bootstrap()"
Creates bootstrapped clone.
.Sp
.Vb 10
\& Type    : Utility method
\& Title   : bootstrap
\& Usage   : my $bootstrap = $object\->bootstrap;
\& Function: Creates bootstrapped clone.
\& Returns : A bootstrapped clone of the invocant.
\& Args    : Optional, a subroutine reference that returns a random
\&           integer between 0 (inclusive) and the argument provided
\&           to it (exclusive). The default implementation is to use
\&           sub { int( rand( shift ) ) }, a user might override this
\&           by providing an implementation with a better random number
\&           generator.
\& Comments: The bootstrapping algorithm uses perl\*(Aqs random number
\&           generator to create a new series of indices (without
\&           replacement) of the same length as the original matrix.
\&           These indices are first sorted, then applied to the 
\&           cloned sequences. Annotations (if present) stay connected
\&           to the resampled cells.
.Ve
.IP "\fIjackknife()\fR" 4
.IX Item "jackknife()"
Creates jackknifed clone.
.Sp
.Vb 10
\& Type    : Utility method
\& Title   : jackknife
\& Usage   : my $bootstrap = $object\->jackknife(0.5);
\& Function: Creates jackknifed clone.
\& Returns : A jackknifed clone of the invocant.
\& Args    : * Required, a number between 0 and 1, representing the
\&             fraction of characters to jackknife. 
\&           * Optional, a subroutine reference that returns a random
\&             integer between 0 (inclusive) and the argument provided
\&             to it (exclusive). The default implementation is to use
\&             sub { int( rand( shift ) ) }, a user might override this
\&             by providing an implementation with a better random number
\&             generator.
\& Comments: The jackknife algorithm uses perl\*(Aqs random number
\&           generator to create a new series of indices of cells to keep.
\&           These indices are first sorted, then applied to the 
\&           cloned sequences. Annotations (if present) stay connected
\&           to the resampled cells.
.Ve
.IP "\fIinsert()\fR" 4
.IX Item "insert()"
Insert argument in invocant.
.Sp
.Vb 8
\& Type    : Listable method
\& Title   : insert
\& Usage   : $matrix\->insert($datum);
\& Function: Inserts $datum in $matrix.
\& Returns : Modified object
\& Args    : A datum object
\& Comments: This method re\-implements the method by the same
\&           name in Bio::Phylo::Listable
.Ve
.IP "\fIcompress_lookup()\fR" 4
.IX Item "compress_lookup()"
Removes unused states from lookup table
.Sp
.Vb 6
\& Type    : Method
\& Title   : validate
\& Usage   : $obj\->compress_lookup
\& Function: Removes unused states from lookup table
\& Returns : $self
\& Args    : None
.Ve
.IP "\fIcheck_taxa()\fR" 4
.IX Item "check_taxa()"
Validates taxa associations.
.Sp
.Vb 8
\& Type    : Method
\& Title   : check_taxa
\& Usage   : $obj\->check_taxa
\& Function: Validates relation between matrix and taxa block 
\& Returns : Modified object
\& Args    : None
\& Comments: This method implements the interface method by the same
\&           name in Bio::Phylo::Taxa::TaxaLinker
.Ve
.IP "\fImake_taxa()\fR" 4
.IX Item "make_taxa()"
Creates a taxa block from the objects contents if none exists yet.
.Sp
.Vb 6
\& Type    : Method
\& Title   : make_taxa
\& Usage   : my $taxa = $obj\->make_taxa
\& Function: Creates a taxa block from the objects contents if none exists yet.
\& Returns : $taxa
\& Args    : NONE
.Ve
.SS "\s-1SERIALIZERS\s0"
.IX Subsection "SERIALIZERS"
.IP "\fIto_xml()\fR" 4
.IX Item "to_xml()"
Serializes matrix to nexml format.
.Sp
.Vb 7
\& Type    : Format convertor
\& Title   : to_xml
\& Usage   : my $data_block = $matrix\->to_xml;
\& Function: Converts matrix object into a nexml element structure.
\& Returns : Nexml block (SCALAR).
\& Args    : Optional:
\&                   \-compact => 1 (for compact representation of matrix)
.Ve
.IP "\fIto_nexus()\fR" 4
.IX Item "to_nexus()"
Serializes matrix to nexus format.
.Sp
.Vb 6
\& Type    : Format convertor
\& Title   : to_nexus
\& Usage   : my $data_block = $matrix\->to_nexus;
\& Function: Converts matrix object into a nexus data block.
\& Returns : Nexus data block (SCALAR).
\& Args    : The following options are available:
\& 
\&            # if set, writes TITLE & LINK tokens
\&            \*(Aq\-links\*(Aq => 1
\&            
\&            # if set, writes block as a "data" block (deprecated, but used by mrbayes),
\&            # otherwise writes "characters" block (default)
\&            \-data_block => 1
\&            
\&            # if set, writes "RESPECTCASE" token
\&            \-respectcase => 1
\&            
\&            # if set, writes "GAPMODE=(NEWSTATE or MISSING)" token
\&            \-gapmode => 1
\&            
\&            # if set, writes "MSTAXA=(POLYMORPH or UNCERTAIN)" token
\&            \-polymorphism => 1
\&            
\&            # if set, writes character labels
\&            \-charlabels => 1
\&            
\&            # if set, writes state labels
\&            \-statelabels => 1
\&            
\&            # if set, writes mesquite\-style charstatelabels
\&            \-charstatelabels => 1
\&            
\&            # by default, names for sequences are derived from $datum\->get_name, if 
\&            # \*(Aqinternal\*(Aq is specified, uses $datum\->get_internal_name, if \*(Aqtaxon\*(Aq
\&            # uses $datum\->get_taxon\->get_name, if \*(Aqtaxon_internal\*(Aq uses 
\&            # $datum\->get_taxon\->get_internal_name, if $key, uses $datum\->get_generic($key)
\&            \-seqnames => one of (internal|taxon|taxon_internal|$key)
.Ve
.IP "\fIto_dom()\fR" 4
.IX Item "to_dom()"
Analog to to_xml.
.Sp
.Vb 9
\& Type    : Serializer
\& Title   : to_dom
\& Usage   : $matrix\->to_dom
\& Function: Generates a DOM subtree from the invocant
\&           and its contained objects
\& Returns : an Element object
\& Args    : Optional:
\&           \-compact => 1 : renders characters as sequences,
\&                           not individual cells
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There is a mailing list at <https://groups.google.com/forum/#!forum/bio\-phylo> 
for any user or developer questions and discussions.
.IP "Bio::Phylo::Taxa::TaxaLinker" 4
.IX Item "Bio::Phylo::Taxa::TaxaLinker"
This object inherits from Bio::Phylo::Taxa::TaxaLinker, so the
methods defined therein are also applicable to Bio::Phylo::Matrices::Matrix
objects.
.IP "Bio::Phylo::Matrices::TypeSafeData" 4
.IX Item "Bio::Phylo::Matrices::TypeSafeData"
This object inherits from Bio::Phylo::Matrices::TypeSafeData, so the
methods defined therein are also applicable to Bio::Phylo::Matrices::Matrix
objects.
.IP "Bio::Phylo::Manual" 4
.IX Item "Bio::Phylo::Manual"
Also see the manual: Bio::Phylo::Manual and <http://rutgervos.blogspot.com>.
.SH "CITATION"
.IX Header "CITATION"
If you use Bio::Phylo in published research, please cite it:
.PP
\&\fBRutger A Vos\fR, \fBJason Caravas\fR, \fBKlaas Hartmann\fR, \fBMark A Jensen\fR
and \fBChase Miller\fR, 2011. Bio::Phylo \- phyloinformatic analysis using Perl.
\&\fI\s-1BMC\s0 Bioinformatics\fR \fB12\fR:63.
<http://dx.doi.org/10.1186/1471\-2105\-12\-63>
