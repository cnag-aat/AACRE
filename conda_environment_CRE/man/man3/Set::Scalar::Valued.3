.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Set::Scalar::Valued 3"
.TH Set::Scalar::Valued 3 "2014-03-24" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Set::Scalar::Valued \- valued sets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use Set::Scalar::Valued;
\&    $s = Set::Scalar::Valued\->new;
\&    $s\->insert(a => 12, \*(Aqb c\*(Aq => $d);
\&    $s\->delete(\*(Aqb c\*(Aq => $d);
\&    $t = Set::Scalar\->new(x => $y, y => $z);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Valued sets are an extension of the traditional set concept.  In
addition to a member just existing in the set, the member also has a
distinct value.  You can think of this a combination of a traditional
set and a Perl hash.
.PP
The used methods are as for the traditional of Set::Scalar, with
the difference that when creating (\fInew()\fR) or modifying (\fIinsert()\fR,
\&\fIdelete()\fR, \fIinvert()\fR), you must supply twice the number of arguments:
the member-value pairs, instead of just the members.  Note, though,
that in the current implementation of \fIdelete()\fR the value half is
unused, the deletion is by the member.  In future implementation
this behavior may change so that also the value matters.
.PP
There are a couple of additional methods:
.PP
.Vb 1
\&    %ve = $s\->valued_members;
.Ve
.PP
which returns the member-value pairs, and
.PP
.Vb 1
\&    @v  = $s\->values;
.Ve
.PP
which returns just the values (in the same order as the \fImembers()\fR
method would return the members), and
.PP
.Vb 1
\&    $v  = $s\->value($member);
.Ve
.PP
which returns the value of the member.
.PP
The display format of a valued set is the member-value pairs separated
by \*(L" => \*(R", the pairs separated by \*(L", \*(R" and enclosed in curly brackets {}.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi <jhi@iki.fi>
