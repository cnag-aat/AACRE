.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Run::Analysis 3"
.TH Bio::Tools::Run::Analysis 3 "2019-10-28" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::Run::Analysis \- Module representing any (remote or local)
analysis tool
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  # run analysis \*(Aqseqret\*(Aq using a default location and a default
\&  # access method (which means using a Web Service at EBI)
\&  use Bio::Tools::Run::Analysis;
\&  print new Bio::Tools::Run::Analysis (\-name => \*(Aqedit::seqret\*(Aq)
\&       \->wait_for ({ sequence_direct_data => \*(Aqtatatacgtatacga\*(Aq,
\&                     osformat => \*(Aqembl\*(Aq
\&                     })
\&       \->result (\*(Aqoutseq\*(Aq);
\&
\&  # run a longer job without waiting for its completion
\&  use Bio::Tools::Run::Analysis;
\&  my $job = Bio::Tools::Run::Analysis\->new(\-name => \*(Aqedit::seqret\*(Aq)
\&                 \->run ({ sequence_direct_data => \*(Aqtatatacgtatacga\*(Aq,
\&                          osformat => \*(Aqembl\*(Aq
\&                          });
\&  # ...and after a while
\&  $job\->result (\*(Aqoutseq\*(Aq);
\&
\&  # get all results in the same invocation (as a hash reference
\&  # with result names as keys) \- let the module decide which
\&  # results are binary (images in this examples) and save those
\&  # in file (or files); it also shows how to tell that the module
\&  # should read input data from a local file first
\&  use Bio::Tools::Run::Analysis;
\&  my $results =
\&    Bio::Tools::Run::Analysis\->new(\-name => \*(Aqalignment_multiple::prettyplot\*(Aq)
\&       \->wait_for ( { msf_direct_data => \*(Aq@/home/testdata/my.seq\*(Aq } )
\&       \->results (\*(Aq?\*(Aq);
\&  use Data::Dumper;
\&  print Dumper ($results);
\&
\&  # get names, types of all inputs and results,
\&  # get short and detailed (in XML) service description
\&  use Bio::Tools::Run::Analysis;
\&  my $service = Bio::Tools::Run::Analysis\->new(\-name => \*(Aqedit::seqret\*(Aq);
\&  my $hash1 = $service\->input_spec;
\&  my $hash2 = $service\->result_spec;
\&  my $hash3 = $service\->analysis_spec;
\&  my $xml = $service\->describe;
\&
\&  # get current job status
\&  use Bio::Tools::Run::Analysis;
\&  print new Bio::Tools::Run::Analysis (\-name => \*(Aqedit::seqret\*(Aq)
\&    \->run ( { #...input data...
\&            } )
\&    \->status;
\&
\&  # run a job and print its job ID, keep the job un\-destroyed
\&  use Bio::Tools::Run::Analysis;
\&  my $job =
\&    Bio::Tools::Run::Analysis\->new(\-name => \*(Aqedit::seqret\*(Aq,
\&                                   \-destroy_on_exit => 0)
\&    \->run ( { sequence_direct_data => \*(Aq@/home/testdata/mzef.seq\*(Aq } );
\&  print $job\->id . "\en";
\&  # ...it prints (for example):
\&  #    edit::seqret/c8ef56:ef535489ac:\-7ff4
\&
\&  # ...in another time, on another planet, you may say
\&  use Bio::Tools::Run::Analysis;
\&  my $job =
\&    Bio::Tools::Run::Analysis::Job\->new(\-name => \*(Aqedit::seqret\*(Aq,
\&                                        \-id => \*(Aqedit::seqret/c8ef56:ef535489ac:\-7ff4\*(Aq);
\&  print join ("\en",
\&            $job\->status,
\&            \*(AqFinished: \*(Aq . $job\->ended (1),   # (1) means \*(Aqformatted\*(Aq
\&            \*(AqElapsed time: \*(Aq . $job\->elapsed,
\&            $job\->last_event,
\&            $job\->result (\*(Aqoutseq\*(Aq)
\&            );
\&
\&  # ...or you may achieve the same keeping module
\&  # Bio::Tools::Run::Analysis::Job invisible
\&  use Bio::Tools::Run::Analysis;
\&  my $job =
\&    Bio::Tools::Run::Analysis\->new(\-name => \*(Aqedit::seqret\*(Aq)
\&        \->create_job (\*(Aqedit::seqret/c8ef56:ef535489ac:\-7ff4\*(Aq);
\&  print join ("\en",
\&            $job\->status,
\&            # ...
\&            );
\&
\&  # ...and later you may free this job resources
\&  $job\->remove;
\&
\&  #
\&  # \-\-\- See DESCRIPTION for using generator \*(Aqapplmaker.pl\*(Aq:
\&  #
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The module represents an access to the local and/or remote analysis
tools in a unified way that allows adding new access methods
(protocols) seamlessly.
.PP
At the moment of writing, there is available a \fI\s-1SOAP\s0\fR access to
almost all \s-1EMBOSS\s0 applications, running at the
European Bioinformatics Institute.
.PP
The documentation of all \f(CW\*(C`public\*(C'\fR methods are to be found
in \f(CW\*(C`Bio::AnalysisI\*(C'\fR. A tutorial (and examples how to call almost all
public methods) is in the script \f(CW\*(C`panalysis.PLS\*(C'\fR (go to the \f(CW\*(C`scripts\*(C'\fR
directory and type \f(CW\*(C`perldoc panalysis.PLS\*(C'\fR).
.PP
The module \f(CW\*(C`Bio::Tools::Run::Analysis\*(C'\fR uses general approach allowing to set
arbitrary input data and to retrieve results by naming them. However,
sometimes is more convenient to use a specific module, representing
one analysis tool, that already knows about available input and result
names. Such analyses-specific Perl modules can be generated by
\&\f(CW\*(C`papplmaker.PLS\*(C'\fR generator. Its features and usage are documented in
the generator (go to the \f(CW\*(C`scripts\*(C'\fR directory and type \f(CW\*(C`perldoc
papplmaker.PLS\*(C'\fR).
.PP
.Vb 2
\&  # this will generate module Seqret.pm
\&  perl papplmaker.PLS \-n edit.seqret \-m Seqret
\&
\&  # ...which can be used with data\-specific methods
\&  use Seqret;
\&  my $outseq = new Seqret
\&    \->sequence_direct_data (\*(Aq@/home/testdata/my.seq\*(Aq)
\&    \->osformat (\*(Aqembl\*(Aq)
\&    \->wait_for
\&    \->outseq
\&    ;
\&  print $outseq;
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Senger (martin.senger@gmail.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003, Martin Senger and EMBL-EBI.
All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
http://www.ebi.ac.uk/soaplab/Perl_Client.html
.SH "APPENDIX"
.IX Header "APPENDIX"
Here is the rest of the object methods.  Internal methods are preceded
with an underscore _.
.SS "new"
.IX Subsection "new"
.Vb 10
\& Usage   : my $tool =
\&             Bio::Tools::Run::Analysis\->new(\-access => \*(Aqsoap\*(Aq,
\&                                            \-name => \*(Aqedit.seqret\*(Aq,
\&                                            ...
\&                                            );
\& Returns : a new Bio::Tools::Run::Analysis object representing the given tool
\& Args    : There may be additional arguments which are specific
\&           to the access method (see methods \*(Aqnew\*(Aq or \*(Aq_initialize\*(Aq
\&           of the access\-specific implementations (such as module
\&           Bio::Tools::Run::Analysis::soap for a SOAP\-based access).
\&
\&           The recognised and used arguments are:
\&             \-access
\&             \-location
\&             \-name
\&             \-httpproxy
\&             \-timeout
.Ve
.PP
It builds, populates and returns a new \f(CW\*(C`Bio::Tools::Run::Analysis\*(C'\fR object. This
is how it is seen from the outside. But in fact, it builds, populates
and returns a more specific lower-level object, for example
\&\f(CW\*(C`Bio::Tools::Run::Analysis::soap\*(C'\fR object \- which one it depends on the \f(CW\*(C`\-access\*(C'\fR
parameter.
.IP "\-access" 4
.IX Item "-access"
It indicates what lower-level module to load.  Default is 'soap'.
Other (but future) possibilities may be:
.Sp
.Vb 2
\&   \-access => \*(Aqnovella\*(Aq
\&   \-access => \*(Aqlocal\*(Aq
.Ve
.IP "\-location" 4
.IX Item "-location"
A location of the service. The contents is access-specific (see
details in the lower-level implementation modules).
.Sp
Default is \f(CW\*(C`http://www.ebi.ac.uk/soaplab/services\*(C'\fR ( services running
at European Bioinformatics Institute on top of most of \s-1EMBOSS\s0
analyses, and on few others).
.IP "\-name" 4
.IX Item "-name"
A name of an analysis tool, or a name of its higher-level abstraction,
possibly including a category where the analysis belong to. There is
no default value (which usually means that this parameter is mandatory
unless your \fI\-location\fR parameter includes also the name (but it is
then access-dependent).
.IP "\-destroy_on_exit => '0'" 4
.IX Item "-destroy_on_exit => '0'"
Default value is '1' which means that all Bio::Tools::Run::Analysis::Job
objects \- when being finalised \- will send a request
to the remote site to forget the results of these jobs.
.Sp
If you change it to '0' make sure that you know the job identification
\&\- otherwise you will not be able to re-established connection with it
(later, when you use your program again). This can be done by calling
method \f(CW\*(C`id\*(C'\fR on the job object (such object is returned by any of
these methods: \f(CW\*(C`create_job\*(C'\fR, \f(CW\*(C`run\*(C'\fR, \f(CW\*(C`wait_for\*(C'\fR).
.IP "\-httpproxy" 4
.IX Item "-httpproxy"
In addition to the \fIlocation\fR parameter, you may need to specify also
a location/URL of an \s-1HTTP\s0 proxy server (if your site requires
one). The expected format is \f(CW\*(C`http://server:port\*(C'\fR.  There is no
default value. It is also an access-specific parameter which may not
be used by all access methods.
.IP "\-timeout" 4
.IX Item "-timeout"
For long(er) running jobs the \s-1HTTP\s0 connection may be time-outed. In
order to avoid it (or, vice-versa, to call timeout sooner) you may
specify \f(CW\*(C`timeout\*(C'\fR with the number of seconds the connection will be
kept alive. Zero means to keep it alive forever. The default value is
two minutes.
.SS "\s-1VERSION\s0 and Revision"
.IX Subsection "VERSION and Revision"
.Vb 2
\& Usage   : print $Bio::Tools::Run::Analysis::VERSION;
\&           print $Bio::Tools::Run::Analysis::Revision;
.Ve
.SH "Module Bio::Tools::Run::Analysis::Job"
.IX Header "Module Bio::Tools::Run::Analysis::Job"
It represents a job, a single execution of an analysis tool. Usually
you do not instantiate these objects \- they are returned by methods
\&\f(CW\*(C`create_job\*(C'\fR, \f(CW\*(C`run\*(C'\fR, and \f(CW\*(C`wait_for\*(C'\fR of \f(CW\*(C`Bio::Tools::Run::Analysis\*(C'\fR object.
.PP
However, if you wish to re-create a job you need to know its \s-1ID\s0
(method \f(CW\*(C`id\*(C'\fR gives it to you). The \s-1ID\s0 can be passed directly to the
\&\f(CW\*(C`new\*(C'\fR method, or again you may use \f(CW\*(C`create_job\*(C'\fR of a
\&\f(CW\*(C`Bio::Tools::Run::Analysis\*(C'\fR object with the \s-1ID\s0 as parameter. See \s-1SYNOPSIS\s0 above
for an example.
.PP
Remember that all public methods of this module are described in
details in interface module \f(CW\*(C`Bio::AnalysisI\*(C'\fR and in the tutorial in
the \f(CW\*(C`analysis.pl\*(C'\fR script.
.SS "new"
.IX Subsection "new"
.Vb 10
\& Usage   : my $job = Bio::Tools::Run::Analysis::Job\->new
\&                       (\-access => \*(Aqsoap\*(Aq,
\&                        \-name => \*(Aqedit.seqret\*(Aq,
\&                        \-id => \*(Aqxxxyyy111222333\*(Aq
\&                        );
\& Returns : a re\-created object representing a job
\& Args    : The same arguments as for Bio::Tools::Run::Analysis object:
\&             \-access
\&             \-location
\&             \-name
\&             \-httpproxy
\&             \-timeout
\&             (and perhaps others)
\&           Additionally and specifically for this object:
\&             \-id
\&             \-analysis
.Ve
.IP "\-id" 4
.IX Item "-id"
A job \s-1ID\s0 created some previous time and now used to re-create the same
job (in order to re-gain access to this job results, for example).
.IP "\-analysis" 4
.IX Item "-analysis"
A \f(CW\*(C`Bio::Tools::Run::Analysis\*(C'\fR object whose properties (such as \f(CW\*(C`\-access\*(C'\fR and
\&\f(CW\*(C`\-location\*(C'\fR are used to re-create this job object.
.SH "Module Bio::Tools::Run::Analysis::Utils"
.IX Header "Module Bio::Tools::Run::Analysis::Utils"
It contains several general utilities. These are \f(CW\*(C`functions\*(C'\fR, not
methods. Therefore call them like, for example:
.PP
.Vb 1
\&    &Bio::Tools::Run::Analysis::Utils::format_time (...);
.Ve
.SS "format_time"
.IX Subsection "format_time"
.Vb 3
\& Usage   : Bio::Tools::Run::Analysis::Utils::format_time ($time);
\& Returns : Slightly formatted $time
\& Args    : $time is number of seconds from the beginning of Epoch
.Ve
.PP
It returns what \f(CW\*(C`localtime\*(C'\fR returns which means that return value is
different in the array and scalar context (see localtime). If \f(CW$time\fR
is ``\-1'' it returns 'n/a' (in the scalar context) or an empty array
(in the array context). If \f(CW$time\fR is too small to represent the
distance from the beginning of the Epoch, it returns it unchanged (the
same in any contex) \- this is reasonable for \f(CW$time\fR representing an
elapsed time.
.PP
The function is used to format times coming back from various job time
methods.
.SS "_load_access_module"
.IX Subsection "_load_access_module"
.Vb 4
\& Usage   : $class\->_load_access_module ($access)
\& Returns : 1 on success, undef on failure
\& Args    : \*(Aqaccess\*(Aq should contain the last part of the
\&           name of a module who does the real implementation
.Ve
.PP
It does (in the run-time) a similar thing as
.PP
.Vb 1
\&   require Bio::Tools::Run::Analysis::$access
.Ve
.PP
It prints an error on \s-1STDERR\s0 if it fails to find and load the module
(for example, because of the compilation errors in the module).
.SS "_guess_access"
.IX Subsection "_guess_access"
.Vb 5
\& Usage   : Bio::Tools::Run::Analysis::Utils::guess_access ($rh_params)
\& Returns : string with a guessed access protocol (e.g. \*(Aqsoap\*(Aq),
\&           or undef if the guessing failed
\& Args    : \*(Aqrh_params\*(Aq is a hash reference containing parameters given
\&           to the \*(Aqnew\*(Aq method.
.Ve
.PP
It makes an expert guess what kind of access/transport protocol should
be used to access the underlying analysis. The guess is based on the
parameters in \fIrh_params\fR. Rememeber that this method is called only
if there was no \fI\-access\fR parameter which could tell directly what
access method to use.
