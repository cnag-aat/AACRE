.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "FFI::CheckLib 3"
.TH FFI::CheckLib 3 "2020-05-11" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
FFI::CheckLib \- Check that a library is available for FFI
.SH "VERSION"
.IX Header "VERSION"
version 0.27
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use FFI::CheckLib;
\& 
\& check_lib_or_exit( lib => \*(Aqjpeg\*(Aq, symbol => \*(Aqjinit_memory_mgr\*(Aq );
\& check_lib_or_exit( lib => [ \*(Aqiconv\*(Aq, \*(Aqjpeg\*(Aq ] );
\& 
\& # or prompt for path to library and then:
\& print "where to find jpeg library: ";
\& my $path = <STDIN>;
\& check_lib_or_exit( lib => \*(Aqjpeg\*(Aq, libpath => $path );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module checks whether a particular dynamic library is available for
\&\s-1FFI\s0 to use. It is modeled heavily on Devel::CheckLib, but will find
dynamic libraries even when development packages are not installed.  It
also provides a find_lib function that will
return the full path to the found dynamic library, which can be feed
directly into FFI::Platypus or another \s-1FFI\s0 system.
.PP
Although intended mainly for \s-1FFI\s0 modules via FFI::Platypus and
similar, this module does not actually use any \s-1FFI\s0 to do its detection
and probing.  This module does not have any non-core runtime dependencies.
The test suite does depend on Test2::Suite.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
All of these take the same named parameters and are exported by default.
.SS "find_lib"
.IX Subsection "find_lib"
.Vb 1
\& my(@libs) = find_lib(%args);
.Ve
.PP
This will return a list of dynamic libraries, or empty list if none were
found.
.PP
[version 0.05]
.PP
If called in scalar context it will return the first library found.
.PP
Arguments are key value pairs with these keys:
.IP "lib" 4
.IX Item "lib"
Must be either a string with the name of a single library or a reference
to an array of strings of library names.  Depending on your platform,
\&\f(CW\*(C`CheckLib\*(C'\fR will prepend \f(CW\*(C`lib\*(C'\fR or append \f(CW\*(C`.dll\*(C'\fR or \f(CW\*(C`.so\*(C'\fR when
searching.
.Sp
[version 0.11]
.Sp
As a special case, if \f(CW\*(C`*\*(C'\fR is specified then any libs found will match.
.IP "libpath" 4
.IX Item "libpath"
A string or array of additional paths to search for libraries.
.IP "systempath" 4
.IX Item "systempath"
[version 0.11]
.Sp
A string or array of system paths to search for instead of letting
FFI::CheckLib determine the system path.  You can set this to \f(CW\*(C`[]\*(C'\fR
in order to not search \fIany\fR system paths.
.IP "symbol" 4
.IX Item "symbol"
A string or a list of symbol names that must be found.
.IP "verify" 4
.IX Item "verify"
A code reference used to verify a library really is the one that you
want.  It should take two arguments, which is the name of the library
and the full path to the library pathname.  It should return true if it
is acceptable, and false otherwise.  You can use this in conjunction
with FFI::Platypus to determine if it is going to meet your needs.
Example:
.Sp
.Vb 2
\& use FFI::CheckLib;
\& use FFI::Platypus;
\& 
\& my($lib) = find_lib(
\&   lib => \*(Aqfoo\*(Aq,
\&   verify => sub {
\&     my($name, $libpath) = @_;
\& 
\&     my $ffi = FFI::Platypus\->new;
\&     $ffi\->lib($libpath);
\& 
\&     my $f = $ffi\->function(\*(Aqfoo_version\*(Aq, [] => \*(Aqint\*(Aq);
\& 
\&     return $f\->call() >= 500; # we accept version 500 or better
\&   },
\& );
.Ve
.IP "recursive" 4
.IX Item "recursive"
[version 0.11]
.Sp
Recursively search for libraries in any non-system paths (those provided
via \f(CW\*(C`libpath\*(C'\fR above).
.IP "try_linker_script" 4
.IX Item "try_linker_script"
[version 0.24]
.Sp
Some vendors provide \f(CW\*(C`.so\*(C'\fR files that are linker scripts that point to
the real binary shared library.  These linker scripts can be used by gcc
or clang, but are not directly usable by FFI::Platypus and friends.
On select platforms, this options will use the linker command (\f(CW\*(C`ld\*(C'\fR)
to attempt to resolve the real \f(CW\*(C`.so\*(C'\fR for non-binary files.  Since there
is extra overhead this is off by default.
.Sp
An example is libyaml on Red Hat based Linux distributions.  On Debian
these are handled with symlinks and no trickery is required.
.IP "alien" 4
.IX Item "alien"
[version 0.25]
.Sp
If no libraries can be found, try the given aliens instead.  The Alien
classes specified must provide the Alien::Base interface for dynamic
libraries, which is to say they should provide a method called
\&\f(CW\*(C`dynamic_libs\*(C'\fR that returns a list of dynamic libraries.
.SS "assert_lib"
.IX Subsection "assert_lib"
.Vb 1
\& assert_lib(%args);
.Ve
.PP
This behaves exactly the same as find_lib,
except that instead of returning empty list of failure it throws an
exception.
.SS "check_lib_or_exit"
.IX Subsection "check_lib_or_exit"
.Vb 1
\& check_lib_or_exit(%args);
.Ve
.PP
This behaves exactly the same as assert_lib,
except that instead of dying, it warns (with exactly the same error
message) and exists.  This is intended for use in \f(CW\*(C`Makefile.PL\*(C'\fR or
\&\f(CW\*(C`Build.PL\*(C'\fR
.SS "find_lib_or_exit"
.IX Subsection "find_lib_or_exit"
[version 0.05]
.PP
.Vb 1
\& my(@libs) = find_lib_or_exit(%args);
.Ve
.PP
This behaves exactly the same as find_lib,
except that if the library is not found, it will call exit with an
appropriate diagnostic.
.SS "find_lib_or_die"
.IX Subsection "find_lib_or_die"
[version 0.06]
.PP
.Vb 1
\& my(@libs) = find_lib_or_die(%args);
.Ve
.PP
This behaves exactly the same as find_lib,
except that if the library is not found, it will die with an appropriate
diagnostic.
.SS "check_lib"
.IX Subsection "check_lib"
.Vb 1
\& my $bool = check_lib(%args);
.Ve
.PP
This behaves exactly the same as find_lib,
except that it returns true (1) on finding the appropriate libraries or
false (0) otherwise.
.SS "which"
.IX Subsection "which"
[version 0.17]
.PP
.Vb 1
\& my $path = where($name);
.Ve
.PP
Return the path to the first library that matches the given name.
.PP
Not exported by default.
.SS "where"
.IX Subsection "where"
[version 0.17]
.PP
.Vb 1
\& my @paths = where($name);
.Ve
.PP
Return the paths to all the libraries that match the given name.
.PP
Not exported by default.
.SS "has_symbols"
.IX Subsection "has_symbols"
[version 0.17]
.PP
.Vb 1
\& my $bool = has_symbols($path, @symbol_names);
.Ve
.PP
Returns true if \fIall\fR of the symbols can be found in the dynamic library located
at the given path.  Can be useful in conjunction with \f(CW\*(C`verify\*(C'\fR with \f(CW\*(C`find_lib\*(C'\fR
above.
.PP
Not exported by default.
.SS "system_path"
.IX Subsection "system_path"
[version 0.20]
.PP
.Vb 1
\& my $path = FFI::CheckLib::system_path;
.Ve
.PP
Returns the system path as a list reference.  On some systems, this is \f(CW\*(C`PATH\*(C'\fR
on others it might be \f(CW\*(C`LD_LIBRARY_PATH\*(C'\fR on still others it could be something
completely different.  So although you \fImay\fR add items to this list, you should
probably do some careful consideration before you do so.
.PP
This function is not exportable, even on request.
.SH "FAQ"
.IX Header "FAQ"
.ie n .IP "Why not just use ""dlopen""?" 4
.el .IP "Why not just use \f(CWdlopen\fR?" 4
.IX Item "Why not just use dlopen?"
Calling \f(CW\*(C`dlopen\*(C'\fR on a library name and then \f(CW\*(C`dlclose\*(C'\fR immediately can tell
you if you have the exact name of a library available on a system.  It does
have a number of drawbacks as well.
.RS 4
.IP "No absolute or relative path" 4
.IX Item "No absolute or relative path"
It only tells you that the library is \fIsomewhere\fR on the system, not having
the absolute or relative path makes it harder to generate useful diagnostics.
.IP "\s-1POSIX\s0 only" 4
.IX Item "POSIX only"
This doesn't work on non-POSIX systems like Microsoft Windows. If you are
using a \s-1POSIX\s0 emulation layer on Windows that provides \f(CW\*(C`dlopen\*(C'\fR, like
Cygwin, there are a number of gotchas there as well.  Having a layer written
in Perl handles this means that developers on Unix can develop \s-1FFI\s0 that will
more likely work on these platforms without special casing them.
.IP "inconsistent implementations" 4
.IX Item "inconsistent implementations"
Even on \s-1POSIX\s0 systems you have inconsistent implementations.  OpenBSD for
example don't usually include symlinks for \f(CW\*(C`.so\*(C'\fR files meaning you need
to know the exact \f(CW\*(C`.so\*(C'\fR version.
.IP "non-system directories" 4
.IX Item "non-system directories"
By default \f(CW\*(C`dlopen\*(C'\fR only works for libraries in the system paths.  Most
platforms have a way of configuring the search for different non-system
paths, but none of them are portable, and are usually discouraged anyway.
Alien and friends need to do searches for dynamic libraries in
non-system directories for \f(CW\*(C`share\*(C'\fR installs.
.RE
.RS 4
.RE
.IP "My 64\-bit Perl is misconfigured and has 32\-bit libraries in its search path.  Is that a bug in FFI::CheckLib?" 4
.IX Item "My 64-bit Perl is misconfigured and has 32-bit libraries in its search path. Is that a bug in FFI::CheckLib?"
Nope.
.IP "The way FFI::CheckLib is implemented it won't work on \s-1AIX,\s0 HP-UX, OpenVMS or Plan 9." 4
.IX Item "The way FFI::CheckLib is implemented it won't work on AIX, HP-UX, OpenVMS or Plan 9."
I know for a fact that it doesn't work on \s-1AIX\s0 \fIas currently implemented\fR
because I used to develop on \s-1AIX\s0 in the early 2000s, and I am aware of some
of the technical challenges.  There are probably other systems that it won't
work on.  I would love to add support for these platforms.  Realistically
these platforms have a tiny market share, and absent patches from users or
the companies that own these operating systems (patches welcome), or hardware
/ \s-1CPU\s0 time donations, these platforms are unsupportable anyway.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "FFI::Platypus" 4
.IX Item "FFI::Platypus"
Call library functions dynamically without a compiler.
.IP "Dist::Zilla::Plugin::FFI::CheckLib" 4
.IX Item "Dist::Zilla::Plugin::FFI::CheckLib"
Dist::Zilla plugin for this module.
.SH "AUTHOR"
.IX Header "AUTHOR"
Author: Graham Ollis <plicease@cpan.org>
.PP
Contributors:
.PP
Bakkiaraj Murugesan (bakkiaraj)
.PP
Dan Book (grinnz, \s-1DBOOK\s0)
.PP
Ilya Pavlov (Ilya, \s-1ILUX\s0)
.PP
Shawn Laffan (\s-1SLAFFAN\s0)
.PP
Petr Pisar (ppisar)
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2014\-2018 by Graham Ollis.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
