.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Graph::BitMatrix 3"
.TH Graph::BitMatrix 3 "2014-03-09" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Graph::BitMatrix \- create and manipulate a V x V bit matrix of graph G
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\&    use Graph::BitMatrix;
\&    use Graph::Directed;
\&    my $g  = Graph::Directed\->new;
\&    $g\->add_...(); # build $g
\&    my $m = Graph::BitMatrix\->new($g, %opt);
\&    $m\->get($u, $v)
\&    $m\->set($u, $v)
\&    $m\->unset($u, $v)
\&    $m\->get_row($u, $v1, $v2, ..., $vn)
\&    $m\->set_row($u, $v1, $v2, ..., $vn)
\&    $m\->unset_row($u, $v1, $v2, ..., $vn)
\&    $a\->vertices()
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class enables creating bit matrices that compactly describe
the connected of the graphs.
.SS "Class Methods"
.IX Subsection "Class Methods"
.IP "new($g)" 4
.IX Item "new($g)"
Create a bit matrix from a Graph \f(CW$g\fR.  The \f(CW%opt\fR, if present,
can have the following options:
.RS 4
.IP "\(bu" 8
connect_edges
.Sp
If true or if not present, set the bits in the bit matrix that
correspond to edges.  If false, do not set any bits.  In either
case the bit matrix of V x V bits is allocated.
.RE
.RS 4
.RE
.SS "Object Methods"
.IX Subsection "Object Methods"
.ie n .IP "get($u, $v)" 4
.el .IP "get($u, \f(CW$v\fR)" 4
.IX Item "get($u, $v)"
Return true if the bit matrix has a \*(L"one bit\*(R" between the vertices
\&\f(CW$u\fR and \f(CW$v\fR; in other words, if there is (at least one) a vertex going from
\&\f(CW$u\fR to \f(CW$v\fR.  If there is no vertex and therefore a \*(L"zero bit\*(R", return false.
.ie n .IP "set($u, $v)" 4
.el .IP "set($u, \f(CW$v\fR)" 4
.IX Item "set($u, $v)"
Set the bit between the vertices \f(CW$u\fR and \f(CW$v\fR; in other words, connect
the vertices \f(CW$u\fR and \f(CW$v\fR by an edge.  The change does not get mirrored
back to the original graph.  Returns nothing.
.ie n .IP "unset($u, $v)" 4
.el .IP "unset($u, \f(CW$v\fR)" 4
.IX Item "unset($u, $v)"
Unset the bit between the vertices \f(CW$u\fR and \f(CW$v\fR; in other words, disconnect
the vertices \f(CW$u\fR and \f(CW$v\fR by an edge.  The change does not get mirrored
back to the original graph.  Returns nothing.
.ie n .IP "get_row($u, $v1, $v2, ..., $vn)" 4
.el .IP "get_row($u, \f(CW$v1\fR, \f(CW$v2\fR, ..., \f(CW$vn\fR)" 4
.IX Item "get_row($u, $v1, $v2, ..., $vn)"
Test the row at vertex \f(CW\*(C`u\*(C'\fR for the vertices \f(CW\*(C`v1\*(C'\fR, \f(CW\*(C`v2\*(C'\fR, ..., \f(CW\*(C`vn\*(C'\fR
Returns a list of \fIn\fR truth values.
.ie n .IP "set_row($u, $v1, $v2, ..., $vn)" 4
.el .IP "set_row($u, \f(CW$v1\fR, \f(CW$v2\fR, ..., \f(CW$vn\fR)" 4
.IX Item "set_row($u, $v1, $v2, ..., $vn)"
Sets the row at vertex \f(CW\*(C`u\*(C'\fR for the vertices \f(CW\*(C`v1\*(C'\fR, \f(CW\*(C`v2\*(C'\fR, ..., \f(CW\*(C`vn\*(C'\fR,
in other words, connects the vertex \f(CW\*(C`u\*(C'\fR to the vertices \f(CW\*(C`vi\*(C'\fR.
The changes do not get mirrored back to the original graph.
Returns nothing.
.ie n .IP "unset_row($u, $v1, $v2, ..., $vn)" 4
.el .IP "unset_row($u, \f(CW$v1\fR, \f(CW$v2\fR, ..., \f(CW$vn\fR)" 4
.IX Item "unset_row($u, $v1, $v2, ..., $vn)"
Unsets the row at vertex \f(CW\*(C`u\*(C'\fR for the vertices \f(CW\*(C`v1\*(C'\fR, \f(CW\*(C`v2\*(C'\fR, ..., \f(CW\*(C`vn\*(C'\fR,
in other words, disconnects the vertex \f(CW\*(C`u\*(C'\fR from the vertices \f(CW\*(C`vi\*(C'\fR.
The changes do not get mirrored back to the original graph.
Returns nothing.
.IP "vertices" 4
.IX Item "vertices"
Return the list of vertices in the bit matrix.
.SH "ALGORITHM"
.IX Header "ALGORITHM"
The algorithm used to create the matrix is two nested loops, which is
O(V**2) in time, and the returned matrices are O(V**2) in space.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Jarkko Hietaniemi \fIjhi@iki.fi\fR
.SH "LICENSE"
.IX Header "LICENSE"
This module is licensed under the same terms as Perl itself.
