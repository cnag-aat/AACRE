.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "GraphViz 3"
.TH GraphViz 3 "2016-12-27" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GraphViz \- Interface to AT&T's GraphViz. Deprecated. See GraphViz2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use GraphViz;
\&
\&  my $g = GraphViz\->new();
\&
\&  $g\->add_node(\*(AqLondon\*(Aq);
\&  $g\->add_node(\*(AqParis\*(Aq, label => \*(AqCity of\enlurve\*(Aq);
\&  $g\->add_node(\*(AqNew York\*(Aq);
\&
\&  $g\->add_edge(\*(AqLondon\*(Aq => \*(AqParis\*(Aq);
\&  $g\->add_edge(\*(AqLondon\*(Aq => \*(AqNew York\*(Aq, label => \*(AqFar\*(Aq);
\&  $g\->add_edge(\*(AqParis\*(Aq => \*(AqLondon\*(Aq);
\&
\&  print $g\->as_png;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an interface to layout and image generation of directed
and undirected graphs in a variety of formats (PostScript, \s-1PNG,\s0 etc.) using the
\&\*(L"dot\*(R", \*(L"neato\*(R", \*(L"twopi\*(R", \*(L"circo\*(R" and \*(L"fdp\*(R"  programs from the Graphviz project
(http://www.graphviz.org/ or http://www.research.att.com/sw/tools/graphviz/).
.PP
GraphViz is deprecated in favour of GraphViz2.
.SH "Installation"
.IX Header "Installation"
Of course you need to install \s-1AT&T\s0's Graphviz before using this module.
See <http://www.graphviz.org/Download.php>.
.PP
You are strongly advised to download the stable version of Graphviz, because the
development snapshots (click on 'Source code'), are sometimes non-functional.
.PP
Install GraphViz as you would for any \f(CW\*(C`Perl\*(C'\fR module:
.PP
Run:
.PP
.Vb 1
\&        cpanm GraphViz
\&
\&        Note: cpanm ships in App::cpanminus. See also App::perlbrew.
.Ve
.PP
or run:
.PP
.Vb 1
\&        sudo cpan GraphViz
.Ve
.PP
or unpack the distro, and then either:
.PP
.Vb 4
\&        perl Build.PL
\&        ./Build
\&        ./Build test
\&        sudo ./Build install
.Ve
.PP
or:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make (or dmake or nmake)
\&        make test
\&        make install
.Ve
.SH "Overview"
.IX Header "Overview"
.SS "Modules in this distro"
.IX Subsection "Modules in this distro"
.IP "o GraphViz" 4
.IX Item "o GraphViz"
.PD 0
.IP "o GraphViz::No" 4
.IX Item "o GraphViz::No"
.IP "o GraphViz::Small" 4
.IX Item "o GraphViz::Small"
.IP "o GraphViz::Regex" 4
.IX Item "o GraphViz::Regex"
.IP "o GraphViz::XML" 4
.IX Item "o GraphViz::XML"
.IP "o GraphViz::Data::Grapher" 4
.IX Item "o GraphViz::Data::Grapher"
.IP "o GraphViz::Parse::RecDescent" 4
.IX Item "o GraphViz::Parse::RecDescent"
.IP "o GraphViz::Parse::Yacc" 4
.IX Item "o GraphViz::Parse::Yacc"
.IP "o GraphViz::Parse::Yapp" 4
.IX Item "o GraphViz::Parse::Yapp"
.PD
.SS "What is a graph?"
.IX Subsection "What is a graph?"
A (undirected) graph is a collection of nodes linked together with
edges.
.PP
A directed graph is the same as a graph, but the edges have a
direction.
.SS "What is GraphViz?"
.IX Subsection "What is GraphViz?"
This module is an interface to the GraphViz toolset
(http://www.graphviz.org/). The GraphViz tools provide automatic graph
layout and drawing. This module simplifies the creation of graphs and
hides some of the complexity of the GraphViz module.
.PP
Laying out graphs in an aesthetically-pleasing way is a hard problem \-
there may be multiple ways to lay out the same graph, each with their
own quirks. GraphViz luckily takes part of this hard problem and does
a pretty good job in a couple of seconds for most graphs.
.SS "Why should I use this module?"
.IX Subsection "Why should I use this module?"
Observation aids comprehension. That is a fancy way of expressing
that popular faux-Chinese proverb: \*(L"a picture is worth a thousand
words\*(R".
.PP
Text is not always the best way to represent anything and everything
to do with a computer programs. Pictures and images are easier to
assimilate than text. The ability to show a particular thing
graphically can aid a great deal in comprehending what that thing
really represents.
.PP
Diagrams are computationally efficient, because information can be
indexed by location; they group related information in the same
area. They also allow relations to be expressed between elements
without labeling the elements.
.PP
A friend of mine used this to his advantage when trying to remember
important dates in computer history. Instead of sitting down and
trying to remember everything, he printed over a hundred posters (each
with a date and event) and plastered these throughout his house. His
spatial memory is still so good that asked last week (more than a year
since the experiment) when Lisp was invented, he replied that it was
upstairs, around the corner from the toilet, so must have been around
1958.
.PP
Spreadsheets are also a wonderfully simple graphical representation of
computational models.
.SS "Applications"
.IX Subsection "Applications"
Bundled with this module are several modules to help graph data
structures (GraphViz::Data::Dumper), \s-1XML\s0 (GraphViz::XML), and
Parse::RecDescent, Parse::Yapp, and yacc grammars
(GraphViz::Parse::RecDescent, GraphViz::Parse::Yapp, and
GraphViz::Parse::Yacc).
.PP
Note that Marcel Grunauer has released some modules on \s-1CPAN\s0 to graph
various other structures. See GraphViz::DBI and GraphViz::ISA for
example.
.PP
brian d foy has written an article about Devel::GraphVizProf for
Dr. Dobb's Journal:
http://www.ddj.com/columns/perl/2001/0104pl002/0104pl002.htm
.SS "Award winning!"
.IX Subsection "Award winning!"
I presented a paper and talk on \*(L"Graphing Perl\*(R" using GraphViz at the
3rd German Perl Workshop and received the \*(L"Best Knowledge Transfer\*(R"
prize.
.PP
.Vb 2
\&    Talk: http://www.astray.com/graphing_perl/graphing_perl.pdf
\&  Slides: http://www.astray.com/graphing_perl/
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
This is the constructor. It accepts several attributes.
.PP
.Vb 7
\&  my $g = GraphViz\->new();
\&  my $g = GraphViz\->new(directed => 0);
\&  my $g = GraphViz\->new(layout => \*(Aqneato\*(Aq, ratio => \*(Aqcompress\*(Aq);
\&  my $g = GraphViz\->new(rankdir  => \*(AqBT\*(Aq);
\&  my $g = GraphViz\->new(width => 8.5, height => 11);
\&  my $g = GraphViz\->new(width => 30, height => 20,
\&                        pagewidth => 8.5, pageheight => 11);
.Ve
.PP
The most two important attributes are 'layout' and 'directed'.
.IP "layout" 4
.IX Item "layout"
The 'layout' attribute determines which layout algorithm GraphViz.pm will
use. Possible values are:
.RS 4
.IP "dot" 4
.IX Item "dot"
The default GraphViz layout for directed graph layouts
.IP "neato" 4
.IX Item "neato"
For undirected graph layouts \- spring model
.IP "twopi" 4
.IX Item "twopi"
For undirected graph layouts \- radial
.IP "circo" 4
.IX Item "circo"
For undirected graph layouts \- circular
.IP "fdp" 4
.IX Item "fdp"
For undirected graph layouts \- force directed spring model
.RE
.RS 4
.RE
.IP "directed" 4
.IX Item "directed"
The 'directed' attribute, which defaults to 1 (true) specifies
directed (edges have arrows) graphs. Setting this to zero produces
undirected graphs (edges do not have arrows).
.IP "rankdir" 4
.IX Item "rankdir"
Another attribute 'rankdir' controls the direction in which the nodes are linked
together. The default is '\s-1TB\s0' (arrows from top to bottom). Other legal values
are '\s-1BT\s0' (bottom\->top), '\s-1LR\s0' (left\->right) and '\s-1RL\s0' (right\->left).
.IP "width, height" 4
.IX Item "width, height"
The 'width' and 'height' attributes control the size of the bounding
box of the drawing in inches. This is more useful for PostScript
output as for raster graphic (such as \s-1PNG\s0) the pixel dimensions
can not be set, although there are generally 96 pixels per inch.
.IP "pagewidth, pageheight" 4
.IX Item "pagewidth, pageheight"
The 'pagewidth' and 'pageheight' attributes set the PostScript
pagination size in inches. That is, if the image is larger than the
page then the resulting PostScript image is a sequence of pages that
can be tiled or assembled into a mosaic of the full image. (This only
works for PostScript output).
.IP "concentrate" 4
.IX Item "concentrate"
The 'concentrate' attribute controls enables an edge merging technique
to reduce clutter in dense layouts of directed graphs. The default is
not to merge edges.
.IP "orientation" 4
.IX Item "orientation"
This option controls the angle, in degrees, used to rotate polygon node shapes.
.IP "random_start" 4
.IX Item "random_start"
For undirected graphs, the 'random_start' attribute requests an
initial random placement for the graph, which may give a better
result. The default is not random.
.IP "epsilon" 4
.IX Item "epsilon"
For undirected graphs, the 'epsilon' attribute decides how long the
graph solver tries before finding a graph layout. Lower numbers allow
the solver to fun longer and potentially give a better layout. Larger
values can decrease the running time but with a reduction in layout
quality. The default is 0.1.
.IP "overlap" 4
.IX Item "overlap"
The 'overlap' option allows you to set layout behavior for graph nodes
that overlap.  (From GraphViz documentation:)
.Sp
Determines if and how node overlaps should be removed.
.RS 4
.IP "true" 4
.IX Item "true"
(the default) overlaps are retained.
.IP "scale" 4
.IX Item "scale"
overlaps are removed by uniformly scaling in x and y.
.IP "false" 4
.IX Item "false"
If the value converts to \*(L"false\*(R", node overlaps are removed by a Voronoi-based technique.
.IP "scalexy" 4
.IX Item "scalexy"
x and y are separately scaled to remove overlaps.
.IP "orthoxy, orthxy" 4
.IX Item "orthoxy, orthxy"
If the value is \*(L"orthoxy\*(R" or \*(L"orthoyx\*(R", overlaps are moved by optimizing two
constraint problems, one for the x axis and one for the y. The suffix indicates
which axis is processed first.
.Sp
\&\fB\s-1NOTE\s0\fR: The methods related to \*(L"orthoxy\*(R" and \*(L"orthoyx\*(R" are still evolving. The
semantics of these may change, or these methods may disappear altogether.
.IP "compress" 4
.IX Item "compress"
If the value is \*(L"compress\*(R", the layout will be scaled down as much as possible
without introducing any overlaps.
.RE
.RS 4
.Sp
Except for the Voronoi method, all of these transforms preserve the orthogonal
ordering of the original layout. That is, if the x coordinates of two nodes are
originally the same, they will remain the same, and if the x coordinate of one
node is originally less than the x coordinate of another, this relation will
still hold in the transformed layout. The similar properties hold for the y
coordinates.
.RE
.IP "no_overlap" 4
.IX Item "no_overlap"
The 'no_overlap' overlap option, if set, tells the graph solver to not
overlap the nodes.  Deprecated,  Use 'overlap' => 'false'.
.IP "ratio" 4
.IX Item "ratio"
The 'ratio' option sets the aspect ratio (drawing height/drawing width) for the
drawing. Note that this is adjusted before the size attribute constraints are
enforced.  Default value is \f(CW\*(C`fill\*(C'\fR.
.RS 4
.IP "numeric" 4
.IX Item "numeric"
If ratio is numeric, it is taken as the desired aspect ratio. Then, if the
actual aspect ratio is less than the desired ratio, the drawing height is
scaled up to achieve the desired ratio; if the actual ratio is greater than
that desired ratio, the drawing width is scaled up.
.IP "fill" 4
.IX Item "fill"
If ratio = \f(CW\*(C`fill\*(C'\fR and the size attribute is set, node positions are scaled,
separately in both x and y, so that the final drawing exactly fills the
specified size.
.IP "compress" 4
.IX Item "compress"
If ratio = \f(CW\*(C`compress\*(C'\fR and the size attribute is set, dot attempts to compress
the initial layout to fit in the given size. This achieves a tighter packing of
nodes but reduces the balance and symmetry. This feature only works in dot.
.IP "expand" 4
.IX Item "expand"
If ratio = \f(CW\*(C`expand\*(C'\fR the size attribute is set, and both the width and the
height of the graph are less than the value in size, node positions are scaled
uniformly until at least one dimension fits size exactly. Note that this is
distinct from using size as the desired size, as here the drawing is expanded
before edges are generated and all node and text sizes remain unchanged.
.IP "auto" 4
.IX Item "auto"
If ratio = \f(CW\*(C`auto\*(C'\fR the page attribute is set and the graph cannot be drawn on a
single page, then size is set to an ``ideal'' value. In particular, the size in
a given dimension will be the smallest integral multiple of the page size in
that dimension which is at least half the current size. The two dimensions are
then scaled independently to the new size. This feature only works in dot.
.RE
.RS 4
.RE
.IP "bgcolor" 4
.IX Item "bgcolor"
The 'bgcolor' option sets the background colour. A colour value may be
\&\*(L"h,s,v\*(R" (hue, saturation, brightness) floating point numbers between 0
and 1, or an X11 color name such as 'white', 'black', 'red', 'green',
\&'blue', 'yellow', 'magenta', 'cyan', or 'burlywood'.
.IP "name" 4
.IX Item "name"
The 'name' option sets name of the graph. This option is useful in few
situations, like client side image map generation, see cmapx.
By default 'test' is used.
.IP "node,edge,graph" 4
.IX Item "node,edge,graph"
The 'node', 'edge' and 'graph' attributes allow you to specify global
node, edge and graph attributes (in addition to those controlled by
the special attributes described above). The value should be a hash
reference containing the corresponding key-value pairs. For example,
to make all nodes box-shaped (unless explicitly given another shape):
.Sp
.Vb 1
\&  my $g = GraphViz\->new(node => {shape => \*(Aqbox\*(Aq});
.Ve
.SS "add_node"
.IX Subsection "add_node"
A graph consists of at least one node. All nodes have a name attached
which uniquely represents that node.
.PP
The add_node method creates a new node and optionally assigns it
attributes.
.PP
The simplest form is used when no attributes are required, in which
the string represents the name of the node:
.PP
.Vb 1
\&  $g\->add_node(\*(AqParis\*(Aq);
.Ve
.PP
Various attributes are possible: \*(L"label\*(R" provides a label for the node
(the label defaults to the name if none is specified). The label can
contain embedded newlines with '\en', as well as '\ec', '\el', '\er' for
center, left, and right justified lines:
.PP
.Vb 1
\&  $g\->add_node(\*(AqParis\*(Aq, label => \*(AqCity of\enlurve\*(Aq);
.Ve
.PP
Attributes need not all be specified in the one line: successive
declarations of the same node have a cumulative effect, in that any
later attributes are just added to the existing ones. For example, the
following two lines are equivalent to the one above:
.PP
.Vb 2
\&  $g\->add_node(\*(AqParis\*(Aq);
\&  $g\->add_node(\*(AqParis\*(Aq, label => \*(AqCity of\enlurve\*(Aq);
.Ve
.PP
Note that multiple attributes can be specified. Other attributes
include:
.IP "height, width" 4
.IX Item "height, width"
sets the minimum height or width
.IP "shape" 4
.IX Item "shape"
sets the node shape. This can be one of: 'record', 'plaintext',
\&'ellipse', 'circle', 'egg', 'triangle', 'box', 'diamond', 'trapezium',
\&'parallelogram', 'house', 'hexagon', 'octagon'
.IP "fontsize" 4
.IX Item "fontsize"
sets the label size in points
.IP "fontname" 4
.IX Item "fontname"
sets the label font family name
.IP "color" 4
.IX Item "color"
sets the outline colour, and the default fill colour if the 'style' is
\&'filled' and 'fillcolor' is not specified
.Sp
A colour value may be \*(L"h,s,v\*(R" (hue, saturation, brightness) floating
point numbers between 0 and 1, or an X11 color name such as 'white',
\&'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan', or
\&'burlywood'
.IP "fillcolor" 4
.IX Item "fillcolor"
sets the fill colour when the style is 'filled'. If not specified, the
\&'fillcolor' when the 'style' is 'filled' defaults to be the same as
the outline color
.IP "style" 4
.IX Item "style"
sets the style of the node. Can be one of: 'filled', 'solid',
\&'dashed', 'dotted', 'bold', 'invis'
.IP "\s-1URL\s0" 4
.IX Item "URL"
sets the url for the node in image map and PostScript files. The
string '\eN' value will be replaced by the node name. In PostScript
files, \s-1URL\s0 information is embedded in such a way that Acrobat
Distiller creates \s-1PDF\s0 files with active hyperlinks
.PP
If you wish to add an anonymous node, that is a node for which you do
not wish to generate a name, you may use the following form, where the
GraphViz module generates a name and returns it for you. You may then
use this name later on to refer to this node:
.PP
.Vb 1
\&  my $nodename = $g\->add_node(\*(Aqlabel\*(Aq => \*(AqRoman city\*(Aq);
.Ve
.PP
Nodes can be clustered together with the \*(L"cluster\*(R" attribute, which is
drawn by having a labelled rectangle around all the nodes in a
cluster. An empty string means not clustered.
.PP
.Vb 2
\&  $g\->add_node(\*(AqLondon\*(Aq, cluster => \*(AqEurope\*(Aq);
\&  $g\->add_node(\*(AqAmsterdam\*(Aq, cluster => \*(AqEurope\*(Aq);
.Ve
.PP
Clusters can also take a hashref so that you can set attributes:
.PP
.Vb 8
\&  my $eurocluster = {
\&    name      =>\*(AqEurope\*(Aq,
\&    style     =>\*(Aqfilled\*(Aq,
\&    fillcolor =>\*(Aqlightgray\*(Aq,
\&    fontname  =>\*(Aqarial\*(Aq,
\&    fontsize  =>\*(Aq12\*(Aq,
\&  };
\&  $g\->add_node(\*(AqLondon\*(Aq, cluster => $eurocluster, @default_attrs);
.Ve
.PP
Nodes can be located in the same rank (that is, at the same level in
the graph) with the \*(L"rank\*(R" attribute. Nodes with the same rank value
are ranked together.
.PP
.Vb 2
\&  $g\->add_node(\*(AqParis\*(Aq, rank => \*(Aqtop\*(Aq);
\&  $g\->add_node(\*(AqBoston\*(Aq, rank => \*(Aqtop\*(Aq);
.Ve
.PP
Also, nodes can consist of multiple parts (known as ports). This is
implemented by passing an array reference as the label, and the parts
are displayed as a label. GraphViz has a much more complete port
system, this is just a simple interface to it. See the 'from_port' and
\&'to_port' attributes of add_edge:
.PP
.Vb 1
\&  $g\->add_node(\*(AqLondon\*(Aq, label => [\*(AqHeathrow\*(Aq, \*(AqGatwick\*(Aq]);
.Ve
.SS "add_edge"
.IX Subsection "add_edge"
Edges are directed (or undirected) links between nodes. This method
creates a new edge between two nodes and optionally assigns it
attributes.
.PP
The simplest form is when now attributes are required, in which case
the nodes from and to which the edge should be are specified. This
works well visually in the program code:
.PP
.Vb 1
\&  $g\->add_edge(\*(AqLondon\*(Aq => \*(AqParis\*(Aq);
.Ve
.PP
Attributes such as 'label' can also be used. This specifies a label
for the edge.  The label can contain embedded newlines with '\en', as
well as '\ec', '\el', '\er' for center, left, and right justified lines.
.PP
.Vb 1
\&  $g\->add_edge(\*(AqLondon\*(Aq => \*(AqNew York\*(Aq, label => \*(AqFar\*(Aq);
.Ve
.PP
Note that multiple attributes can be specified. Other attributes
include:
.IP "minlen" 4
.IX Item "minlen"
sets an integer factor that applies to the edge length (ranks for
normal edges, or minimum node separation for flat edges)
.IP "weight" 4
.IX Item "weight"
sets the integer cost of the edge. Values greater than 1 tend to
shorten the edge. Weight 0 flat edges are ignored for ordering
nodes
.IP "fontsize" 4
.IX Item "fontsize"
sets the label type size in points
.IP "fontname" 4
.IX Item "fontname"
sets the label font family name
.IP "fontcolor" 4
.IX Item "fontcolor"
sets the label text colour
.IP "color" 4
.IX Item "color"
sets the line colour for the edge
.Sp
A colour value may be \*(L"h,s,v\*(R" (hue, saturation, brightness) floating
point numbers between 0 and 1, or an X11 color name such as 'white',
\&'black', 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan', or
\&'burlywood'
.IP "style" 4
.IX Item "style"
sets the style of the node. Can be one of: 'filled', 'solid',
\&'dashed', 'dotted', 'bold', 'invis'
.IP "dir" 4
.IX Item "dir"
sets the arrow direction. Can be one of: 'forward', 'back', 'both',  'none'
.IP "tailclip, headclip" 4
.IX Item "tailclip, headclip"
when set to false disables endpoint shape clipping
.IP "arrowhead, arrowtail" 4
.IX Item "arrowhead, arrowtail"
sets the type for the arrow head or tail. Can be one of: 'none',
\&'normal', 'inv', 'dot', 'odot', 'invdot', 'invodot.'
.IP "arrowsize" 4
.IX Item "arrowsize"
sets the arrow size: (norm_length=10,norm_width=5,
inv_length=6,inv_width=7,dot_radius=2)
.IP "headlabel, taillabel" 4
.IX Item "headlabel, taillabel"
sets the text for port labels. Note that labelfontcolor,
labelfontname, labelfontsize are also allowed
.IP "labeldistance, port_label_distance" 4
.IX Item "labeldistance, port_label_distance"
sets the distance from the edge / port to the label. Also labelangle
.IP "decorate" 4
.IX Item "decorate"
if set, draws a line from the edge to the label
.IP "samehead, sametail" 4
.IX Item "samehead, sametail"
if set aim edges having the same value to the same port, using the
average landing point
.IP "constraint" 4
.IX Item "constraint"
if set to false causes an edge to be ignored for rank assignment
.PP
Additionally, adding edges between ports of a node is done via the
\&'from_port' and 'to_port' parameters, which currently takes in the
offset of the port (ie 0, 1, 2...).
.PP
.Vb 1
\&  $g\->add_edge(\*(AqLondon\*(Aq => \*(AqParis\*(Aq, from_port => 0);
.Ve
.SS "as_canon, as_text, as_gif etc. methods"
.IX Subsection "as_canon, as_text, as_gif etc. methods"
There are a number of methods which generate input for dot / neato /
twopi / circo / fdp or output the graph in a variety of formats.
.PP
Note that if you pass a filename, the data is written to that
filename. If you pass a filehandle, the data will be streamed to the
filehandle. If you pass a scalar reference, then the data will be
stored in that scalar. If you pass it a code reference, then it is
called with the data (note that the coderef may be called multiple
times if the image is large). Otherwise, the data is returned:
.PP
\&\fBWin32 Note:\fR you will probably want to binmode any filehandles you write
the output to if you want your application to be portable to Win32.
.PP
.Vb 9
\&  my $png_image = $g\->as_png;
\&  # or
\&  $g\->as_png("pretty.png"); # save image
\&  # or
\&  $g\->as_png(\e*STDOUT); # stream image to a filehandle
\&  # or
\&  #g\->as_png(\e$text); # save data in a scalar
\&  # or
\&  $g\->as_png(sub { $png_image .= shift });
.Ve
.IP "as_debug" 4
.IX Item "as_debug"
The as_debug method returns the dot file which we pass to GraphViz. It
does not lay out the graph. This is mostly useful for debugging.
.Sp
.Vb 1
\&  print $g\->as_debug;
.Ve
.IP "as_canon" 4
.IX Item "as_canon"
The as_canon method returns the canonical dot / neato / twopi / circo / fdp  file
which corresponds to the graph. It does not layout the graph \- every
other as_* method does.
.Sp
.Vb 1
\&  print $g\->as_canon;
\&
\&
\&  # prints out something like:
\&  digraph test {
\&      node [    label = "\eN" ];
\&      London [label=London];
\&      Paris [label="City of\enlurve"];
\&      New_York [label="New York"];
\&      London \-> Paris;
\&      London \-> New_York [label=Far];
\&      Paris \-> London;
\&  }
.Ve
.IP "as_text" 4
.IX Item "as_text"
The as_text method returns text which is a layed-out dot / neato /
twopi / circo / fdp format file.
.Sp
.Vb 1
\&  print $g\->as_text;
\&
\&  # prints out something like:
\&  digraph test {
\&      node [    label = "\eN" ];
\&      graph [bb= "0,0,162,134"];
\&      London [label=London, pos="33,116", width="0.89", height="0.50"];
\&      Paris [label="City of\enlurve", pos="33,23", width="0.92", height="0.62"];
\&      New_York [label="New York", pos="123,23", width="1.08", height="0.50"];
\&      London \-> Paris [pos="e,27,45 28,98 26,86 26,70 27,55"];
\&      London \-> New_York [label=Far, pos="e,107,40 49,100 63,85 84,63 101,46", lp="99,72"];
\&      Paris \-> London [pos="s,38,98 39,92 40,78 40,60 39,45"];
\&  }
.Ve
.IP "as_ps" 4
.IX Item "as_ps"
Returns a string which contains a layed-out PostScript-format file.
.Sp
.Vb 1
\&  print $g\->as_ps;
.Ve
.IP "as_hpgl" 4
.IX Item "as_hpgl"
Returns a string which contains a layed-out \s-1HP\s0 pen plotter-format file.
.Sp
.Vb 1
\&  print $g\->as_hpgl;
.Ve
.IP "as_pcl" 4
.IX Item "as_pcl"
Returns a string which contains a layed-out Laserjet printer-format file.
.Sp
.Vb 1
\&  print $g\->as_pcl;
.Ve
.IP "as_mif" 4
.IX Item "as_mif"
Returns a string which contains a layed-out FrameMaker graphics-format file.
.Sp
.Vb 1
\&  print $g\->as_mif;
.Ve
.IP "as_pic" 4
.IX Item "as_pic"
Returns a string which contains a layed-out PIC-format file.
.Sp
.Vb 1
\&  print $g\->as_pic;
.Ve
.IP "as_gd" 4
.IX Item "as_gd"
Returns a string which contains a layed-out GD-format file.
.Sp
.Vb 1
\&  print $g\->as_gd;
.Ve
.IP "as_gd2" 4
.IX Item "as_gd2"
Returns a string which contains a layed-out GD2\-format file.
.Sp
.Vb 1
\&  print $g\->as_gd2;
.Ve
.IP "as_gif" 4
.IX Item "as_gif"
Returns a string which contains a layed-out GIF-format file.
.Sp
.Vb 1
\&  print $g\->as_gif;
.Ve
.IP "as_jpeg" 4
.IX Item "as_jpeg"
Returns a string which contains a layed-out JPEG-format file.
.Sp
.Vb 1
\&  print $g\->as_jpeg;
.Ve
.IP "as_png" 4
.IX Item "as_png"
Returns a string which contains a layed-out PNG-format file.
.Sp
.Vb 2
\&  print $g\->as_png;
\&  $g\->as_png("pretty.png"); # save image
.Ve
.IP "as_wbmp" 4
.IX Item "as_wbmp"
Returns a string which contains a layed-out Windows BMP-format file.
.Sp
.Vb 1
\&  print $g\->as_wbmp;
.Ve
.IP "as_cmap  (deprecated)" 4
.IX Item "as_cmap (deprecated)"
Returns a string which contains a layed-out \s-1HTML\s0 client-side image map
format file.   Use as_cmapx instead.
.Sp
.Vb 1
\&  print $g\->as_cmap;
.Ve
.IP "as_cmapx" 4
.IX Item "as_cmapx"
Returns a string which contains a layed-out \s-1HTML HTML/X\s0 client-side image map
format file. Name and id attributes of map element are set to name of the graph.
.Sp
.Vb 1
\&  print $g\->as_cmapx;
.Ve
.IP "as_ismap (deprecated)" 4
.IX Item "as_ismap (deprecated)"
Returns a string which contains a layed-out old-style server-side
image map format file.  Use as_imap instead.
.Sp
.Vb 1
\&  print $g\->as_ismap;
.Ve
.IP "as_imap" 4
.IX Item "as_imap"
Returns a string which contains a layed-out \s-1HTML\s0 new-style server-side
image map format file.
.Sp
.Vb 1
\&  print $g\->as_imap;
.Ve
.IP "as_vdx" 4
.IX Item "as_vdx"
Returns a string which contains a VDX-format (Microsoft Visio) file.
.Sp
.Vb 1
\&  print $g\->as_vdx;
.Ve
.IP "as_vrml" 4
.IX Item "as_vrml"
Returns a string which contains a layed-out VRML-format file.
.Sp
.Vb 1
\&  print $g\->as_vrml;
.Ve
.IP "as_vtx" 4
.IX Item "as_vtx"
Returns a string which contains a layed-out \s-1VTX\s0 (Visual Thought)
format file.
.Sp
.Vb 1
\&  print $g\->as_vtx;
.Ve
.IP "as_mp" 4
.IX Item "as_mp"
Returns a string which contains a layed-out MetaPost-format file.
.Sp
.Vb 1
\&  print $g\->as_mp;
.Ve
.IP "as_fig" 4
.IX Item "as_fig"
Returns a string which contains a layed-out FIG-format file.
.Sp
.Vb 1
\&  print $g\->as_fig;
.Ve
.IP "as_svg" 4
.IX Item "as_svg"
Returns a string which contains a layed-out SVG-format file.
.Sp
.Vb 1
\&  print $g\->as_svg;
.Ve
.IP "as_svgz" 4
.IX Item "as_svgz"
Returns a string which contains a layed-out SVG-format file
that is compressed.
.Sp
.Vb 1
\&  print $g\->as_svgz;
.Ve
.IP "as_plain" 4
.IX Item "as_plain"
Returns a string which contains a layed-out simple-format file.
.Sp
.Vb 1
\&  print $g\->as_plain;
.Ve
.SH "FAQ"
.IX Header "FAQ"
.SS "Why do I get error messages like the following?"
.IX Subsection "Why do I get error messages like the following?"
.Vb 2
\&        Error: <stdin>:1: syntax error near line 1
\&        context: digraph >>>  Graph <<<  {
.Ve
.PP
Graphviz reserves some words as keywords, meaning they can't be used as an \s-1ID,\s0 e.g. for the name of the graph.
So, don't do this:
.PP
.Vb 4
\&        strict graph graph{...}
\&        strict graph Graph{...}
\&        strict graph strict{...}
\&        etc...
.Ve
.PP
Likewise for non-strict graphs, and digraphs. You can however add double-quotes around such reserved words:
.PP
.Vb 1
\&        strict graph "graph"{...}
.Ve
.PP
Even better, use a more meaningful name for your graph...
.PP
The keywords are: node, edge, graph, digraph, subgraph and strict. Compass points are not keywords.
.PP
See keywords <http://www.graphviz.org/content/dot-language> in the discussion of the syntax of \s-1DOT\s0
for details.
.SS "How do you handle \s-1XXE\s0 within \s-1XML\s0?"
.IX Subsection "How do you handle XXE within XML?"
Due to security risks with \s-1XXE\s0 in \s-1XML,\s0 Graphviz does not support \s-1XML\s0 that contains \s-1XXE.\s0 Thus it
automatically prevents external entities being parsed by using the no_xxe option in XML::Twig
when calling XML::Twig \-> \fInew()\fR. And for this reason also the pre-reqs in Makefile.PL specify
XML::Twig V 3.52.
.PP
See <https://metacpan.org/pod/release/MIROD/XML\-Twig\-3.52/Twig.pm#no_xxe>
.SH "NOTES"
.IX Header "NOTES"
Older versions of GraphViz used a slightly different syntax for node
and edge adding (with hash references). The new format is slightly
clearer, although for the moment we support both. Use the new, clear
syntax, please.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
GraphViz is deprecated in favour of GraphViz2.
.SH "Machine-Readable Change Log"
.IX Header "Machine-Readable Change Log"
The file Changes was converted into Changelog.ini by Module::Metadata::Changes.
.SH "Repository"
.IX Header "Repository"
<https://github.com/ronsavage/GraphViz>
.SH "AUTHOR"
.IX Header "AUTHOR"
Leon Brocard: <\fIacme@astray.com\fR>.
.PP
Current maintainer: Ron Savage \fI<ron@savage.net.au>\fR.
.PP
My homepage: <http://savage.net.au/>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000\-4, Leon Brocard
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it or modify it under the Perl License,
a copy of which is available at <http://dev.perl.org/licenses/>.
