.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Run::Alignment::Lagan 3"
.TH Bio::Tools::Run::Alignment::Lagan 3 "2019-10-28" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::Run::Alignment::Lagan \- Object for the local execution of the LAGAN suite of tools (including MLAGAN for multiple sequence alignments)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::Tools::Run::Alignment::Lagan;
\&
\&  @params =
\&      (\*(Aqchaos\*(Aq => "The contents of this string will be passed as args to chaos",
\&
\&       #Read you chaos README file for more info/This functionality
\&       #has not been tested and will be integrated in future versions.
\&
\&       \*(Aqorder\*(Aq => "\e"\-gs \-7 \-gc \-2 \-mt 2 \-ms \-1\e"",
\&       #Where gap start penalty of\- 7, gap continue of \-2, match of 2,
\&       #and mismatch of \-1.
\&
\&       \*(Aqrecurse\*(Aq => "\e"(12,25),(7,25),(4,30)"\e",
\&       #A list of (wordlength,score cutoff) pairs to be used in the
\&       #recursive anchoring
\&
\&       \*(Aqtree\*(Aq => "\e"(sample1 (sample2 sample3))"\e",
\&       #Used by mlagan / tree can also be passed when calling mlagan directly
\&
\&       #SCORING PARAMETERS FOR MLAGAN:
\&       \*(Aqmatch\*(Aq => 12,
\&       \*(Aqmismatch\*(Aq => \-8,
\&       \*(Aqgapstart\*(Aq => \-50,
\&       \*(Aqgapend\*(Aq => \-50,
\&       \*(Aqgapcont\*(Aq => \-2,
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
To run mlagan/lagan, you must have an environment variable that points to
the executable directory with files lagan.pl etc.
\&\*(L"LAGAN_DIR=/opt/lagan_executables/\*(R"
.PP
Simply having the executables in your path is not supported because the
executables themselves only work with the environment variable set.
.PP
All lagan and mlagan parameters listed in their Readmes can be set
except for the mfa flag which has been turned on by default to prevent
parsing of the alignment format.
.PP
\&\s-1TO USE LAGAN:\s0
.PP
.Vb 2
\&  my $lagan = Bio::Tools::Run::Alignment::Lagan\->new(@params);
\&  my $report_out = $lagan\->lagan($seq1, $seq2);
.Ve
.PP
A SimpleAlign object is returned.
.PP
\&\s-1TO USE MLAGAN:\s0
.PP
.Vb 3
\&  my $lagan = Bio::Tools::Run::Alignment::Lagan\->new();
\&  my $tree = "(($seqname1 $seqname2) $seqname3)";
\&  my @sequence_objs;    #an array of bioperl Seq objects
\&
\&  ##If you use an unblessed seq array
\&  my $seq_ref = \e@sequence_objs;
\&  bless $seq_ref, "ARRAY";
\&
\&  my $report_out = $lagan\->mlagan($seq_ref, $tree);
\&
\&  A SimpleAlign object is returned
.Ve
.PP
Only basic mlagan/lagan functionality has been implemented due to the
iterative development of their project.  Future maintenance upgrades
will include enhanced features and scoring.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Stephen Montgomery"
.IX Header "AUTHOR - Stephen Montgomery"
Email smontgom@bcgsc.bc.ca
.PP
Genome Sciences Centre in beautiful Vancouver, British Columbia \s-1CANADA\s0
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
MLagan/Lagan is the hard work of Michael Brudno et al.
.PP
Sendu Bala bix@sendu.me.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "lagan"
.IX Subsection "lagan"
.Vb 2
\&  Runs the Lagan pairwise alignment algorithm
\&  Inputs should be two PrimarySeq objects.
\&
\&  Returns an SimpleAlign object / preloaded with the tmp file of the
\&  Lagan multifasta output.
.Ve
.SS "mlagan"
.IX Subsection "mlagan"
.Vb 5
\&  Runs the Mlagan multiple sequence alignment algorithm.
\&  Inputs should be an Array of Primary Seq objects and a Phylogenetic Tree in
\&  String format or as a Bio::Tree::TreeI compliant object.
\&  Returns an SimpleAlign object / preloaded with the tmp file of the Mlagan
\&  multifasta output.
.Ve
.SS "nuc_matrix"
.IX Subsection "nuc_matrix"
.Vb 10
\& Title   : nuc_matrix
\& Usage   : my $matrix_obj = $obj\->nuc_matrix();
\&           \-or\-
\&           $obj\->nuc_matrix($matrix_obj);
\&           \-or\-
\&           $obj\->nuc_matrix($matrix_file);
\& Function: Get/set the substitution matrix for use by mlagan. By default the
\&           file $LAGAN_DIR/nucmatrix.txt is used by mlagan. By default this
\&           method returns a corresponding Matrix.
\& Returns : Bio::Matrix::Mlagan object
\& Args    : none to get, OR to set:
\&           Bio::Matrix::MLagan object
\&           OR
\&           filename of an mlagan substitution matrix file
\&
\&           NB: due to a bug in mlagan 2.0, the \-nucmatrixfile option does not
\&           work, so this Bioperl wrapper is unable to simply point mlagan to
\&           your desired matrix file (or to a temp file generated from your
\&           matrix object). Instead the $LAGAN_DIR/nucmatrix.txt file must
\&           actually be replaced. This wrapper will make a back\-up copy of that
\&           file, write the new file in its place, then revert things back to the
\&           way they were after the alignment has been produced. For this reason,
\&           $LAGAN_DIR must be writable, as must $LAGAN_DIR/nucmatrix.txt.
.Ve
.SS "_setinput"
.IX Subsection "_setinput"
.Vb 5
\& Title   : _setinput
\& Usage   : Internal function, not to be called directly
\& Function: Create input file(s) for Lagan executables
\& Returns : name of files containing Lagan data input / 
\&           or array of files and phylo tree for Mlagan data input
.Ve
.SS "_generic_lagan"
.IX Subsection "_generic_lagan"
.Vb 3
\& Title   : _generic_lagan
\& Usage   :  internal function not called directly
\& Returns :  SimpleAlign object
.Ve
.SS "_setparams"
.IX Subsection "_setparams"
.Vb 5
\& Title   : _setparams
\& Usage   : Internal function, not to be called directly
\& Function: Create parameter inputs for (m)Lagan program
\& Returns : parameter string to be passed to Lagan
\& Args    : Reference to calling object and name of (m)Lagan executable
.Ve
.SS "_runlagan"
.IX Subsection "_runlagan"
.Vb 5
\& Title   :  _runlagan
\& Usage   :  Internal function, not to be called directly
\& Function:   makes actual system call to (m)Lagan program
\& Example :
\& Returns : Report object in the SimpleAlign object
.Ve
.SS "executable"
.IX Subsection "executable"
.Vb 6
\& Title   : executable
\& Usage   : my $exe = $lagan\->executable(\*(Aqmlagan\*(Aq);
\& Function: Finds the full path to the \*(Aqlagan\*(Aq executable
\& Returns : string representing the full path to the exe
\& Args    : [optional] name of executable to set path to
\&           [optional] boolean flag whether or not warn when exe is not found
\&
\& Thanks to Jason Stajich for providing the framework for this subroutine
.Ve
.SS "program_path"
.IX Subsection "program_path"
.Vb 4
\& Title   : program_path
\& Usage   : my $path = $lagan\->program_path();
\& Function: Builds path for executable
\& Returns : string representing the full path to the exe
\&
\& Thanks to Jason Stajich for providing the framework for this subroutine
.Ve
.SS "program_dir"
.IX Subsection "program_dir"
.Vb 5
\& Title   : program_dir
\& Usage   : my $dir = $lagan\->program_dir();
\& Function: Abstract get method for dir of program. To be implemented
\&           by wrapper.
\& Returns : string representing program directory
\&
\& Thanks to Jason Stajich for providing the framework for this subroutine
.Ve
.SS "version"
.IX Subsection "version"
.Vb 5
\& Title   : version
\& Usage   : my $version = $lagan\->version;
\& Function: returns the program version
\& Returns : number
\& Args    : none
.Ve
