.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "GraphViz::Parse::RecDescent 3"
.TH GraphViz::Parse::RecDescent 3 "2016-12-27" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GraphViz::Parse::RecDescent \- Visualise grammars
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use GraphViz::Parse::RecDescent;
\&
\&  # Either pass in the grammar
\&  my $graph = GraphViz::Parse::RecDescent\->new($grammar);
\&  print $g\->as_png;
\&
\&  # or a Parse::RecDescent parser object
\&  my $graph = GraphViz::Parse::RecDescent\->new($parser);
\&  print $g\->as_ps;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module makes it easy to visualise Parse::RecDescent grammars.
Writing Parse::RecDescent grammars is tricky at the best of times, and
grammars almost always evolve in ways unforseen at the start. This
module aims to visualise a grammar as a graph in order to make the
structure clear and aid in understanding the grammar.
.PP
Rules are represented as nodes, which have their name on the left of
the node and their productions on the right of the node. The subrules
present in the productions are represented by edges to the subrule
nodes.
.PP
Thus, every node (rule) should be connected to the graph \- otherwise a
rule is not part of the grammar.
.PP
This uses the GraphViz module to draw the graph. Thanks to Damian
Conway for the idea.
.PP
Note that the Parse::RecDescent module should be installed.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
This is the constructor. It takes one mandatory argument, which can
either be the grammar text or a Parse::RecDescent parser object of the
grammar to be visualised. A GraphViz object is returned.
.PP
.Vb 2
\&  # Either pass in the grammar
\&  my $graph = GraphViz::Parse::RecDescent\->new($grammar);
\&
\&  # or a Parse::RecDescent parser object
\&  my $graph = GraphViz::Parse::RecDescent\->new($parser);
.Ve
.SS "as_*"
.IX Subsection "as_*"
The grammar can be visualised in a number of different graphical
formats. Methods include as_ps, as_hpgl, as_pcl, as_mif, as_pic,
as_gd, as_gd2, as_gif, as_jpeg, as_png, as_wbmp, as_ismap, as_imap,
as_vrml, as_vtx, as_mp, as_fig, as_svg. See the GraphViz documentation
for more information. The two most common methods are:
.PP
.Vb 2
\&  # Print out a PNG\-format file
\&  print $g\->as_png;
\&
\&  # Print out a PostScript\-format file
\&  print $g\->as_ps;
.Ve
.SH "BUGS"
.IX Header "BUGS"
Translating the grammar to a graph is accomplished by peeking inside
the internals of a parser object, which is a tad scary. A new version
of Parse::RecDescent with different internals may break this module.
.PP
At the moment, almost all Parse::RecDescent directives are
supported. If you find one that has been missed \- let me know!
.PP
Unfortunately, alternations (such as the following) do not produce
very pretty graphs, due to the fact that they are implicit (unamed)
rules and are implemented by new long-named subrules.
.PP
.Vb 1
\&  character: \*(Aqthe\*(Aq ( good | bad | ugly ) /dude/
.Ve
.PP
Hopefully Parse::FastDescent will make this all much easier.
.SH "AUTHOR"
.IX Header "AUTHOR"
Leon Brocard <\fIacme@astray.com\fR>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2001, Leon Brocard
.PP
This module is free software; you can redistribute it or modify it under the Perl License,
a copy of which is available at <http://dev.perl.org/licenses/>.
