.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Array::Compare 3"
.TH Array::Compare 3 "2018-08-23" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Array::Compare \- Perl extension for comparing arrays.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Array::Compare;
\&
\&  my $comp1 = Array::Compare\->new;
\&  $comp\->Sep(\*(Aq|\*(Aq);
\&  $comp\->Skip({3 => 1, 4 => 1});
\&  $comp\->WhiteSpace(0);
\&  $comp\->Case(1);
\&
\&  my $comp2 = Array::Compare\->new(Sep => \*(Aq|\*(Aq,
\&                                  WhiteSpace => 0,
\&                                  Case => 1,
\&                                  Skip => {3 => 1, 4 => 1});
\&
\&  my @arr1 = 0 .. 10;
\&  my @arr2 = 0 .. 10;
\&
\&  $comp1\->compare(\e@arr1, \e@arr2);
\&  $comp2\->compare(\e@arr1, \e@arr2);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you have two arrays and you want to know if they are the same or
different, then Array::Compare will be useful to you.
.PP
All comparisons are carried out via a comparator object. In the
simplest usage, you can create and use a comparator object like
this:
.PP
.Vb 2
\&  my @arr1 = 0 .. 10;
\&  my @arr2 = 0 .. 10;
\&
\&  my $comp = Array::Compare\->new;
\&
\&  if ($comp\->compare(\e@arr1, \e@arr2)) {
\&    print "Arrays are the same\en";
\&  } else {
\&    print "Arrays are different\en";
\&  }
.Ve
.PP
Notice that you pass references to the two arrays to the comparison
method.
.PP
Internally the comparator compares the two arrays by using \f(CW\*(C`join\*(C'\fR
to turn both arrays into strings and comparing the strings using
\&\f(CW\*(C`eq\*(C'\fR. In the joined strings, the elements of the original arrays
are separated with the \f(CW\*(C`^G\*(C'\fR character. This can cause problems if
your array data contains \f(CW\*(C`^G\*(C'\fR characters as it is possible that
two different arrays can be converted to the same string.
.PP
To avoid this, it is possible to override the default separator
character, either by passing and alternative to the \f(CW\*(C`new\*(C'\fR function
.PP
.Vb 1
\&  my $comp = Array::Compare\->new(Sep => \*(Aq|\*(Aq);
.Ve
.PP
or by changing the separator for an existing comparator object
.PP
.Vb 1
\&  $comp\->Sep(\*(Aq|\*(Aq);
.Ve
.PP
In general you should choose a separator character that won't appear
in your data.
.PP
You can also control whether or not whitespace within the elements of
the arrays should be considered significant when making the comparison.
The default is that all whitespace is significant. The alternative is
for all consecutive white space characters to be converted to a single
space for the pruposes of the comparison. Again, this can be turned on
when creating a comparator object:
.PP
.Vb 1
\&  my $comp = Array::Compare\->new(WhiteSpace => 0);
.Ve
.PP
or by altering an existing object:
.PP
.Vb 1
\&  $comp\->WhiteSpace(0);
.Ve
.PP
You can also control whether or not the case of the data is significant
in the comparison. The default is that the case of data is taken into
account. This can be changed in the standard ways when creating a new
comparator object:
.PP
.Vb 1
\&  my $comp = Array::Compare\->new(Case => 0);
.Ve
.PP
or by altering an existing object:
.PP
.Vb 1
\&  $comp\->Case(0);
.Ve
.PP
In addition to the simple comparison described above (which returns true
if the arrays are the same and false if they're different) there is also
a full comparison which returns a list containing the indexes of elements
which differ between the two arrays. If the arrays are the same it returns
an empty list. In scalar context the full comparison returns the length of
this list (i.e. the number of elements that differ). You can access the full
comparison in two ways. Firstly, there is a \f(CW\*(C`DefFull\*(C'\fR attribute. If this
is \f(CW\*(C`true\*(C'\fR then a full comparison if carried out whenever the \f(CW\*(C`compare\*(C'\fR
method is called.
.PP
.Vb 2
\&  my $comp = Array::Compare\->new(DefFull => 1);
\&  $comp\->compare(\e@arr1, \e@arr2); # Full comparison
\&
\&  $comp\->DefFull(0);
\&  $comp\->compare(\e@arr1, \e@arr2); # Simple comparison
\&
\&  $comp\->DefFull(1);
\&  $comp\->compare(\e@arr1, \e@arr2); # Full comparison again
.Ve
.PP
Secondly, you can access the full comparison method directly
.PP
.Vb 1
\&  $comp\->full_compare(\e@arr1, \e@arr2);
.Ve
.PP
For symmetry, there is also a direct method to use to call the simple
comparison.
.PP
.Vb 1
\&  $comp\->simple_compare(\e@arr1, \e@arr2);
.Ve
.PP
The final complication is the ability to skip elements in the comparison.
If you know that two arrays will always differ in a particular element
but want to compare the arrays \fIignoring\fR this element, you can do it
with Array::Compare without taking array slices. To do this, a
comparator object has an optional attribute called \f(CW\*(C`Skip\*(C'\fR which is a
reference to a hash. The keys in this hash are the indexes of the array
elements and the values should be any true value for elements that should
be skipped.
.PP
For example, if you want to compare two arrays, ignoring the values in
elements two and four, you can do something like this:
.PP
.Vb 3
\&  my %skip = (2 => 1, 4 => 1);
\&  my @a = (0, 1, 2, 3, 4, 5);
\&  my @b = (0, 1, X, 3, X, 5);
\&
\&  my $comp = Array::Compare\->new(Skip => \e%skip);
\&
\&  $comp\->compare(\e@a, \e@b);
.Ve
.PP
This should return \fItrue\fR, as we are explicitly ignoring the columns
which differ.
.PP
Of course, having created a comparator object with no skip hash, it is
possible to add one later:
.PP
.Vb 1
\&  $comp\->Skip({1 => 1, 2 => 1});
.Ve
.PP
or:
.PP
.Vb 2
\&  my %skip = (1 => 1, 2 => 2);
\&  $comp\->Skip(\e%skip);
.Ve
.PP
To reset the comparator so that no longer skips elements, set the skip
hash to an empty hash.
.PP
.Vb 1
\&  $comp\->Skip({});
.Ve
.PP
You can also check to see if one array is a permutation of another, i.e.
they contain the same elements but in a different order.
.PP
.Vb 5
\&  if ($comp\->perm(\e@a, \e@b) {
\&    print "Arrays are perms\en";
\&  else {
\&    print "Nope. Arrays are completely different\en";
\&  }
.Ve
.PP
In this case the values of \f(CW\*(C`WhiteSpace\*(C'\fR and \f(CW\*(C`Case\*(C'\fR are still used,
but \f(CW\*(C`Skip\*(C'\fR is ignored for, hopefully, obvious reasons.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new [ %OPTIONS ]"
.el .SS "new [ \f(CW%OPTIONS\fP ]"
.IX Subsection "new [ %OPTIONS ]"
Constructs a new comparison object.
.PP
Takes an optional hash containing various options that control how
comparisons are carried out. Any omitted options take useful defaults.
.IP "Sep" 4
.IX Item "Sep"
This is the value that is used to separate fields when the array is joined
into a string. It should be a value which doesn't appear in your data.
Default is '^G'.
.IP "WhiteSpace" 4
.IX Item "WhiteSpace"
Flag that indicates whether or not whitespace is significant in the
comparison. If this value is false then all multiple whitespace characters
are changed into a single space before the comparison takes place. Default
is 1 (whitespace is significant).
.IP "Case" 4
.IX Item "Case"
Flag that indicates whther or not the case of the data should be significant
in the comparison. Default is 1 (case is significant).
.IP "Skip" 4
.IX Item "Skip"
a reference to a hash which contains the numbers of any columns that should
be skipped in the comparison. Default is an empty hash (all columns are
significant).
.IP "DefFull" 4
.IX Item "DefFull"
Flag which indicates whether the default comparison is simple (just returns
true if the arrays are the same or false if they're not) or full (returns an
array containing the indexes of the columns that differ). Default is 0 (simple
comparison).
.SS "compare_len \e@ARR1, \e@ARR2"
.IX Subsection "compare_len @ARR1, @ARR2"
Very simple comparison. Just checks the lengths of the arrays are
the same.
.SS "compare \e@ARR1, \e@ARR2"
.IX Subsection "compare @ARR1, @ARR2"
Compare the values in two arrays and return a data indicating whether
the arrays are the same. The exact return values differ depending on
the comparison method used. See the descriptions of simple_compare
and full_compare for details.
.PP
Uses the value of DefFull to determine which comparison routine
to use.
.SS "simple_compare \e@ARR1, \e@ARR2"
.IX Subsection "simple_compare @ARR1, @ARR2"
Compare the values in two arrays and return a flag indicating whether or
not the arrays are the same.
.PP
Returns true if the arrays are the same or false if they differ.
.PP
Uses the values of 'Sep', 'WhiteSpace' and 'Skip' to influence
the comparison.
.SS "full_compare \e@ARR1, \e@ARR2"
.IX Subsection "full_compare @ARR1, @ARR2"
Do a full comparison between two arrays.
.PP
Checks each individual column. In scalar context returns the number
of columns that differ (zero if the arrays are the same). In list
context returns an list containing the indexes of the columns that
differ (an empty list if the arrays are the same).
.PP
Uses the values of 'Sep' and 'WhiteSpace' to influence the comparison.
.PP
\&\fBNote:\fR If the two arrays are of different lengths then this method
just returns the indexes of the elements that appear in one array but
not the other (i.e. the indexes from the longer array that are beyond
the end of the shorter array). This might be a little
counter-intuitive.
.SS "perm \e@ARR1, \e@ARR2"
.IX Subsection "perm @ARR1, @ARR2"
Check to see if one array is a permutation of the other (i.e. contains
the same set of elements, but in a different order).
.PP
We do this by sorting the arrays and passing references to the assorted
versions to simple_compare. There are also some small changes to
simple_compare as it should ignore the Skip hash if we are called from
perm.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dave Cross <dave@mag\-sol.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2000\-2005, Magnum Solutions Ltd.  All Rights Reserved.
.PP
This script is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
