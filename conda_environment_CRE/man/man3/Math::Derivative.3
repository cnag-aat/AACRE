.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Derivative 3"
.TH Math::Derivative 3 "2018-12-17" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Derivative \- Numeric 1st and 2nd order differentiation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::Derivative qw(:all);
\&
\&    @dydx = forwarddiff(\e@x, \e@y);
\&
\&    @dydx = centraldiff(\e@x, \e@y);
\&
\&    @dydx = Derivative1(\e@x, \e@y);     # A synonym for centraldiff()
\&
\&    @d2ydx2 = Derivative2(\e@x, \e@y, $yd0, $ydn);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Perl package exports functions that numerically approximate first
and second order differentiation on vectors of data. The accuracy of
the approximation will depend upon the differences between the
successive values in the X array.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
The functions may be imported by name or by using the tag \*(L":all\*(R".
.PP
\fI\fIforwarddiff()\fI\fR
.IX Subsection "forwarddiff()"
.PP
.Vb 1
\&    @dydx = forwarddiff(\e@x, \e@y);
.Ve
.PP
Take the references to two arrays containing the x and y ordinates of
the data, and return an array of approximate first derivatives at the
given x ordinates, using the forward difference approximation.
.PP
The last term is actually formed using a backward difference formula,
there being no array item to subtract from at the end of the array.
If you want to use derivatives strictly formed from the forward
difference formula, use only the values from [0 .. #y\-1], e.g.:
.PP
.Vb 1
\&    @dydx = (forwarddiff(\e@x, \e@y))[0 .. $#y\-1];
.Ve
.PP
or, more simply,
.PP
.Vb 2
\&    @dydx = forwarddiff(\e@x, \e@y);
\&    pop @dydx;
.Ve
.PP
\fI\fIcentraldiff()\fI\fR
.IX Subsection "centraldiff()"
.PP
.Vb 1
\&    @dydx = centraldiff(\e@x, \e@y);
.Ve
.PP
Take the references to two arrays containing the x and y ordinates of
the data, and return an array of approximate first derivatives at the
given x ordinates.
.PP
The algorithm used three data points to calculate the derivative, except
at the end points, where by necessity the forward difference algorithm
is used instead. If you want to use derivatives strictly formed from
the central difference formula, use only the values from [1 .. #y\-1],
e.g.:
.PP
.Vb 1
\&    @dydx = (centraldiff(\e@x, \e@y))[1 .. $#y\-1];
.Ve
.PP
\fI\fIDerivative2()\fI\fR
.IX Subsection "Derivative2()"
.PP
.Vb 1
\&    @d2ydx2 = Derivative2(\e@x, \e@y);
.Ve
.PP
or
.PP
.Vb 1
\&    @d2ydx2 = Derivative2(\e@x, \e@y, $yp0, $ypn);
.Ve
.PP
Take references to two arrays containing the x and y ordinates of the
data and return an array of approximate second derivatives at the given
x ordinates.
.PP
You may optionally give values to use as the first derivatives at the
start and end points of the data. If you don't, first derivative values
will be assumed to be zero.
.PP
\fI\fIDerivative1()\fI\fR
.IX Subsection "Derivative1()"
.PP
A synonym for \fIcentraldiff()\fR.
.SH "REFERENCES"
.IX Header "REFERENCES"
<http://www.holoborodko.com/pavel/numerical\-methods/numerical\-derivative/central\-differences/>
.PP
<http://www.robots.ox.ac.uk/~sjrob/Teaching/EngComp/ecl6.pdf>
.SH "AUTHOR"
.IX Header "AUTHOR"
John A.R. Williams \fBJ.A.R.Williams@aston.ac.uk\fR
.PP
John M. Gamble \fBjgamble@cpan.org\fR (current maintainer)
