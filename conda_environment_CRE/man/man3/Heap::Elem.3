.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Heap::Elem 3"
.TH Heap::Elem 3 "2007-04-28" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Heap::Elem \- Base class for elements in a Heap
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Heap::Elem::SomeInheritor;
\&
\&  use Heap::SomeHeapClass;
\&
\&  $elem = Heap::Elem::SomeInheritor\->new( $value );
\&  $heap = Heap::SomeHeapClass\->new;
\&
\&  $heap\->add($elem);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an inheritable class for Heap Elements.  It provides
the interface documentation and some inheritable methods.
Only a child classes can be used \- this class is not complete.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$elem = Heap::Elem::SomeInheritor\->new( [args] );" 4
.el .IP "\f(CW$elem\fR = Heap::Elem::SomeInheritor\->new( [args] );" 4
.IX Item "$elem = Heap::Elem::SomeInheritor->new( [args] );"
Creates a new Elem.
If there is exactly one arg, the Elem's value will be set
to that value.
If there is more than one arg provided, the Elem's value will be set
to an anonymous hash initialized to the provided args (which must
have an even number, of course).
.ie n .IP "$elem\->heap( $val ); $elem\->heap;" 4
.el .IP "\f(CW$elem\fR\->heap( \f(CW$val\fR ); \f(CW$elem\fR\->heap;" 4
.IX Item "$elem->heap( $val ); $elem->heap;"
Provides a method for use by the Heap processing routines.
If a value argument is provided, it will be saved.  The
new saved value is always returned.  If no value argument
is provided, the old saved value is returned.
.Sp
The Heap processing routines use this method to map an element
into its internal structure.  This is needed to support the
Heap methods that affect elements that are not are the top
of the heap \- \fIdecrease_key\fR and \fIdelete\fR.
.Sp
The Heap processing routines will ensure that this value is
undef when this elem is removed from a heap, and is not undef
after it is inserted into a heap.  This means that you can
check whether an element is currently contained within a heap
or not.  (It cannot be used to determine which heap an element
is contained in, if you have multiple heaps.  Keeping that
information accurate would make the operation of merging two
heaps into a single one take longer \- it would have to traverse
all of the elements in the merged heap to update them; for
Binomial and Fibonacci heaps that would turn an O(1) operation
into an O(n) one.)
.ie n .IP "$elem\->val( $val ); $elem\->val;" 4
.el .IP "\f(CW$elem\fR\->val( \f(CW$val\fR ); \f(CW$elem\fR\->val;" 4
.IX Item "$elem->val( $val ); $elem->val;"
Provides a method to get and/or set the value of the element.
.ie n .IP "$elem1\->cmp($elem2)" 4
.el .IP "\f(CW$elem1\fR\->cmp($elem2)" 4
.IX Item "$elem1->cmp($elem2)"
A routine to compare two elements.  It must return a negative
value if this element should go higher on the heap than \fI\f(CI$elem2\fI\fR,
0 if they are equal, or a positive value if this element should
go lower on the heap than \fI\f(CI$elem2\fI\fR.  Just as with sort, the
Perl operators <=> and cmp cause the smaller value to be returned
first; similarly you can negate the meaning to reverse the order
\&\- causing the heap to always return the largest element instead
of the smallest.
.SH "INHERITING"
.IX Header "INHERITING"
This class can be inherited to provide an object with the
ability to be heaped.  If the object is implemented as
a hash, and if it can deal with a key of \fIheap\fR, leaving
it unchanged for use by the heap routines, then the following
implemetation will work.
.PP
.Vb 1
\&  package myObject;
\&
\&  require Exporter;
\&
\&  @ISA = qw(Heap::Elem);
\&
\&  sub new {
\&      my $self = shift;
\&      my $class = ref($self) || $self;
\&
\&      my $self = SUPER::new($class);
\&
\&      # set $self\->{key} = $value;
\&  }
\&
\&  sub cmp {
\&      my $self = shift;
\&      my $other = shift;
\&
\&      $self\->{key} cmp $other\->{key};
\&  }
\&
\&  # other methods for the rest of myObject\*(Aqs functionality
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
John Macdonald, john@perlwolf.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1998\-2007, O'Reilly & Associates.
.PP
This code is distributed under the same copyright terms as perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIHeap\fR\|(3), \fIHeap::Elem::Num\fR\|(3), \fIHeap::Elem::NumRev\fR\|(3),
\&\fIHeap::Elem::Str\fR\|(3), \fIHeap::Elem::StrRev\fR\|(3).
