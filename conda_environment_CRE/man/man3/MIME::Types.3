.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "MIME::Types 3"
.TH MIME::Types 3 "2018-01-26" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MIME::Types \- Definition of MIME types
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& MIME::Types
\&   is a Exporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\& use MIME::Types;
\& my $mt    = MIME::Types\->new(...);    # MIME::Types object
\& my $type  = $mt\->type(\*(Aqtext/plain\*(Aq);  # MIME::Type  object
\& my $type  = $mt\->mimeTypeOf(\*(Aqgif\*(Aq);
\& my $type  = $mt\->mimeTypeOf(\*(Aqpicture.jpg\*(Aq);
\& my @types = $mt\->httpAccept(\*(Aqtext/html, application/json;q=0.1\*(Aq)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1MIME\s0 types are used in many applications (for instance as part of e\-mail
and \s-1HTTP\s0 traffic) to indicate the type of content which is transmitted.
or expected.  See \s-1RFC2045\s0 at \fIhttps://www.ietf.org/rfc/rfc2045.txt\fR
.PP
Sometimes detailed knowledge about a mime-type is need, however this
module only knows about the file-name extensions which relate to some
filetype.  It can also be used to produce the right format: types
which are not registered at \s-1IANA\s0 need to use 'x\-' prefixes.
.PP
This object administers a huge list of known mime-types, combined
from various sources.  For instance, it contains \fBall \s-1IANA\s0\fR types
and the knowledge of Apache.  Probably the most complete table on
the net!
.SS "MIME::Types and daemons (fork)"
.IX Subsection "MIME::Types and daemons (fork)"
If your program uses fork (usually for a daemon), then you want to have
the type table initialized before you start forking. So, first call
.PP
.Vb 1
\&   my $mt = MIME::Types\->new;
.Ve
.PP
Later, each time you create this object (you may, of course, also reuse
the object you create here) you will get access to \fBthe same global table\fR
of types.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "MIME::Types\->\fBnew\fR(%options)" 4
.IX Item "MIME::Types->new(%options)"
Create a new \f(CW\*(C`MIME::Types\*(C'\fR object which manages the data.  In the current
implementation, it does not matter whether you create this object often
within your program, but in the future this may change.
.Sp
.Vb 5
\& \-Option         \-\-Default
\&  db_file          <installed source>
\&  only_complete    <false>
\&  only_iana        <false>
\&  skip_extensions  <false>
.Ve
.RS 4
.IP "db_file => \s-1FILENAME\s0" 2
.IX Item "db_file => FILENAME"
The location of the database which contains the type information.  Only the
first instantiation of this object will have this parameter obeyed.
.Sp
[2.10] This parameter can be globally overruled via the \f(CW\*(C`PERL_MIME_TYPE_DB\*(C'\fR
environment variable, which may be needed in case of \s-1PAR\s0 or other tricky
installations.  For \s-1PAR,\s0 you probably set this environment variable to
\&\*(L"inc/lib/MIME/types.db\*(R"
.IP "only_complete => \s-1BOOLEAN\s0" 2
.IX Item "only_complete => BOOLEAN"
Only include complete \s-1MIME\s0 type definitions: requires at least one known
extension.  This will reduce the number of entries \-\-and with that the
amount of memory consumed\*(-- considerably.
.Sp
In your program you have to decide: the first time that you call
the creator (\f(CW\*(C`new\*(C'\fR) determines whether you get the full or the partial
information.
.IP "only_iana => \s-1BOOLEAN\s0" 2
.IX Item "only_iana => BOOLEAN"
Only load the types which are currently known by \s-1IANA.\s0
.IP "skip_extensions => \s-1BOOLEAN\s0" 2
.IX Item "skip_extensions => BOOLEAN"
Do not load the table to map extensions to types, which is quite large.
.RE
.RS 4
.RE
.SS "Knowledge"
.IX Subsection "Knowledge"
.ie n .IP "$obj\->\fBaddType\fR($type, ...)" 4
.el .IP "\f(CW$obj\fR\->\fBaddType\fR($type, ...)" 4
.IX Item "$obj->addType($type, ...)"
Add one or more TYPEs to the set of known types.  Each \s-1TYPE\s0 is a
\&\f(CW\*(C`MIME::Type\*(C'\fR which must be experimental: either the main-type or
the sub-type must start with \f(CW\*(C`x\-\*(C'\fR.
.Sp
Please inform the maintainer of this module when registered types
are missing.  Before version MIME::Types version 1.14, a warning
was produced when an unknown \s-1IANA\s0 type was added.  This has been
removed, because some people need that to get their application
to work locally... broken applications...
.ie n .IP "$obj\->\fBextensions\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBextensions\fR()" 4
.IX Item "$obj->extensions()"
Returns a list of all defined extensions.
.ie n .IP "$obj\->\fBlistTypes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlistTypes\fR()" 4
.IX Item "$obj->listTypes()"
Returns a list of all defined mime-types by name only.  This will \fBnot\fR
instantiate MIME::Type objects.  See \fItypes()\fR
.ie n .IP "$obj\->\fBmimeTypeOf\fR($filename)" 4
.el .IP "\f(CW$obj\fR\->\fBmimeTypeOf\fR($filename)" 4
.IX Item "$obj->mimeTypeOf($filename)"
Returns the \f(CW\*(C`MIME::Type\*(C'\fR object which belongs to the \s-1FILENAME\s0 (or simply
its filename extension) or \f(CW\*(C`undef\*(C'\fR if the file type is unknown.  The extension
is used and considered case-insensitive.
.Sp
In some cases, more than one type is known for a certain filename extension.
In that case, the preferred one is taken (for an unclear definition of
preference)
.Sp
example: use of \fImimeTypeOf()\fR
.Sp
.Vb 2
\& my $types = MIME::Types\->new;
\& my $mime = $types\->mimeTypeOf(\*(Aqgif\*(Aq);
\&
\& my $mime = $types\->mimeTypeOf(\*(Aqpicture.jpg\*(Aq);
\& print $mime\->isBinary;
.Ve
.ie n .IP "$obj\->\fBtype\fR($string)" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR($string)" 4
.IX Item "$obj->type($string)"
Returns the \f(CW\*(C`MIME::Type\*(C'\fR which describes the type related to \s-1STRING.\s0
[2.00] Only one type will be returned.
.Sp
[before 2.00] One type may be described more than once.  Different
extensions may be in use for this type, and different operating systems
may cause more than one \f(CW\*(C`MIME::Type\*(C'\fR object to be defined.  In scalar
context, only the first is returned.
.ie n .IP "$obj\->\fBtypes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtypes\fR()" 4
.IX Item "$obj->types()"
Returns a list of all defined mime-types.  For reasons of backwards
compatibility, this will instantiate MIME::Type objects, which will
be returned.  See \fIlistTypes()\fR.
.SS "\s-1HTTP\s0 support"
.IX Subsection "HTTP support"
.ie n .IP "$obj\->\fBhttpAccept\fR($header)" 4
.el .IP "\f(CW$obj\fR\->\fBhttpAccept\fR($header)" 4
.IX Item "$obj->httpAccept($header)"
[2.07] Decompose a typical HTTP-Accept header, and sort it based on the
included priority information.  Returned is a sorted list of type names,
where the highest priority type is first.  The list may contain '*/*'
(accept any) or a '*' as subtype.
.Sp
Ill-formated typenames are ignored.  On equal qualities, the order is
kept.  See \s-1RFC2616\s0 section 14.1
.Sp
example:
.Sp
.Vb 1
\&  my @types = $types\->httpAccept(\*(Aqtext/html, application/json;q=0.9\*(Aq);
.Ve
.ie n .IP "$obj\->\fBhttpAcceptBest\fR($accept|\e@types, @have)" 4
.el .IP "\f(CW$obj\fR\->\fBhttpAcceptBest\fR($accept|\e@types, \f(CW@have\fR)" 4
.IX Item "$obj->httpAcceptBest($accept|@types, @have)"
[2.07] The \f(CW$accept\fR string is processed via \fIhttpAccept()\fR to order the
types on preference.  You may also provide a list of ordered \f(CW@types\fR
which may have been the result of that method, called earlier.
.Sp
As second parameter, you pass a \s-1LIST\s0 of types you \f(CW@have\fR to offer.
Those need to be MIME::Type objects. The preferred type will get
selected.  When none of these are accepted by the client, this will
return \f(CW\*(C`undef\*(C'\fR.  It should result in a 406 server response.
.Sp
example:
.Sp
.Vb 3
\&   my $accept = $req\->header(\*(AqAccept\*(Aq);
\&   my @have   = map $mt\->type($_), qw[text/plain text/html];
\&   my @ext    = $mt\->httpAcceptBest($accept, @have);
.Ve
.ie n .IP "$obj\->\fBhttpAcceptSelect\fR($accept|\e@types, @filenames|\e@filenames)" 4
.el .IP "\f(CW$obj\fR\->\fBhttpAcceptSelect\fR($accept|\e@types, \f(CW@filenames\fR|\e@filenames)" 4
.IX Item "$obj->httpAcceptSelect($accept|@types, @filenames|@filenames)"
[2.07] Like \fIhttpAcceptBest()\fR, but now we do not return a pair with mime-type
and filename, not just the type.  If \f(CW$accept\fR is \f(CW\*(C`undef\*(C'\fR, the first
filename is returned.
.Sp
example:
.Sp
.Vb 2
\&   use HTTP::Status \*(Aq:constants\*(Aq;
\&   use File::Glob   \*(Aqbsd_glob\*(Aq;    # understands blanks in filename
\&
\&   my @filenames   = bsd_glob "$imagedir/$fnbase.*;
\&   my $accept      = $req\->header(\*(AqAccept\*(Aq);
\&   my ($fn, $mime) = $mt\->httpAcceptSelect($accept, @filenames);
\&   my $code        = defined $mime ? HTTP_NOT_ACCEPTABLE : HTTP_OK;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The next functions are provided for backward compatibility with MIME::Types
versions [0.06] and below.  This code originates from Jeff Okamoto
\&\fIokamoto@corp.hp.com\fR and others.
.IP "\fBby_mediatype\fR(\s-1TYPE\s0)" 4
.IX Item "by_mediatype(TYPE)"
This function takes a media type and returns a list or anonymous array of
anonymous three-element arrays whose values are the file name suffix used to
identify it, the media type, and a content encoding.
.Sp
\&\s-1TYPE\s0 can be a full type name (contains '/', and will be matched in full),
a partial type (which is used as regular expression) or a real regular
expression.
.IP "\fBby_suffix\fR(FILENAME|SUFFIX)" 4
.IX Item "by_suffix(FILENAME|SUFFIX)"
Like \f(CW\*(C`mimeTypeOf\*(C'\fR, but does not return an \f(CW\*(C`MIME::Type\*(C'\fR object. If the file
+type is unknown, both the returned media type and encoding are empty strings.
.Sp
example: use of function \fIby_suffix()\fR
.Sp
.Vb 2
\& use MIME::Types \*(Aqby_suffix\*(Aq;
\& my ($mediatype, $encoding) = by_suffix(\*(Aqimage.gif\*(Aq);
\&
\& my $refdata = by_suffix(\*(Aqimage.gif\*(Aq);
\& my ($mediatype, $encoding) = @$refdata;
.Ve
.IP "\fBimport_mime_types\fR()" 4
.IX Item "import_mime_types()"
This method has been removed: mime-types are only useful if understood
by many parties.  Therefore, the \s-1IANA\s0 assigns names which can be used.
In the table kept by this \f(CW\*(C`MIME::Types\*(C'\fR module all these names, plus
the most often used temporary names are kept.  When names seem to be
missing, please contact the maintainer for inclusion.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of MIME-Types distribution version 2.17,
built on January 26, 2018. Website: \fIhttp://perl.overmeer.net/CPAN/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 1999\-2018 by [Mark Overmeer <markov@cpan.org>]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://dev.perl.org/licenses/\fR
