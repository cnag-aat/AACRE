.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Run::Phylo::SLR 3"
.TH Bio::Tools::Run::Phylo::SLR 3 "2019-10-28" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::Run::Phylo::SLR \- Wrapper around the SLR program
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Bio::Tools::Run::Phylo::SLR;
\&  use Bio::AlignIO;
\&  use Bio::TreeIO;
\&  use Bio::SimpleAlign;
\&
\&  my $alignio = Bio::AlignIO\->new
\&      (\-format => \*(Aqfasta\*(Aq,
\&       \-file   => \*(Aqt/data/219877.cdna.fasta\*(Aq);
\&
\&  my $aln = $alignio\->next_aln;
\&
\&  my $treeio = Bio::TreeIO\->new
\&      (\-format => \*(Aqnewick\*(Aq, \-file => \*(Aqt/data/219877.tree\*(Aq);
\&
\&  my $tree = $treeio\->next_tree;
\&
\&  my $slr = Bio::Tools::Run::Phylo::SLR\->new();
\&  $slr\->alignment($aln);
\&  $slr\->tree($tree);
\&  # $rc = 1 for success, 0 for errors
\&  my ($rc,$results) = $slr\->run();
\&
\&  my $positive_sites = $results\->{\*(Aqpositive\*(Aq};
\&
\&  print "# Site\etNeutral\etOptimal\etOmega\et",
\&        "lower\etupper\etLRT_Stat\etPval\etAdj.Pval\etResult\etNote\en";
\&  foreach my $positive_site (@$positive_sites) {
\&      print 
\&          $positive_site\->[0], "\et",
\&          $positive_site\->[1], "\et",
\&          $positive_site\->[2], "\et",
\&          $positive_site\->[3], "\et",
\&          $positive_site\->[4], "\et",
\&          $positive_site\->[5], "\et",
\&          $positive_site\->[6], "\et",
\&          $positive_site\->[7], "\et",
\&          $positive_site\->[8], "\et",
\&          "positive\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a wrapper around the \s-1SLR\s0 program. See
http://www.ebi.ac.uk/goldman/SLR/ for more information.
.PP
This module is more about generating the proper ctl file and
will run the program in a separate temporary directory to avoid
creating temp files all over the place.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Albert Vilella"
.IX Header "AUTHOR - Albert Vilella"
Email avilella-at-gmail-dot-com
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Additional contributors names and emails here
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "Default Values"
.IX Subsection "Default Values"
\&\s-1INCOMPLETE DOCUMENTATION OF ALL METHODS\s0
.PP
seqfile [incodon]
  File from which to read alignment of codon sequences. The file
  should be in \s-1PAML\s0 format.
.PP
treefile [intree]
  File from which tree should be read. The tree should be in Nexus
  format
.PP
outfile [slr.res]
  File to which results are written. If the file already exists, it will
  be overwritten.
.PP
reoptimise [1]
  Should the branch lengths, omega and kappa be reoptimized?
  0 \- no
  1 \- yes.
.PP
kappa [2.0]
  Value for kappa. If 'reoptimise' is specified, the value
  given will be used as am initial estimate,
.PP
omega [0.1]
  Value for omega (dN/dS). If 'reoptimise' is specified, the value
  given will be used as an initial estimate.
.PP
codonf [0]
  How codon frequencies are estimated:
    0: F61/F60  Estimates used are the empirical frequencies from the
  data.
    1: F3x4     The frequencies of nucleotides at each codon position
  are estimated from the data and then multiplied together to get the
  frequency of observing a given codon. The frequency of stop codons is
  set to zero, and all other frequencies scaled appropriately.
    2: F1x4     Nucleotide frequencies are estimated from the data
  (not taking into account at which position in the codon it occurs).
  The nucleotide frequencies are multiplied together to get the frequency 
  of observing and then corrected for stop codons.
.PP
freqtype [0]
  How codon frequencies are incorporated into the substitution matrix.
  0: q_{ij} = pi_{j} s_{ij}
  1: q_{ij} = \esqrt(pi_j/pi_i) s_{ij}
  2: q_{ij} = \epi_{n} s_{ij}, where n is the nucleotide that the 
  subsitution is to.
  3: q_{ij} = s_{ij} / pi_i
  Option 0 is the tradition method of incorporating equilibrium frequencies
  into subsitution matrices (Felsenstein 1981; Goldman and Yang, 1994)
  Option 1 is described by Goldman and Whelan (2002), in this case with the
  additional parameter set to 0.5.
  Option 2 was suggested by Muse and Gaut (1994).
  Option 3 is included as an experiment, originally suggested by Bret Larget.
  it does not appear to describe evolution very successfully and should not
  be used for analyses.
.PP
.Vb 3
\&  Kosakovsky\-Pond has repeatedly stated that he finds incorporating codon
\&  frequencies in the manner of option 2 to be superior to option 0. We find
\&  that option 1 tends to perform better than either of these options.
.Ve
.PP
positive_only [0]
  If only positively selected sites are of interest, set this to \*(L"1\*(R".
  Calculation will be slightly faster, but information about sites under
  purifying selection is lost.
.PP
gencode [universal]
  Which genetic code to use when determining whether a given mutation
  is synonymous or nonsynonymous. Currently only \*(L"universal\*(R" and
  \*(L"mammalian\*(R" mitochondrial are supported.
.PP
nucleof [0]
  Allow for empirical exchangabilities for nucleotide substitution.
  0: No adjustment. All nucleotides treated the same, modulo 
  transition / transversion.
  1: The rate at which a substitution caused a mutation from nucleotide
  a to nucleotide b is adjust by a constant N_{ab}. This adjustment is 
  in addition to other adjustments (e.g. transition / transversion or
  base frequencies).
.PP
aminof [0]
  Incorporate amino acid similarity parameters into substitution matrix,
  adjusting omega for a change between amino acid i and amino acid j.
  A_{ij} is a symmetric matrix of constants representing amino acid
  similarities.
  0: Constant omega for all amino acid changes
  1: omega_{ij} = omega^{A_{ij}}
  2: omega_{ij} = a_{ij} log(omega) / [ 1 \- exp(\-a_{ij} log(omega)) ]
  Option 1 has the same form as the original codon subsitution model 
  proposed by Goldman and Yang (but with potentially different 
  constants).
  Option 2 has a more population genetic derivtion, with omega being
  interpreted as the ratio of fixation probabilities.
.PP
nucfile [nuc.dat]
  If nucleof is non-zero, read nucleotide substitution constants from
  nucfile. If this file does not exist, hard coded constants are used.
.PP
aminofile [amino.dat]
  If aminof is non-zero, read amino acid similarity constants from
  aminofile. If this file does not exist, hard coded constants are used.
.PP
timemem [0]
  Print summary of real time and \s-1CPU\s0 time used. Will eventually print
  summary of memory use as well.
.PP
ldiff [3.841459]
  Twice log-likelihood difference used as a threshold for calculating 
  support (confidence) intervals for sitewise omega estimates. This 
  value should be the quantile from a chi-square distribution with one
  degree of freedom corresponding to the support required. 
  E.g. qchisq(0.95,1) = 3.841459
     0.4549364 = 50% support
     1.323304  = 75% support
     2.705543  = 90% support
     3.841459  = 95% support
     6.634897  = 99% support
     7.879439  = 99.5% support
    10.82757   = 99.9% support
.PP
paramin []
  If not blank, read in parameters from file given by the argument.
.PP
paramout []
  If not blank, write out parameter estimates to file given.
.PP
skipsitewise [0]
  Skip sitewise estimation of omega. Depending on other options given, 
  either calculate maximum likelihood or likelihood fixed at parameter
  values given.
.PP
seed [0]
  Seed for random number generator. If seed is 0, then previously 
  produced seed file (~/.rng64) is used. If this does not exist, the
  random number generator is initialised using the clock.
.PP
saveseed [1]
  If non-zero, save finial seed in file (~/.rng64) to be used as initial
  seed in future runs of program.
.SS "Results Format"
.IX Subsection "Results Format"
Results file (default: slr.res)
\&\-\-\-\-\-\-\-\-\-\-\-\-
Results are presented in nine columns
.PP
Site
  Number of sites in alignment
.PP
Neutral
  (minus) Log-probability of observing site given that it was 
  evolving neutrally (omega=1)
.PP
Optimal
  (minus) Log-probability of observing site given that it was 
  evolving at the optimal value of omega.
.PP
Omega
  The value of omega which maximizes the log-probability of observing
.PP
LRT_Stat
  Log-likelihood ratio statistic for non-neutral selection (or
  positive selection if the positive_only option is set to 1).
  LRT_Stat = 2 * (Neutral-Optimal)
.PP
Pval
  P\-value for non-neutral (or positive) selection at a site,
  unadjusted for multiple comparisons.
.PP
Adj. Pval 
  P\-value for non-neutral (or positive) selection at a site, after
  adjusting for multiple comparisons using the Hochberg procedure 
  (see the file \*(L"MultipleComparisons.txt\*(R" in the doc directory).
.PP
Result
  A simple visual guide to the result. Sites detected as having been
  under positive selection are marked with a '+', sites under 
  purifying selection are marked with '\-'. The number of symbols
    Number symbols      Threshold
          1             95%
          2             99%
          3             95% after adjustment
          4             99% after adjustment
.PP
.Vb 4
\&  Occasionally the result may also contain an exclamation mark. This
\&  indicates that the observation at a site is not significantly
\&  different from random (equivalent to infinitely strong positive
\&  selection). This may indicate that the alignment at that site is bad
.Ve
.PP
Note
.PP
.Vb 7
\&  The following events are flagged:
\&  Synonymous            All codons at a site code for the same amino 
\&                        acid.
\&  Single character      Only one sequence at the site is ungapped,
\&                        the result of a recent insertion for example.
\&  All gaps              All sequences at a site contain a gap
\&                        character.
\&
\&  Sites marked "Single character" or "All gaps" are not counted
\&  towards the number of sites for the purposes of correcting for
\&  multiple comparisons since it is not possible to detect selection
\&  from none or one observation under the assumptions made by the
\&  sitewise likelihood ratio test.
.Ve
.SS "program_name"
.IX Subsection "program_name"
.Vb 5
\& Title   : program_name
\& Usage   : $factory\->program_name()
\& Function: holds the program name
\& Returns:  string
\& Args    : None
.Ve
.SS "program_dir"
.IX Subsection "program_dir"
.Vb 5
\& Title   : program_dir
\& Usage   : \->program_dir()
\& Function: returns the program directory, obtained from ENV variable.
\& Returns:  string
\& Args    :
.Ve
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : my $obj = Bio::Tools::Run::Phylo::SLR\->new();
\& Function: Builds a new Bio::Tools::Run::Phylo::SLR object 
\& Returns : Bio::Tools::Run::Phylo::SLR
\& Args    : \-alignment => the Bio::Align::AlignI object
\&           \-save_tempfiles => boolean to save the generated tempfiles and
\&                              NOT cleanup after onesself (default FALSE)
\&           \-tree => the Bio::Tree::TreeI object
\&           \-params => a hashref of SLR parameters (all passed to set_parameter)
\&           \-executable => where the SLR executable resides
.Ve
.PP
See also: Bio::Tree::TreeI, Bio::Align::AlignI
.SS "prepare"
.IX Subsection "prepare"
.Vb 7
\& Title   : prepare
\& Usage   : my $rundir = $slr\->prepare($aln);
\& Function: prepare the SLR analysis using the default or updated parameters
\&           the alignment parameter must have been set
\& Returns : value of rundir
\& Args    : L<Bio::Align::AlignI> object,
\&           L<Bio::Tree::TreeI> object
.Ve
.SS "run"
.IX Subsection "run"
.Vb 7
\& Title   : run
\& Usage   : my ($rc,$parser) = $slr\->run($aln,$tree);
\& Function: run the SLR analysis using the default or updated parameters
\&           the alignment parameter must have been set
\& Returns : Return code, L<Bio::Tools::Phylo::SLR>
\& Args    : L<Bio::Align::AlignI> object,
\&           L<Bio::Tree::TreeI> object
.Ve
.SS "error_string"
.IX Subsection "error_string"
.Vb 5
\& Title   : error_string
\& Usage   : $obj\->error_string($newval)
\& Function: Where the output from the last analysus run is stored.
\& Returns : value of error_string
\& Args    : newvalue (optional)
.Ve
.SS "alignment"
.IX Subsection "alignment"
.Vb 8
\& Title   : alignment
\& Usage   : $slr\->align($aln);
\& Function: Get/Set the L<Bio::Align::AlignI> object
\& Returns : L<Bio::Align::AlignI> object
\& Args    : [optional] L<Bio::Align::AlignI>
\& Comment : We could potentially add support for running directly on a file
\&           but we shall keep it simple
\& See also: L<Bio::SimpleAlign>
.Ve
.SS "tree"
.IX Subsection "tree"
.Vb 5
\& Title   : tree
\& Usage   : $slr\->tree($tree, %params);
\& Function: Get/Set the L<Bio::Tree::TreeI> object
\& Returns : L<Bio::Tree::TreeI> 
\& Args    : [optional] $tree => L<Bio::Tree::TreeI>,
\&
\& Comment : We could potentially add support for running directly on a file
\&           but we shall keep it simple
\& See also: L<Bio::Tree::Tree>
.Ve
.SS "get_parameters"
.IX Subsection "get_parameters"
.Vb 5
\& Title   : get_parameters
\& Usage   : my %params = $self\->get_parameters();
\& Function: returns the list of parameters as a hash
\& Returns : associative array keyed on parameter names
\& Args    : none
.Ve
.SS "set_parameter"
.IX Subsection "set_parameter"
.Vb 11
\& Title   : set_parameter
\& Usage   : $slr\->set_parameter($param,$val);
\& Function: Sets a SLR parameter, will be validated against
\&           the valid values as set in the %VALIDVALUES class variable.  
\&           The checks can be ignored if one turns off param checks like this:
\&             $slr\->no_param_checks(1)
\& Returns : boolean if set was success, if verbose is set to \-1
\&           then no warning will be reported
\& Args    : $param => name of the parameter
\&           $value => value to set the parameter to
\& See also: L<no_param_checks()>
.Ve
.SS "set_default_parameters"
.IX Subsection "set_default_parameters"
.Vb 7
\& Title   : set_default_parameters
\& Usage   : $slr\->set_default_parameters(0);
\& Function: (Re)set the default parameters from the defaults
\&           (the first value in each array in the 
\&            %VALIDVALUES class variable)
\& Returns : none
\& Args    : boolean: keep existing parameter values
.Ve
.SH "Bio::Tools::Run::WrapperBase methods"
.IX Header "Bio::Tools::Run::WrapperBase methods"
.SS "no_param_checks"
.IX Subsection "no_param_checks"
.Vb 6
\& Title   : no_param_checks
\& Usage   : $obj\->no_param_checks($newval)
\& Function: Boolean flag as to whether or not we should
\&           trust the sanity checks for parameter values  
\& Returns : value of no_param_checks
\& Args    : newvalue (optional)
.Ve
.SS "save_tempfiles"
.IX Subsection "save_tempfiles"
.Vb 5
\& Title   : save_tempfiles
\& Usage   : $obj\->save_tempfiles($newval)
\& Function: 
\& Returns : value of save_tempfiles
\& Args    : newvalue (optional)
.Ve
.SS "outfile_name"
.IX Subsection "outfile_name"
.Vb 6
\& Title   : outfile_name
\& Usage   : my $outfile = $slr\->outfile_name();
\& Function: Get/Set the name of the output file for this run
\&           (if you wanted to do something special)
\& Returns : string
\& Args    : [optional] string to set value to
.Ve
.SS "tempdir"
.IX Subsection "tempdir"
.Vb 5
\& Title   : tempdir
\& Usage   : my $tmpdir = $self\->tempdir();
\& Function: Retrieve a temporary directory name (which is created)
\& Returns : string which is the name of the temporary directory
\& Args    : none
.Ve
.SS "cleanup"
.IX Subsection "cleanup"
.Vb 5
\& Title   : cleanup
\& Usage   : $slr\->cleanup();
\& Function: Will cleanup the tempdir directory after an SLR run
\& Returns : none
\& Args    : none
.Ve
.SS "io"
.IX Subsection "io"
.Vb 5
\& Title   : io
\& Usage   : $obj\->io($newval)
\& Function:  Gets a L<Bio::Root::IO> object
\& Returns : L<Bio::Root::IO>
\& Args    : none
.Ve
