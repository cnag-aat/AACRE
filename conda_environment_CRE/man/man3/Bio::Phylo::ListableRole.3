.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::ListableRole 3"
.TH Bio::Phylo::ListableRole 3 "2014-02-08" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Phylo::ListableRole \- Extra functionality for things that are lists
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& No direct usage, parent class. Methods documented here 
\& are available for all objects that inherit from it.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A listable object is an object that contains multiple smaller objects of the
same type. For example: a tree contains nodes, so it's a listable object.
.PP
This class contains methods that are useful for all listable objects: Matrices
(i.e. sets of matrix objects), individual Matrix objects, Datum objects (i.e.
character state sequences), Taxa, Forest, Tree and Node objects.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1ARRAY METHODS\s0"
.IX Subsection "ARRAY METHODS"
.IP "\fIprune_entities()\fR" 4
.IX Item "prune_entities()"
Prunes the container's contents specified by an array reference of indices.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : prune_entities
\& Usage   : $list\->prune_entities([9,7,7,6]);
\& Function: Prunes a subset of contents
\& Returns : A Bio::Phylo::Listable object.
\& Args    : An array reference of indices
.Ve
.IP "\fIget_index_of()\fR" 4
.IX Item "get_index_of()"
Returns the index of the argument in the list,
or undef if the list doesn't contain the argument
.Sp
.Vb 7
\& Type    : Accessor
\& Title   : get_index_of
\& Usage   : my $i = $listable\->get_index_of($obj)
\& Function: Returns the index of the argument in the list,
\&           or undef if the list doesn\*(Aqt contain the argument
\& Returns : An index or undef
\& Args    : A contained object
.Ve
.IP "\fIget_by_index()\fR" 4
.IX Item "get_by_index()"
Gets element at index from container.
.Sp
.Vb 10
\& Type    : Accessor
\& Title   : get_by_index
\& Usage   : my $contained_obj = $obj\->get_by_index($i);
\& Function: Retrieves the i\*(Aqth entity 
\&           from a listable object.
\& Returns : An entity stored by a listable 
\&           object (or array ref for slices).
\& Args    : An index or range. This works 
\&           the way you dereference any perl
\&           array including through slices, 
\&           i.e. $obj\->get_by_index(0 .. 10)>
\&           $obj\->get_by_index(0, \-1) 
\&           and so on.
\& Comments: Throws if out\-of\-bounds
.Ve
.IP "\fIget_by_regular_expression()\fR" 4
.IX Item "get_by_regular_expression()"
Gets elements that match regular expression from container.
.Sp
.Vb 10
\& Type    : Accessor
\& Title   : get_by_regular_expression
\& Usage   : my @objects = @{ 
\&               $obj\->get_by_regular_expression(
\&                    \-value => $method,
\&                    \-match => $re
\&            ) };
\& Function: Retrieves the data in the 
\&           current Bio::Phylo::Listable 
\&           object whose $method output 
\&           matches $re
\& Returns : A list of Bio::Phylo::* objects.
\& Args    : \-value => any of the string 
\&                     datum props (e.g. \*(Aqget_type\*(Aq)
\&           \-match => a compiled regular 
\&                     expression (e.g. qr/^[D|R]NA$/)
.Ve
.IP "\fIget_by_value()\fR" 4
.IX Item "get_by_value()"
Gets elements that meet numerical rule from container.
.Sp
.Vb 10
\& Type    : Accessor
\& Title   : get_by_value
\& Usage   : my @objects = @{ $obj\->get_by_value(
\&              \-value => $method,
\&              \-ge    => $number
\&           ) };
\& Function: Iterates through all objects 
\&           contained by $obj and returns 
\&           those for which the output of 
\&           $method (e.g. get_tree_length) 
\&           is less than (\-lt), less than 
\&           or equal to (\-le), equal to 
\&           (\-eq), greater than or equal to 
\&           (\-ge), or greater than (\-gt) $number.
\& Returns : A reference to an array of objects
\& Args    : \-value => any of the numerical 
\&                     obj data (e.g. tree length)
\&           \-lt    => less than
\&           \-le    => less than or equals
\&           \-eq    => equals
\&           \-ge    => greater than or equals
\&           \-gt    => greater than
.Ve
.IP "\fIget_by_name()\fR" 4
.IX Item "get_by_name()"
Gets first element that has argument name
.Sp
.Vb 8
\& Type    : Accessor
\& Title   : get_by_name
\& Usage   : my $found = $obj\->get_by_name(\*(Aqfoo\*(Aq);
\& Function: Retrieves the first contained object
\&           in the current Bio::Phylo::Listable 
\&           object whose name is \*(Aqfoo\*(Aq
\& Returns : A Bio::Phylo::* object.
\& Args    : A name (string)
.Ve
.SS "\s-1VISITOR METHODS\s0"
.IX Subsection "VISITOR METHODS"
.IP "\fIvisit()\fR" 4
.IX Item "visit()"
Iterates over objects contained by container, executes argument
code reference on each.
.Sp
.Vb 9
\& Type    : Visitor predicate
\& Title   : visit
\& Usage   : $obj\->visit( 
\&               sub{ print $_[0]\->get_name, "\en" } 
\&           );
\& Function: Implements visitor pattern 
\&           using code reference.
\& Returns : The container, possibly modified.
\& Args    : a CODE reference.
.Ve
.SS "\s-1TESTS\s0"
.IX Subsection "TESTS"
.IP "\fIcontains()\fR" 4
.IX Item "contains()"
Tests whether the container object contains the argument object.
.Sp
.Vb 9
\& Type    : Test
\& Title   : contains
\& Usage   : if ( $obj\->contains( $other_obj ) ) {
\&               # do something
\&           }
\& Function: Tests whether the container object 
\&           contains the argument object
\& Returns : BOOLEAN
\& Args    : A Bio::Phylo::* object
.Ve
.IP "\fIcan_contain()\fR" 4
.IX Item "can_contain()"
Tests if argument can be inserted in container.
.Sp
.Vb 6
\& Type    : Test
\& Title   : can_contain
\& Usage   : &do_something if $listable\->can_contain( $obj );
\& Function: Tests if $obj can be inserted in $listable
\& Returns : BOOL
\& Args    : An $obj to test
.Ve
.SS "\s-1UTILITY METHODS\s0"
.IX Subsection "UTILITY METHODS"
.IP "\fIcross_reference()\fR" 4
.IX Item "cross_reference()"
The cross_reference method links node and datum objects to the taxa they apply
to. After crossreferencing a matrix with a taxa object, every datum object has
a reference to a taxon object stored in its \f(CW\*(C`$datum\->get_taxon\*(C'\fR field, and
every taxon object has a list of references to datum objects stored in its
\&\f(CW\*(C`$taxon\->get_data\*(C'\fR field.
.Sp
.Vb 9
\& Type    : Generic method
\& Title   : cross_reference
\& Usage   : $obj\->cross_reference($taxa);
\& Function: Crossreferences the entities 
\&           in the container with names 
\&           in $taxa
\& Returns : string
\& Args    : A Bio::Phylo::Taxa object
\& Comments:
.Ve
.IP "\fIalphabetize()\fR" 4
.IX Item "alphabetize()"
Sorts the contents alphabetically by their name.
.Sp
.Vb 7
\& Type    : Generic method
\& Title   : alphabetize
\& Usage   : $obj\->alphabetize;
\& Function: Sorts the contents alphabetically by their name.
\& Returns : $self
\& Args    : None
\& Comments:
.Ve
.SS "\s-1SETS MANAGEMENT\s0"
.IX Subsection "SETS MANAGEMENT"
Many Bio::Phylo objects are segmented, i.e. they contain one or more subparts 
of the same type. For example, a matrix contains multiple rows; each row 
contains multiple cells; a tree contains nodes, and so on. (Segmented objects
all inherit from Bio::Phylo::Listable, i.e. the class whose documentation you're
reading here.) In many cases it is useful to be able to define subsets of the 
contents of segmented objects, for example sets of taxon objects inside a taxa 
block. The Bio::Phylo::Listable object allows this through a number of methods 
(add_set, remove_set, add_to_set, remove_from_set etc.). Those methods delegate 
the actual management of the set contents to the Bio::Phylo::Set object. 
Consult the documentation for Bio::Phylo::Set for a code sample.
.IP "\fIsets_to_xml()\fR" 4
.IX Item "sets_to_xml()"
Returns string representation of sets
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : sets_to_xml
\& Usage   : my $str = $obj\->sets_to_xml;
\& Function: Gets xml string
\& Returns : Scalar
\& Args    : None
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There is a mailing list at <https://groups.google.com/forum/#!forum/bio\-phylo> 
for any user or developer questions and discussions.
.PP
Also see the manual: Bio::Phylo::Manual and <http://rutgervos.blogspot.com>.
.SS "Objects inheriting from Bio::Phylo::Listable"
.IX Subsection "Objects inheriting from Bio::Phylo::Listable"
.IP "Bio::Phylo::Forest" 4
.IX Item "Bio::Phylo::Forest"
Iterate over a set of trees.
.IP "Bio::Phylo::Forest::Tree" 4
.IX Item "Bio::Phylo::Forest::Tree"
Iterate over nodes in a tree.
.IP "Bio::Phylo::Forest::Node" 4
.IX Item "Bio::Phylo::Forest::Node"
Iterate of children of a node.
.IP "Bio::Phylo::Matrices" 4
.IX Item "Bio::Phylo::Matrices"
Iterate over a set of matrices.
.IP "Bio::Phylo::Matrices::Matrix" 4
.IX Item "Bio::Phylo::Matrices::Matrix"
Iterate over the datum objects in a matrix.
.IP "Bio::Phylo::Matrices::Datum" 4
.IX Item "Bio::Phylo::Matrices::Datum"
Iterate over the characters in a datum.
.IP "Bio::Phylo::Taxa" 4
.IX Item "Bio::Phylo::Taxa"
Iterate over a set of taxa.
.SS "Superclasses"
.IX Subsection "Superclasses"
.IP "Bio::Phylo::NeXML::Writable" 4
.IX Item "Bio::Phylo::NeXML::Writable"
This object inherits from Bio::Phylo::NeXML::Writable, so methods
defined there are also applicable here.
.SH "CITATION"
.IX Header "CITATION"
If you use Bio::Phylo in published research, please cite it:
.PP
\&\fBRutger A Vos\fR, \fBJason Caravas\fR, \fBKlaas Hartmann\fR, \fBMark A Jensen\fR
and \fBChase Miller\fR, 2011. Bio::Phylo \- phyloinformatic analysis using Perl.
\&\fI\s-1BMC\s0 Bioinformatics\fR \fB12\fR:63.
<http://dx.doi.org/10.1186/1471\-2105\-12\-63>
