.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::Manual 3"
.TH Bio::Phylo::Manual 3 "2014-02-08" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Phylo::Manual \- High\-level user guide
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This is the manual for Bio::Phylo. Bio::Phylo is a perl5 package for
phylogenetic analysis. The stable \s-1URL\s0 for the
most recent distribution is <http://search.cpan.org/dist/Bio\-Phylo/>.
.PP
This manual is intended for readers who know how to program 
in perl and understand commonly-encountered concepts in phylogenetics. 
What is offered in this document is an overview of Bio::Phylo's
functionality, not a tutorial or a reference of all functions.
.PP
For exhaustive \s-1API\s0 documentation, consult the embedded perlpod in
the classes of this release, for example by issuing \f(CW\*(C`perldoc Bio::Phylo::IO\*(C'\fR
(or some other class name) in a terminal window.
.PP
Note that Bio::Phylo uses inheritance to a great extent,
such that any one object may inherit additional methods from a number
of superclasses. In such cases, this will be noted in the \*(L"\s-1SEE ALSO\*(R"\s0
section at the bottom of that class's documentation. The Bio::Phylo documentation
system rewards the methodical reader who follows these document links.
.PP
For installation instructions, read the \s-1README\s0 file in the root directory 
of the distribution.
.SH "INSTANT GRATIFICATION"
.IX Header "INSTANT GRATIFICATION"
The following sections will demonstrate some of the basic functionality,
with immediate, useful results.
.SS "One-liners"
.IX Subsection "One-liners"
One-liners are perl statements that are executed directly on the command
line, using the \f(CW\*(C`\-e \*(Aq...statements...\*(Aq\*(C'\fR argument.
Often, you'll include the \f(CW\*(C`\-MFoo::Bar\*(C'\fR switch to include module
\&\f(CW\*(C`Foo::Bar\*(C'\fR at runtime. (See perlrun for more info on executing
the interpreter.) \fB\s-1NOTE FOR WINDOWS USERS\s0\fR: in the following examples,
switch the quotes around, i.e. use double quotes where single quotes are
used and vice versa.
.IP "\fBFirst steps\fR" 4
.IX Item "First steps"
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
No concept is valid in Perl if it cannot be expressed in a one-liner.
For the Bio::Phylo package, some operations can be performed using
a single expression from the command line. Here are some examples.
.IP "Solution 1: downloading and converting Tree of Life data" 4
.IX Item "Solution 1: downloading and converting Tree of Life data"
.Vb 1
\& perl \-MBio::Phylo::IO=parse \-e \*(Aqprint parse\->to_nexus\*(Aq format tolweb as_project 1 url $URL
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
Assuming that the environment variable \f(CW$URL\fR has been set to point to 
a node in the \s-1XML\s0 web service of the Tree of Life (<http://tolweb.org>),
this command will download the output, parse it, and print the parsed output
as nexus. As an example, using this url:
.Sp
.Vb 1
\& http://tolweb.org/onlinecontributors/app?service=external&page=xml/TreeStructureService&node_id=133799
.Ve
.Sp
Something like the following output would be produced:
.Sp
.Vb 10
\& #NEXUS
\& BEGIN TAXA;
\& [! Taxa block written by Bio::Phylo::Taxa 0.31_1520 on Thu Nov 25 20:49:54 2010 ]      
\&         DIMENSIONS NTAX=3;
\&         TAXLABELS
\&                        \*(AqBembidion alaskense\*(Aq
\&                        \*(AqBembidion argenteolum\*(Aq
\&                        \*(AqBembidion semenovi\*(Aq
\&                 ;
\& END;
\& BEGIN TREES;
\& [! Trees block written by Bio::Phylo::Forest 0.31_1520 on Thu Nov 25 20:49:54 2010 ]
\&        TRANSLATE
\&                1 \*(AqBembidion alaskense\*(Aq,
\&                2 \*(AqBembidion argenteolum\*(Aq,
\&                3 \*(AqBembidion semenovi\*(Aq;
\&        TREE Tree2 = [&R] (((2,3),1));
\& END;
.Ve
.Sp
So what is happening here? Firstly, we provide the \f(CW\*(C`\-MBio::Phylo::IO\*(C'\fR switch,
to which we add \f(CW\*(C`=parse\*(C'\fR, which means we import the \f(CW\*(C`parse\*(C'\fR function from
Bio::Phylo::IO. This function is supplied with named arguments, which can
also be provided on the command line, i.e. as part of the \f(CW@ARGV\fR array.
.Sp
Secondly, we use the \f(CW\*(C`\-e\*(C'\fR 'print parse\->to_nexus' switch. Here we till perl
to execute the parse function, transform its return value to nexus, and print
that to \s-1STDOUT.\s0
.Sp
Following that, we provide the named command line arguments. \f(CW\*(C`format tolweb\*(C'\fR
specifies that the input for the parse function is in the Tree of Life \s-1XML\s0
format. \f(CW\*(C`as_project 1\*(C'\fR specifies that the parse function should return its
contents as a newly created Bio::Phylo::Project object. \f(CW\*(C`url $URL\*(C'\fR 
specifies the data source to parse; in this case the data source lives at 
\&\f(CW$URL\fR. Other possible options for a data source are \f(CW\*(C`file\*(C'\fR with a file name, 
\&\f(CW\*(C`string\*(C'\fR with a string of phylogenetic data in some recognized format, or 
\&\f(CW\*(C`handle\*(C'\fR with an open file handle.
.Sp
(This example requires the otherwise optional modules LWP::UserAgent
and XML::Twig to be installed on your system.)
.IP "Solution 2: calculating tree balance" 4
.IX Item "Solution 2: calculating tree balance"
.Vb 2
\& perl \-MBio::Phylo::IO=parse \-e \*(Aqprint \e
\& parse(\-format=>"newick",\-string=>"((A,B),C);")\->first\->calc_imbalance\*(Aq
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
The \f(CW\*(C`\-MModule\*(C'\fR switch is the equivalent of using 
\&\f(CW\*(C`use Module;\*(C'\fR in a script. Here we use the Bio::Phylo::IO module, which
is Bio::Phylo's entry point into file parsing and file writing.
.Sp
The \f(CW\*(C`\-e\*(C'\fR switch is used to evaluate the subsequent expression. We parse a 
string, \f(CW\*(C`((A,B),C);\*(C'\fR, of format \f(CW\*(C`newick\*(C'\fR. The parser returns a 
Bio::Phylo::Forest object (i.e. a set of trees, in this case a set of 
one). From this set we retrieve the first (and only) tree, and calculate 
Colless' imbalance, which returns a number, which we print to standard out.
.Sp
This would print \*(L"1\*(R", because the tree is a ladder, and therefore completely
unbalanced. Note how this example uses the standard interface for 
Bio::Phylo::IO as you would normally use it in code you write in a script
or a module. As the arguments to the \f(CW\*(C`parse\*(C'\fR function can also be supplied in 
\&\f(CW@ARGV\fR (useful for one-liners or other processes that launch 
shell commands) the example can be rewritten as:
.Sp
.Vb 2
\& perl \-MBio::Phylo::IO=parse \-e \*(Aqprint parse()\->first\->calc_imbalance\*(Aq \e
\& format newick string "((A,B),C);"
.Ve
.Sp
In this alternative invocation, note how the arguments to the parse call are
now outside of the '...command...' quotes, making them \*(L"shell words\*(R",
which for various reasons may not be preceded by dashes.
.IP "\fBSets of trees\fR" 4
.IX Item "Sets of trees"
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
You want a one-liner to iterate over a set of trees:
.IP "Solution" 4
.IX Item "Solution"
.Vb 2
\& perl \-MBio::Phylo::IO=parse \-lne \*(Aqprint \e
\& parse(\-format=>"newick",\-string=>$_)\->first\->calc_i2\*(Aq <file>
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
The \f(CW\*(C`\-n\*(C'\fR switch wraps a \*(L"while(<>) { ... }\*(R" around the
program, so the trees from \fIfile\fR (that is, if they are one newick
tree description per line) are copied into \f(CW$_\fR one tree at a
time. The \f(CW\*(C`\-l\*(C'\fR switch appends a line break to the printed output.
.IP "\fBStringifying trees\fR" 4
.IX Item "Stringifying trees"
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
You don't want a number printed to \f(CW\*(C`STDOUT\*(C'\fR, you want a tree:
.IP "Solution" 4
.IX Item "Solution"
.Vb 2
\& perl \-MBio::Phylo::IO=parse \-e \*(Aqprint \e
\& parse(\-format=>"newick",\-string=>"((A,B),C);")\->first\->to_newick\*(Aq
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
If you try to print a tree object, what's written is something like
\&\f(CW\*(C`Bio::Phylo::Forest::Tree=SCALAR(0x1a337dc)\*(C'\fR (that is, the 
memory address of the object reference). This is probably not 
what you want, so the tree object has a \f(CW\*(C`to_newick\*(C'\fR 
method that stringifies the tree to a newick string. Likewise, matrices,
taxa and tree blocks can write a \s-1NEXUS\s0 block using \f(CW\*(C`to_nexus\*(C'\fR,
and all of them can also be written to NeXML (<http://www.nexml.org>) using
\&\f(CW\*(C`to_xml\*(C'\fR and to a \s-1JSON\s0 mapping thereof using \f(CW\*(C`to_json\*(C'\fR.
.SS "Input and output"
.IX Subsection "Input and output"
The Bio::Phylo::IO module is the unified front end for parsing and
unparsing phylogenetic data objects. It is a non-OO module that optionally
exports the \f(CW\*(C`parse\*(C'\fR and \f(CW\*(C`unparse\*(C'\fR subroutines into the caller's
namespace, using the \f(CW\*(C`use Bio::Phylo::IO qw(parse unparse);\*(C'\fR directive.
Alternatively, you can call the subroutines as class methods. The \f(CW\*(C`parse\*(C'\fR
and \f(CW\*(C`unparse\*(C'\fR subroutines load and dispatch the appropriate sub-modules
at runtime, depending on the \f(CW\*(C`\-format\*(C'\fR argument.
.IP "\fBParsing trees\fR" 4
.IX Item "Parsing trees"
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
You want to create a Bio::Phylo::Forest::Tree object from a newick string.
.IP "Solution" 4
.IX Item "Solution"
.Vb 1
\& use Bio::Phylo::IO;
\&
\& # get a newick string from some source
\& my $tree_string = \*(Aq(((A,B),C),D);\*(Aq;
\&
\& # Call class method parse from Bio::Phylo::IO
\& my $tree = Bio::Phylo::IO\->parse(
\&    \-string => $tree_string,
\&    \-format => \*(Aqnewick\*(Aq
\& )\->first;
\&
\& # note: newick parser returns \*(AqBio::Phylo::Forest\*(Aq
\& # Call \->first to retrieve the first tree of the forest.
\&
\& print ref $tree, "\en"; # prints \*(AqBio::Phylo::Forest::Tree\*(Aq
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
The Bio::Phylo::IO module invokes format specific parser and unparser modules. 
It is Bio::Phylo's front door for data input and output from files, raw strings 
and file handles.
.Sp
In the solution the \s-1IO\s0 module calls the Bio::Phylo::Parsers::Newick parser
which turns a tree description into a Bio::Phylo::Forest object. (Several other 
parser and unparser modules live in the Bio::Phylo::Parsers::* and 
Bio::Phylo::Unparsers::* namespaces, respectively.)
.Sp
The returned forest object subclasses Bio::Phylo::Listable, as a forest models 
a list of trees that you can iterate over. By calling the \f(CW\*(C`\-\*(C'\fRfirst> method, we 
get the first tree in the forest \- a Bio::Phylo::Forest::Tree object (in the 
example it's a very small forest, consisting of just this single tree).
.IP "\fBParsing tables\fR" 4
.IX Item "Parsing tables"
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
You want to create a Bio::Phylo::Matrices::Matrix object from a string.
.IP "Solution" 4
.IX Item "Solution"
.Vb 1
\& use Bio::Phylo::IO;
\&
\& # parsing a table
\& my $table_string = qq(A,1,2|B,1,2|C,2,2|D,2,1);
\& my $matrix = Bio::Phylo::IO\->parse(
\&    \-string   => $table_string,
\&    \-format   => \*(Aqtable\*(Aq,     # See Bio::Phylo::Parsers::Table
\&    \-type     => \*(AqSTANDARD\*(Aq,  # Data type
\&    \-fieldsep => \*(Aq,\*(Aq,         # field separator
\&    \-linesep  => \*(Aq|\*(Aq          # line separator
\& );
\&
\& print ref $matrix, "\en"; # prints \*(AqBio::Phylo::Matrices::Matrix\*(Aq
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
Here the Bio::Phylo::Parsers::Table module parses a string
\&\f(CW\*(C`A,1,2|B,1,2|C,2,2|D,2,1\*(C'\fR, where the \f(CW\*(C`|\*(C'\fR is considered a record or
line separator, and the \f(CW\*(C`,\*(C'\fR as a field separator. The default field and
line separators are the tabstop character \*(L"\et\*(R" and the line break \*(L"\en\*(R".
.IP "\fBParsing taxa\fR" 4
.IX Item "Parsing taxa"
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
You want to create a Bio::Phylo::Taxa object from a string.
.IP "Solution" 4
.IX Item "Solution"
.Vb 1
\& use Bio::Phylo::IO;
\&
\& # parsing a list of taxa
\& my $taxa_string = \*(AqA:B:C:D\*(Aq;
\& my $taxa = Bio::Phylo::IO\->parse(
\&    \-string   => $taxa_string,
\&    \-format   => \*(Aqtaxlist\*(Aq,
\&    \-fieldsep => \*(Aq:\*(Aq
\& );
\&
\& print ref $taxa, "\en"; # prints \*(AqBio::Phylo::Taxa\*(Aq
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
Here the Bio::Phylo::Parsers::Taxlist module parses a string \f(CW\*(C`A:B:C:D\*(C'\fR,
where the \f(CW\*(C`:\*(C'\fR is considered a field separator. The parser returns a
Bio::Phylo::Taxa object. Note that the same result can be obtained by building 
the taxa object from scratch (a more feasible proposition than building trees
or matrices from scratch):
.Sp
.Vb 1
\& use Bio::Phylo::Factory; 
\& 
\& # first instantiate the factory...
\& my $factory = Bio::Phylo::Factory\->new;
\& 
\& # ...then use it to create other objects, such as taxa blocks
\& my $taxa = $factory\->create_taxa( \-name => \*(AqMyTaxa\*(Aq );
\& 
\& # or taxa, (with names A, B, C and D), and add them to the taxa block
\& $taxa\->insert( $factory\->create_taxon( \-name => $_ ) ) for qw(A B C D);
\& 
\& # and write out as a nexus block
\& print $taxa\->to_nexus( \-header => 1, \-links => 1 );
.Ve
.Sp
This example uses the Bio::Phylo::Factory, which is an object that can
create other objects. Here we have it create a Bio::Phylo::Taxa block,
which we populate with four Bio::Phylo::Taxa::Taxon objects. We then
write out the taxa block as nexus, complete with the #NEXUS header (this
is optional so that we can combine multiple blocks in the same file), and
a title, using the \f(CW\*(C`\-links\*(C'\fR switch. The latter is a facility that only 
seems to be used by Mesquite (<http://mesquiteproject.org>) and Bio::Phylo.
It adds a \*(L"title\*(R" to the taxa block in the nexus output, and other blocks
(character state matrices and tree blocks) refer to this using a \*(L"links\*(R"
statement.  This is useful if you want to have multiple taxa blocks in the
same file and you want to distinguish them. Putting this all together, the
output is thus:
.Sp
.Vb 12
\& #NEXUS
\& BEGIN TAXA;
\& [! Taxa block written by Bio::Phylo::Taxa 0.31_1520 on Thu Nov 25 21:31:58 2010 ]
\&        TITLE MyTaxa;
\&         DIMENSIONS NTAX=4;
\&         TAXLABELS
\&                        A
\&                        B
\&                        C
\&                        D
\&         ;
\& END;
.Ve
.SS "Iterating"
.IX Subsection "Iterating"
The Bio::Phylo::Listable module is the superclass of all container objects.
Container objects are objects that contain a set of objects of the same type.
For example, a Bio::Phylo::Forest::Tree object is a container for
Bio::Phylo::Forest::Node objects. Hence, the Bio::Phylo::Forest::Tree
inherits from the Bio::Phylo::Listable class. You can therefore iterate over
the nodes in a tree using the methods defined by Bio::Phylo::Listable.
.IP "\fBIterating over trees and nodes.\fR" 4
.IX Item "Iterating over trees and nodes."
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
You want to access trees and nodes contained in a Bio::Phylo::Forest
object.
.IP "Solution" 4
.IX Item "Solution"
.Vb 1
\&  use Bio::Phylo::IO qw(parse);
\&
\&  my $string = \*(Aq((A,B),(C,D));(((A,B),C)D);\*(Aq;
\&  my $forest = parse( \-format => \*(Aqnewick\*(Aq, \-string => $string );
\&
\&  print ref $forest; # prints \*(AqBio::Phylo::Forest\*(Aq
\&
\&  # access trees in $forest
\&  foreach my $tree ( @{ $forest\->get_entities } ) {
\&      print ref $tree; # prints \*(AqBio::Phylo::Forest::Tree\*(Aq;
\&
\&      # access nodes in $tree
\&      foreach my $node ( @{ $tree\->get_entities } ) {
\&          print ref $node; # prints \*(AqBio::Phylo::Forest::Node\*(Aq;
\&
\&      }
\&  }
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
Bio::Phylo::Forest and Bio::Phylo::Forest::Tree are
nested subclasses of the iterator class Bio::Phylo::Listable. Nested
iterator calls (such as \f(CW\*(C`\-\*(C'\fRget_entities>) can be invoked on the
objects.
.IP "\fBIterating over taxa.\fR" 4
.IX Item "Iterating over taxa."
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
You want to access the individual taxa in a Bio::Phylo::Taxa object.
.IP "Solution" 4
.IX Item "Solution"
.Vb 1
\& use Bio::Phylo::IO qw(parse);
\&
\& my $string = \*(AqA|B|C|D|E|F|G|H\*(Aq;
\& my $taxa = parse(
\&     \-string   => $string,
\&     \-format   => \*(Aqtaxlist\*(Aq,
\&     \-fieldsep => \*(Aq|\*(Aq
\& );
\& print ref $taxa; # prints \*(AqBio::Phylo::Taxa\*(Aq;
\&
\& while ( my $taxon = $taxa\->next ) {
\&     print ref $taxon; # prints \*(AqBio::Phylo::Taxa::Taxon\*(Aq
\& }
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
A Bio::Phylo::Taxa object is a subclass of the
Bio::Phylo::Listable class. Hence, you could also call 
\&\f(CW\*(C`\-\*(C'\fRget_entities> on the taxa object, which returns a 
reference to an array of taxon objects contained by the 
taxa object. Note however the shorthand:
.Sp
.Vb 1
\& while ( my $taxon = $taxa\->next ) { ... }
.Ve
.IP "\fBIterating over datum objects.\fR" 4
.IX Item "Iterating over datum objects."
.PD 0
.IP "Problem" 4
.IX Item "Problem"
.PD
You want to access the datum objects contained by
a Bio::Phylo::Matrices::Matrix object.
.IP "Solution" 4
.IX Item "Solution"
.Vb 1
\& use Bio::Phylo::IO;
\&
\& # parsing a table
\& my $table_string = qq(A,1,2|B,1,2|C,2,2|D,2,1);
\& my $matrix = Bio::Phylo::IO\->parse(
\&    \-string   => $table_string,
\&    \-format   => \*(Aqtable\*(Aq,     # See Bio::Phylo::Parsers::Table
\&    \-type     => \*(AqSTANDARD\*(Aq,  # Data type
\&    \-fieldsep => \*(Aq,\*(Aq,         # field separator
\&    \-linesep  => \*(Aq|\*(Aq          # line separator
\& );
\&
\& print ref $matrix, "\en"; # prints \*(AqBio::Phylo::Matrices::Matrix\*(Aq
\&
\& my $datum = $matrix\->get_by_index( 0, \-1 );
\& print ref $datum; # NOTE: prints \*(AqARRAY\*(Aq!
.Ve
.IP "Discussion" 4
.IX Item "Discussion"
The Bio::Phylo::Matrices::Matrix object subclasses the
Bio::Phylo::Listable object. Hence, its iterator methods are applicable
here as well. In the above example, the get_by_index method is used. With
a single argument it returns a Bio::Phylo object. With multiple arguments
the semantics are nearly identical to array slicing (see perldata), 
except that an array \fIreference\fR is returned. Bio::Phylo generally passes
lists by reference (see perlref).
.SS "Simulating trees"
.IX Subsection "Simulating trees"
The Bio::Phylo::Generator module simulates trees under various
models of clade growth.
.IP "\fBGenerating Yule trees.\fR" 4
.IX Item "Generating Yule trees."
Here's how to generate a forest of ten trees with ten tips:
.Sp
.Vb 8
\&  use Bio::Phylo::Generator;
\&  my $gen = Bio::Phylo::Generator\->new;
\&  my $trees = $gen\->gen_rand_pure_birth(
\&      \-trees => 10,
\&      \-tips  => 10,
\&      \-model => \*(Aqyule\*(Aq
\&  );
\&  print ref $trees; # prints \*(AqBio::Phylo::Forest\*(Aq
.Ve
.IP "\fBExpected versus randomly drawn waiting times.\fR" 4
.IX Item "Expected versus randomly drawn waiting times."
The generator object simulates trees under the Yule or the Hey model,
returning. The \f(CW\*(C`gen_rand_pure_birth\*(C'\fR method call returns branch lengths
drawn from the appropriate distribution, while \f(CW\*(C`gen_exp_pure_birth\*(C'\fR
returns the expected waiting times (e.g. 1/n where n=number of lineages for
the Yule model).
.SS "Filtering"
.IX Subsection "Filtering"
.IP "\fBFiltering objects by numerical value.\fR" 4
.IX Item "Filtering objects by numerical value."
To retrieve, for example, the nodes from a tree that are close to the
root, call:
.Sp
.Vb 4
\& my @deep_nodes = @{ $tree\->get_by_value(
\&    \-value => \*(Aqcalc_nodes_to_root\*(Aq,
\&    \-le    => 2
\& ) };
.Ve
.Sp
Which retrieves the nodes no more than 2 ancestors away from the root.
Any method that returns a numerical value can be specified with the
\&\f(CW\*(C`\-value\*(C'\fR flag. The \f(CW\*(C`\-le\*(C'\fR flag specifies that the returned
value is \fIl\fRess\-than\-or\-\fIe\fRqual to 2.
.IP "\fBFiltering objects by regular expression.\fR" 4
.IX Item "Filtering objects by regular expression."
String values that are returned by objects can be filtered using a
compiled regular expression. For example:
.Sp
.Vb 4
\& my @lemurs = @{ $tree\->get_by_regular_expression(
\&      \-value => \*(Aqget_name\*(Aq,
\&      \-match => qr/[Ll]emur_.+$/
\& ) };
.Ve
.Sp
Retrieves all nodes whose genus name matches Eulemur, Lemur or
Hapalemur.
.SS "Drawing trees"
.IX Subsection "Drawing trees"
You can create visualize tree objects using the
Bio::Phylo::Treedrawer module:
.PP
.Vb 2
\&  use Bio::Phylo::Treedrawers;
\&  use Bio::Phylo::IO;
\&
\&  my $treedrawer = Bio::Phylo::Treedrawers\->new(
\&     \-width  => 400,
\&     \-height => 600,
\&     \-shape  => \*(AqCURVY\*(Aq,
\&     \-mode   => \*(AqCLADO\*(Aq,
\&     \-format => \*(AqSVG\*(Aq
\&  );
\&
\&  my $tree = Bio::Phylo::IO\->parse(
\&     \-format => \*(Aqnewick\*(Aq,
\&     \-string => \*(Aq((A,B),C);\*(Aq
\&  )\->first;
\&
\&  $treedrawer\->set_tree($tree);
\&  $treedrawer\->set_padding(50);
\&
\&  my $string = $treedrawer\->draw;
.Ve
.PP
Read the Bio::Phylo::Treedrawer perldoc for more info.
.SS "Tips and tricks"
.IX Subsection "Tips and tricks"
.IP "\fBGeneric metadata\fR" 4
.IX Item "Generic metadata"
You can append generic key/value pairs to any object, by calling
\&\f(CW$obj\fR\->set_generic( 'key' => 'value');. Subsequently calling
\&\f(CW$obj\fR\->get_generic('key'); returns 'value'. This is a very useful
feature in many situations where you may want to attach, for example,
results from analyses by outside programs (e.g. likelihood scores)
to the tree objects they refer to. Likewise, multiple numbers (e.g.
bootstrap values, posteriors, bremer values) can be attached to the
same node in this way.
.SH "OBJECT AND DATA MODEL"
.IX Header "OBJECT AND DATA MODEL"
.SS "Perl objects"
.IX Subsection "Perl objects"
Object-oriented perl is a massive subject. To learn about the
basic syntax of OO-perl, the following perldocs might be of interest:
.IP "perlboot" 4
.IX Item "perlboot"
Introduction to \s-1OO\s0 perl. Read at least this one if you have no
experience with \s-1OO\s0 perl.
.IP "perlobj" 4
.IX Item "perlobj"
Details about perl objects.
.IP "perltooc" 4
.IX Item "perltooc"
Class data.
.IP "perltoot" 4
.IX Item "perltoot"
Advanced objects: \*(L"Tom's object-oriented tutorial for perl\*(R"
.IP "perlbot" 4
.IX Item "perlbot"
The \*(L"Bag'o Object Tricks\*(R" (the \s-1BOT\s0).
.SS "The Bio::Phylo object model"
.IX Subsection "The Bio::Phylo object model"
The following sections discuss the nested objects that model
phylogenetic information and entities.
.IP "The Bio::Phylo root object." 4
.IX Item "The Bio::Phylo root object."
The Bio::Phylo object is never used directly. However, all
other objects inherit from it, which means that all objects
have getters and setters for their name, description, score.
They can all return a globally unique \s-1ID,\s0 log messages, and
keep track of more administrative things such as the version
number of the release.
.IP "The Bio::Phylo::Forest::* namespace" 4
.IX Item "The Bio::Phylo::Forest::* namespace"
According to Bio::Phylo, there is a Forest (which is
modelled by the Bio::Phylo::Forest object), which contains
Bio::Phylo::Forest::Tree objects, which contain
Bio::Phylo::Forest::Node objects.
.IP "The Bio::Phylo::Forest::Node object" 4
.IX Item "The Bio::Phylo::Forest::Node object"
A node 'knows' a couple
of things: its name, its branch length (i.e. the length
of the branch connecting it and its parent), who its
parent is, its next sister (on its right), its previous
sister (on the left), its first daughter and its last
daughter. Also, a taxon can be specified that the node
refers to (this makes most sense when the node is terminal).
These properties can be retrieved and modified by methods
classified as \s-1ACCESSORS\s0 and \s-1MUTATORS.\s0
.Sp
From this set of properties follows a number of
things which must be either true or false. For example,
if a node has no children it is a terminal node. By asking
a node whether it \*(L"is_terminal\*(R", it replies either with
true (i.e. 1) or false (undef). Methods such as this
are classified as \s-1TESTS.\s0
.Sp
Likewise, based on the properties of an individual
node we can perform a query to retrieve nodes related
to it. For example, by asking the node to
\&\*(L"get_ancestors\*(R" it returns a list of its ancestors,
being all the nodes and the path from its parent to,
and including, the root. These methods are \s-1QUERIES.\s0
.Sp
Lastly, some \s-1CALCULATIONS\s0 can be performed by the
node. By asking the node to \*(L"calc_path_to_root\*(R" it
calculates the sum of the lengths of the branches
connecting it and the root. Of course, in order to make
all this possible, a node has to exist, so it needs to
be constructed. The \s-1CONSTRUCTOR\s0 is the Bio::Phylo::Node\->\fInew()\fR
method.
.Sp
Once a node has served its purpose it
can be destroyed. For this purpose there is a
\&\s-1DESTRUCTOR,\s0 which cleans up once we're done with the
node. However, in most cases you don't have to worry
about constructing and destroying nodes as this is handled
by Bio::Phylo and perl for you.
.Sp
For a detailed description of all the node methods,
their arguments and return values, consult the node
documentation, which, after install, can be viewed by
issuing the \*(L"perldoc Bio::Phylo::Forest::Node\*(R" command.
.IP "The Bio::Phylo::Forest::Tree object" 4
.IX Item "The Bio::Phylo::Forest::Tree object"
A tree knows very
little. All it really holds is a set of nodes, which
are there because of \s-1TREE POPULATION,\s0 i.e. the process
of inserting nodes in the tree. The tree can be queried
in a number of ways, for example, we can ask the tree
to \*(L"get_entities\*(R", to which the tree replies with a list
of all the nodes it holds. Be advised that this doesn't
mean that the nodes are connected in a meaningful way,
if at all. The tree doesn't care, the nodes are
supposed to know who their parents, sisters, and
daughters are. But, we can still get, for example, all
the terminal nodes (i.e. the tips) in the tree by
retrieving all the nodes in the tree and asking each
one of them whether it \*(L"is_terminal\*(R", discarding the
ones that aren't.
.Sp
Based on the set of nodes the tree holds it can
perform calculations, such as \*(L"calc_tree_length\*(R", which
simply means that the tree iterates over all its nodes,
summing their branch lengths, and returning the total.
.Sp
The tree object also has a constructor and a
destructor, but normally you don't have to worry about
that. All the tree methods can be viewed by issuing the
\&\*(L"perldoc Bio::Phylo::Forest::Tree\*(R" command.
.IP "The Bio::Phylo::Forest object" 4
.IX Item "The Bio::Phylo::Forest object"
The object containing all others is the Forest object. It
serves merely as a container to hold multiple trees, which
are inserted in the Forest object using the \*(L"\fIinsert()\fR\*(R" method,
and retrieved using the \*(L"get_entities\*(R" method. More information
can be found in the Bio::Phylo::Forest perldoc page.
.IP "The Bio::Phylo::Matrices::* namespace" 4
.IX Item "The Bio::Phylo::Matrices::* namespace"
Objects in the Bio::Phylo::Matrices namespace are used to handle
comparative data, as single observations, and in larger container
objects.
.IP "The Bio::Phylo::Matrices::Datum object" 4
.IX Item "The Bio::Phylo::Matrices::Datum object"
The datum object holds observations of a predefined type,
such as molecular data, or continuous character states. The
Datum object can be linked to a taxon object, to specify which \s-1OTU\s0
the observation refers to.
.IP "The Bio::Phylo::Matrices::Matrix object" 4
.IX Item "The Bio::Phylo::Matrices::Matrix object"
The matrix object is used to aggregate datum objects into a larger,
iterator object, which can be accessed using the methods of the
Bio::Phylo::Listable class.
.IP "The Bio::Phylo::Matrices object" 4
.IX Item "The Bio::Phylo::Matrices object"
The top level opject in the Bio::Phylo::Matrices namespace is used
to contain multiple matrix or alignment objects, again implementing an
iterator interface.
.IP "The Bio::Phylo::Taxa::* namespace" 4
.IX Item "The Bio::Phylo::Taxa::* namespace"
Sets of taxa are modelled by the Bio::Phylo::Taxa object. It is
a container that holds Bio::Phylo::Taxa::Taxon objects. The taxon
objects at present provide no other functionality than to serve
as a means of crossreferencing nodes in trees, and datum or sequence
objects. This, however, is a very important feature. In order to 
be able to write, for example, files formatted for Mark Pagel's
Discrete, Continuous and Multistate programs a taxa object, a 
matrix and a tree object must be crossreferenced.
.IP "The Bio::Phylo::Taxa object" 4
.IX Item "The Bio::Phylo::Taxa object"
The taxa object is analogous to a taxa block as implemented by
Mesquite (<http://mesquiteproject.org>). Multiple matrix objects
and forests can be linked to a single taxa object, using 
\&\f(CW\*(C`$taxa\-\*(C'\fRset_matrix( \f(CW$matrix\fR )>. Conversely,
the relationship from matrix to taxa and from forest to taxa is a 
one-to-one relationship.
.IP "The Bio::Phylo::Taxa::Taxon object" 4
.IX Item "The Bio::Phylo::Taxa::Taxon object"
Just as forests can be linked to taxa objects, so too can 
indidividual node and datum objects be linked to individual taxon
objects. Again, the taxon can hold references to multiple nodes
or multiple datum objects, but conversely there is a one-to-one
relationship. There is a constraint on these relationships:
a node can only refer to a taxon that belongs to a taxa object
that the forest object that contains the node references:
.Sp
.Vb 10
\&       YES!
\&  _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_    
\& |FOREST        |  The taxon and node objects can
\& |  _\|_\|_\|_\|_\|_\|_\|_\|_\|_  |  link to each other, because
\& | |TREE      | |  their containers do also.
\& | |  _\|_\|_\|_\|_\|_  | |  
\& | | |NODE  | | |  
\& | | |_\|_\|_\|_\|_\|_| | |  
\& | |_\|_\|_\|_\|_^_\|_\|_\|_| |                 
\& |_\|_\|_\|_\|_\|_\|_|_\|_\|_\|_\|_\|_|              NO!       
\&      ^  |               _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_  
\&  _\|_\|_\|_|_\|_|_\|_            |FOREST \*(AqB\*(Aq    |  The taxon object 
\& |TAXA   |  |           |  _\|_\|_\|_\|_\|_\|_\|_\|_\|_  |  cannot reference
\& |  _\|_\|_\|_\|_|  |           | |TREE      | |  forest \*(AqA\*(Aq while
\& | |TAXON | |           | |  _\|_\|_\|_\|_\|_  | |  its container 
\& | |_\|_\|_\|_\|_\|_| |           | | |NODE  | | |  references forest
\& |_\|_\|_\|_\|_\|_\|_\|_\|_\|_|           | | |_\|_\|_\|_\|_\|_| | |  \*(AqB\*(Aq. 
\&                        | |_\|_\|_\|_\|_\|_\|_\|_\|_\|_| |  
\&                        |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|    _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_   
\&                             ^             |FOREST \*(AqA\*(Aq    |   
\&                         _\|_\|_\|_|_\|_\|_\|_\|_        |  _\|_\|_\|_\|_\|_\|_\|_\|_\|_  |  
\&                        |TAXA      |       | |TREE      | |  
\&                        |  _\|_\|_\|_\|_\|_  |       | |  _\|_\|_\|_\|_\|_  | |  
\&                        | |TAXON |\-\-\-\-\-\-\-\-\-\-\-\->|NODE  | | |  
\&                        | |_\|_\|_\|_\|_\|_| |       | | |_\|_\|_\|_\|_\|_| | |  
\&                        |_\|_\|_\|_\|_\|_\|_\|_\|_\|_|       | |_\|_\|_\|_\|_\|_\|_\|_\|_\|_| |  
\&                                           |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
.Ve
.Sp
Trying to set the links in the example on the right will result in
errors: \f(CW"Attempt to link X to taxon from wrong block"\fR. 
So what happens if a taxon already links to a node in forest 
\&'A', and you link its enclosing taxa block to forest 'B'? The 
links at the taxon and node level will be removed, and the 
link between forest and taxa object will be enforced, yielding 
the warning \f(CW"Reset X references from node objects to taxa 
outside taxa block"\fR.
.SS "Encapsulation"
.IX Subsection "Encapsulation"
Unlike most other implementations of tree structures (or any
other perl objects) the Bio::Phylo objects are truly encapsulated:
Most perl objects are hash references, so in most cases you can
do \f(CW\*(C`$obj\-\*(C'\fR{'key'} = 'value'>. Not so for Bio::Phylo. The objects
are implemented as 'InsideOut' objects. How they work exactly
is outside of the scope of this document, but the upshot as that
the state of an object can only be changed through its methods. 
This is a feature that helps keep the code base maintainable as
this project grows. Also, the way it is implemented is more 
memory-efficient and faster than the standard approach. The 
encapsulation forces users of this module to use the documented
interfaces of the objects. This, however, is a good thing: as long
as the interfaces stay the same, any code using Bio::Phylo will
continue to work, regardless of the implementation under the
surface.
.SS "'Is\-a' relationships: Inheritance"
.IX Subsection "'Is-a' relationships: Inheritance"
The objects in Bio::Phylo are related in various ways. Some objects
inherit from superclasses. Hence the object \fIis a\fR special
case of the superclass. This has important implications for the \s-1API:\s0
the documentation for each class only lists the methods defined locally
in that class, not the methods of the superclasses. Therefore, many
objects can do much more than would seem from their local \s-1POD.\s0 Always
inspect the \*(L"\s-1SEE ALSO\*(R"\s0 section of any class's documentation to see if
there are superclasses where more functionality might be defined.
.SS "'Has\-a' relationships"
.IX Subsection "'Has-a' relationships"
Some objects contain other objects. For example, a
Bio::Phylo::Forest::Tree contains Bio::Phylo::Forest::Node
objects, a matrix object holds datum objects, and so on.
The container objects all behave like Bio::Phylo::Listable
objects: you can iterate over them (also recursively).
The contains / container relationships implemented by
Bio::Phylo are shown below:
.SH "CONTAINERS"
.IX Header "CONTAINERS"
.Vb 9
\&      _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_     _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\&     |FOREST        |   |MATRICES        |
\&     |  _\|_\|_\|_\|_\|_\|_\|_\|_\|_  |   |  _\|_\|_\|_\|_\|_\|_\|_\|_\|_    |
\&     | |TREE      | |   | |MATRIX    |   |
\&     | |  _\|_\|_\|_\|_\|_  | |   | |  _\|_\|_\|_\|_\|_  |   |
\&     | | |NODE  | | |   | | |DATUM | |   |
\&     | | |_\|_\|_\|_\|_\|_| | |   | | |_\|_\|_\|_\|_\|_| |   |
\&     | |_\|_\|_\|_\|_\|_\|_\|_\|_\|_| |   | |_\|_\|_\|_\|_\|_\|_\|_\|_\|_|   |
\&     |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|   |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
\&                        
\&      _\|_\|_\|_\|_\|_\|_\|_\|_\|_        
\&     |TAXA      |      
\&     |  _\|_\|_\|_\|_\|_  |     
\&     | |TAXON | |     
\&     | |_\|_\|_\|_\|_\|_| |    
\&     |_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
.Ve
.SH "ARGUMENT FORMATS"
.IX Header "ARGUMENT FORMATS"
.SS "Named arguments when number of arguments >= 2."
.IX Subsection "Named arguments when number of arguments >= 2."
When the number of arguments to a method call exceeds 1, named
arguments are used. The order in which the arguments are specified
doesn't matter, but the arguments must be all lower case and preceded
by a dash:
.PP
.Vb 1
\&  use Bio::Phylo::Forest::Tree;
\&
\&  my $node = Bio::Phylo::Forest::Tree\->new(
\&      \-name  => \*(AqPHYLIP_1\*(Aq,
\&      \-score => 123,
\&  );
.Ve
.SS "Type checking"
.IX Subsection "Type checking"
Argument type is always checked. Numbers are checked for being
numbers, names are checked for being sane strings, without '():;,'.
Objects are checked for type. Internally, Bio::Phylo never checks
type based on class name, for example using
\&\f(CW\*(C`$obj\-\*(C'\fRisa('Some::Class')>. Instead, object identity is validated
using a system of constants defined in Bio::Phylo::Util::CONSTANT.
If Bio::Phylo needs to test validate object type, it'll do something
like:
.PP
.Vb 4
\& use Bio::Phylo::Util::CONSTANT qw(:objecttypes);
\& use Bio::Phylo::Forest::Node;
\& my $node = Bio::Phylo::Forest::Node\->new;
\& print "It\*(Aqs a node!" if $node\->_type == _NODE_;
.Ve
.PP
Hence, Bio::Phylo uses a form of \*(L"duck typing\*(R" (\*(L"if it walks like a
duck, and quacks like a duck, it probably is a duck\*(R"), as opposed
to one that is based on inheritance from a java-like interface, as
is the convention in bioperl. Both systems have their advantages and
drawbacks, but luckily they can coexist side by without problems.
.PP
As a new feature, a utility function is provided that does this type
checking for you, returning true or throwing an exception (see below),
so that the following will either succeed or die (so you might want
to put it inside an eval{} block):
.PP
.Vb 3
\& if ( looks_like_object( $node, _NODE_ ) ) {
\&      # do something
\& }
.Ve
.SS "Constructor arguments"
.IX Subsection "Constructor arguments"
All mutators (i.e. setters, methods called set_*) for a class and its
superclasses can be accessed from the constructor. E.g. because the
Bio::Phylo superclass of object Bio::Phylo::Forest::Node has a
\&\*(L"set_name\*(R" method, you can pass the following to the constructor:
.PP
.Vb 2
\& use Bio::Phylo::Forest::Node;
\& my $node = Bio::Phylo::Forest::Node\->new( \-name => "node1" );
.Ve
.PP
The arguments will be passed up the inheritance tree, and will 
eventually be turned into method calls by the root class.
.SH "RETURN VALUES AND EXCEPTIONS"
.IX Header "RETURN VALUES AND EXCEPTIONS"
.SS "Retun values"
.IX Subsection "Retun values"
Apart from scalar variables, all other return values are passed by
reference, either as a reference to an object or to an array.
.IP "Lists returned as array references" 4
.IX Item "Lists returned as array references"
Multiple return values are never returned as a list, always as an
array reference:
.Sp
.Vb 2
\& my $nodes = $tree\->get_entities;
\& print ref $nodes;
\&
\& #prints ARRAY.
.Ve
.Sp
To receive nodes in \f(CW@nodes\fR, dereference the returned array
reference (for clarity, all array dereferencing in this 
document is indicated by using braces in addition to this sigil):
.Sp
.Vb 1
\& my @nodes = @{ $tree\->get_entities };
.Ve
.IP "Returns self on mutators" 4
.IX Item "Returns self on mutators"
Mutator method calls always return the modified object, and so they
can be chained:
.Sp
.Vb 1
\& $node\->set_name(\*(AqHomo_sapiens\*(Aq)\->set_branch_length(0.2343);
.Ve
.IP "False but defined return values" 4
.IX Item "False but defined return values"
When a value requested through an Accessor hasn't been set, the return
value is \f(CW\*(C`undef\*(C'\fR. Here you should take care how you test. For example:
.Sp
.Vb 3
\& if ( ! $node\->get_parent ) {
\&        $root = $node;
\& }
.Ve
.Sp
This works as expected \- object references are always \*(L"true\*(R", so if
\&\f(CW\*(C`get_parent\*(C'\fR returns \*(L"false\*(R", \f(CW$node\fR has no parent \- hence it must 
be the root. However:
.Sp
.Vb 1
\& if ( ! $node\->get_branch_length ) {
\&
\&        # is there really no branch length?
\&        if ( defined $node\->get_branch_length ) {
\&
\&                # perhaps there is, but of length 0.
\&        }
\& }
.Ve
.Sp
\&...warrants caution. Zero is evaluated as false-but-defined.
.SS "Exceptions"
.IX Subsection "Exceptions"
The Bio::Phylo modules throw exceptions that subclass Exception::Class.
Exceptions are thrown when something \fIexceptional\fR has happened. Not when the
value requested through an accessor method is undefined. If a node has no
parent, \f(CW\*(C`undef\*(C'\fR is returned. Usually, you will encounter exceptions in
response to invalid input.
.IP "Trying/Catching exceptions" 4
.IX Item "Trying/Catching exceptions"
If some method call returns an exception, wrap the call inside an \f(CW\*(C`eval\*(C'\fR
block. The error now becomes non-fatal:
.Sp
.Vb 2
\& # try something:
\& eval { $node\->set_branch_length(\*(Aqa bad value\*(Aq); };
\&
\& # handle exception, if any
\& if ($@) {
\&    # do something, e.g.:
\&    print $@\->trace\->as_string; # <\- $@ is an object!
\& }
.Ve
.IP "Stack traces" 4
.IX Item "Stack traces"
If an exception of a particular type is caught, you can print a stack trace
and find out what might have gone wrong starting from your script drilling
into the module code.
.Sp
.Vb 2
\& # exception caught.
\& if ( UNIVERSAL::isa( $@, \*(AqBio::Phylo::Util::Exceptions::BadNumber\*(Aq ) ) {
\&
\&    # prints stack trace in addition to error
\&    warn $@\->error, "\en, $@\->trace\->as_string, "\en";
\&
\&    # further metadata from exception object
\&    warn join \*(Aq \*(Aq,  $@\->euid, $@\->egid, $@\->uid, $@\->gid, $@\->pid, $@\->time;
\&    exit;
\& }
.Ve
.Sp
As a new feature (from v.0.17 onwards) exceptions have become more descriptive,
with a generic explanation of what the thrown exception class typically means
added to the error message, and stack traces are printed out by default.
.IP "Exception types" 4
.IX Item "Exception types"
Several exception classes are defined. The type of the thrown exception should
give you a hint as to what might be wrong. The types are specified in the
Bio::Phylo::Util::Exceptions perldoc.
.SH "TO DO"
.IX Header "TO DO"
Below is a list of things that hopefully will be implemented in future 
versions of Bio::Phylo.
.IP "More \s-1DNA\s0 sequence methods" 4
.IX Item "More DNA sequence methods"
Such as \f(CW$seq\fR\->complement;. This would imply larger constant translation 
tables, including various tables for mtDNA and so on. Will probably be 
implemented, must likely using BioPerl tools.
.IP "Databases" 4
.IX Item "Databases"
Implement/improve access to TreeBASE, TolWeb and other databases. This could
probably be done best using PhyloWS.
.IP "Tests" 4
.IX Item "Tests"
Test coverage is reasonable, but some of the newer features need to be exercised
more.
.IP "Interoperability with BioPerl" 4
.IX Item "Interoperability with BioPerl"
The eventual aim of the Bio::Phylo project is to glue together the phylogenetics 
aspects of BioPerl (<http://www.bioperl.org>), Bio::NEXUS.
.SH "FORUM"
.IX Header "FORUM"
\&\s-1CPAN\s0 hosts a discussion forum for Bio::Phylo. If you have trouble
using this module the discussion forum is a good place to start
posting questions (\s-1NOT\s0 bug reports, see below):
<http://www.cpanforum.com/dist/Bio\-Phylo>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-bio\-phylo@rt.cpan.org\*(C'\fR,
or through the web interface at
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Bio\-Phylo>. I will be notified,
and then you'll automatically be notified of progress on your bug as I make
changes.
.SH "AUTHORS"
.IX Header "AUTHORS"
Rutger Vos, Aki Mimoto, Klaas Hartmann, Jason Caravas, Mark Jensen
and Chase Miller
.ie n .IP "email: ""rutgeraldo@gmail.com""" 4
.el .IP "email: \f(CWrutgeraldo@gmail.com\fR" 4
.IX Item "email: rutgeraldo@gmail.com"
.PD 0
.IP "web page: <http://rutgervos.blogspot.com/>" 4
.IX Item "web page: <http://rutgervos.blogspot.com/>"
.PD
.SH "CITATION"
.IX Header "CITATION"
If you use Bio::Phylo in published research, please cite it:
.PP
\&\fBRutger A Vos\fR, \fBJason Caravas\fR, \fBKlaas Hartmann\fR, \fBMark A Jensen\fR
and \fBChase Miller\fR, 2011. Bio::Phylo \- phyloinformatic analysis using Perl.
\&\fI\s-1BMC\s0 Bioinformatics\fR \fB12\fR:63.
<http://dx.doi.org/10.1186/1471\-2105\-12\-63>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2005\-2010 Rutger A. Vos, All Rights Reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as Perl
itself.
