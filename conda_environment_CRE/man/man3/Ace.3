.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Ace 3"
.TH Ace 3 "2008-11-11" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Ace \- Object\-Oriented Access to ACEDB Databases
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Ace;
\&    # open a remote database connection
\&    $db = Ace\->connect(\-host => \*(Aqbeta.crbm.cnrs\-mop.fr\*(Aq,
\&                       \-port => 20000100);
\&
\&    # open a local database connection
\&    $local = Ace\->connect(\-path=>\*(Aq~acedb/my_ace\*(Aq);
\&
\&    # simple queries
\&    $sequence  = $db\->fetch(Sequence => \*(AqD12345\*(Aq);
\&    $count     = $db\->count(Sequence => \*(AqD*\*(Aq);
\&    @sequences = $db\->fetch(Sequence => \*(AqD*\*(Aq);
\&    $i         = $db\->fetch_many(Sequence=>\*(Aq*\*(Aq);  # fetch a cursor
\&    while ($obj = $i\->next) {
\&       print $obj\->asTable;
\&    }
\&
\&    # complex queries
\&    $query = <<END;
\&    find Annotation Ready_for_submission ; follow gene ; 
\&    follow derived_sequence ; >DNA
\&    END
\&    @ready_dnas= $db\->fetch(\-query=>$query);
\&
\&    $ready = $db\->fetch_many(\-query=>$query);
\&    while ($obj = $ready\->next) {
\&        # do something with obj
\&    }
\&
\&    # database cut and paste
\&    $sequence = $db\->fetch(Sequence => \*(AqD12345\*(Aq);
\&    $local_db\->put($sequence);
\&    @sequences = $db\->fetch(Sequence => \*(AqD*\*(Aq);
\&    $local_db\->put(@sequences);
\&
\&    # Get errors
\&    print Ace\->error;
\&    print $db\->error;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
AcePerl provides an interface to the \s-1ACEDB\s0 object-oriented database.
Both read and write access is provided, and \s-1ACE\s0 objects are returned
as similarly-structured Perl objects.  Multiple databases can be
opened simultaneously.
.PP
You will interact with several Perl classes: \fIAce\fR, \fIAce::Object\fR,
\&\fIAce::Iterator\fR, \fIAce::Model\fR.  \fIAce\fR is the database accessor, and
can be used to open both remote Ace databases (running aceserver or
gifaceserver), and local ones.
.PP
\&\fIAce::Object\fR is the superclass for all objects returned from the
database.  \fIAce\fR and \fIAce::Object\fR are linked: if you retrieve an
Ace::Object from a particular database, it will store a reference to
the database and use it to fetch any subobjects contained within it.
You may make changes to the \fIAce::Object\fR and have those changes
written into the database.  You may also create \fIAce::Object\fRs from
scratch and store them in the database.
.PP
\&\fIAce::Iterator\fR is a utility class that acts as a database cursor for
long-running \s-1ACEDB\s0 queries.  \fIAce::Model\fR provides object-oriented
access to \s-1ACEDB\s0's schema.
.PP
Internally, \fIAce\fR uses the \fIAce::Local\fR class for access to local
databases and \fIAce::AceDB\fR for access to remote databases.
Ordinarily you will not need to interact directly with either of these
classes.
.SH "CREATING NEW DATABASE CONNECTIONS"
.IX Header "CREATING NEW DATABASE CONNECTIONS"
.SS "\fIconnect()\fP \*(-- multiple argument form"
.IX Subsection "connect() multiple argument form"
.Vb 3
\&    # remote database
\&    $db = Ace\->connect(\-host  =>  \*(Aqbeta.crbm.cnrs\-mop.fr\*(Aq,
\&                       \-port  =>  20000100);
\&
\&    # local (non\-server) database
\&    $db = Ace\->connect(\-path  =>  \*(Aq/usr/local/acedb);
.Ve
.PP
Use \fIAce::connect()\fR to establish a connection to a networked or local
AceDB database.  To establish a connection to an AceDB server, use the
\&\fB\-host\fR and/or \fB\-port\fR arguments.  For a local server, use the
\&\fB\-port\fR argument.  The database must be up and running on the
indicated host and port prior to connecting to an AceDB server.  The
full syntax is as follows:
.PP
.Vb 9
\&    $db = Ace\->connect(\-host  =>  $host,
\&                       \-port  =>  $port,
\&                       \-path  =>  $database_path,
\&                       \-program     => $local_connection_program
\&                       \-classmapper =>  $object_class,
\&                       \-timeout     => $timeout,
\&                       \-query_timeout => $query_timeout
\&                       \-cache        => {cache parameters},
\&                      );
.Ve
.PP
The \fIconnect()\fR method uses a named argument calling style, and
recognizes the following arguments:
.IP "\fB\-host\fR, \fB\-port\fR" 4
.IX Item "-host, -port"
These arguments point to the host and port of an AceDB server.
AcePerl will use its internal compiled code to establish a connection
to the server unless explicitly overridden with the \fB\-program\fR
argument.
.IP "\fB\-path\fR" 4
.IX Item "-path"
This argument indicates the path of an AceDB directory on the local
system.  It should point to the directory that contains the \fIwspec\fR
subdirectory.  User name interpolations (~acedb) are \s-1OK.\s0
.IP "\fB\-user\fR" 4
.IX Item "-user"
Name of user to log in as (when using socket server \fBonly\fR).  If not
provided, will attempt an anonymous login.
.IP "\fB\-pass\fR" 4
.IX Item "-pass"
Password to log in with (when using socket server).
.IP "\fB\-url\fR" 4
.IX Item "-url"
An Acedb \s-1URL\s0 that combines the server type, host, port, user and
password in a single string.  See the \fIconnect()\fR method's \*(L"single
argument form\*(R" description.
.IP "\fB\-cache\fR" 4
.IX Item "-cache"
AcePerl can use the Cache::SizeAwareFileCache module to cache objects
to disk. This can result in dramatically increased performance in
environments such as web servers in which the same Acedb objects are
frequently reused.  To activate this mechanism, the
Cache::SizeAwareFileCache module must be installed, and you must pass
the \-cache argument during the \fIconnect()\fR call.
.Sp
The value of \-cache is a hash reference containing the arguments to be
passed to Cache::SizeAwareFileCache.  For example:
.Sp
.Vb 5
\&   \-cache => {
\&              cache_root         => \*(Aq/usr/tmp/acedb\*(Aq,
\&              cache_depth        => 4,
\&              default_expires_in => \*(Aq1 hour\*(Aq
\&              }
.Ve
.Sp
If not otherwise specified, the following cache parameters are assumed:
.Sp
.Vb 6
\&       Parameter               Default Value
\&       \-\-\-\-\-\-\-\-\-               \-\-\-\-\-\-\-\-\-\-\-\-\-
\&       namespace               Server URL (e.g. sace://localhost:2005)
\&       cache_root              /tmp/FileCache (dependent on system temp directory)
\&       default_expires_in      1 day
\&       auto_purge_interval     12 hours
.Ve
.Sp
By default, the cache is not size limited (the \*(L"max_size\*(R" property is
set to \f(CW$NO_MAX_SIZE\fR).  To adjust the size you may consider calling the
Ace object's \fIcache()\fR method to retrieve the physical cache and then
calling the cache object's limit_size($max_size) method from time to
time.  See Cache::SizeAwareFileCache for more details.
.IP "\fB\-program\fR" 4
.IX Item "-program"
By default AcePerl will use its internal compiled code calls to
establish a connection to Ace servers, and will launch a \fItace\fR
subprocess to communicate with local Ace databases.  The \fB\-program\fR
argument allows you to customize this behavior by forcing AcePerl to
use a local program to communicate with the database.  This argument
should point to an executable on your system.  You may use either a
complete path or a bare command name, in which case the \s-1PATH\s0
environment variable will be consulted.  For example, you could force
AcePerl to use the \fIaceclient\fR program to connect to the remote host
by connecting this way:
.Sp
.Vb 3
\&  $db = Ace\->connect(\-host => \*(Aqbeta.crbm.cnrs\-mop.fr\*(Aq,
\&                     \-port => 20000100,
\&                     \-program=>\*(Aqaceclient\*(Aq);
.Ve
.IP "\fB\-classmapper\fR" 4
.IX Item "-classmapper"
The optional \fB\-classmapper\fR argument (alias \fB\-class\fR) points to the
class you would like to return from database queries.  It is provided
for your use if you subclass Ace::Object.  For example, if you have
created a subclass of Ace::Object called Ace::Object::Graphics, you
can have the database return this subclass by default by connecting
this way:
.Sp
.Vb 3
\&  $db = Ace\->connect(\-host => \*(Aqbeta.crbm.cnrs\-mop.fr\*(Aq,
\&                     \-port => 20000100,
\&                     \-class=>\*(AqAce::Object::Graphics\*(Aq);
.Ve
.Sp
The value of \fB\-class\fR can be a hash reference consisting of AceDB
class names as keys and Perl class names as values.  If a class name
does not exist in the hash, a key named _DEFAULT_ will be looked for.
If that does not exist, then Ace will default to Ace::Object.
.Sp
The value of \fB\-class\fR can also be an object or a classname that
implements a \fIclass_for()\fR method.  This method will receive three
arguments containing the AceDB class name, object \s-1ID\s0 and database
handle.  It should return a string indicating the perl class to
create.
.IP "\fB\-timeout\fR" 4
.IX Item "-timeout"
If no response from the server is received within \f(CW$timeout\fR seconds,
the call will return an undefined value.  Internally timeout sets an
alarm and temporarily intercepts the \s-1ALRM\s0 signal.  You should be aware
of this if you use \s-1ALRM\s0 for your own purposes.
.Sp
\&\s-1NOTE:\s0 this feature is temporarily disabled (as of version 1.40)
because it is generating unpredictable results when used with
Apache/mod_perl.
.IP "\fB\-query_timeout\fR" 4
.IX Item "-query_timeout"
If any query takes longer than \f(CW$query_timeout\fR seconds, will return an
undefined value.  This value can only be set at connect time, and cannot
be changed once set.
.PP
If arguments are omitted, they will default to the following values:
.PP
.Vb 7
\&    \-host          localhost
\&    \-port          200005;
\&    \-path          no default
\&    \-program       tace
\&    \-class         Ace::Object
\&    \-timeout       25
\&    \-query_timeout 120
.Ve
.PP
If you prefer to use a more Smalltalk-like message-passing syntax, you
can open a connection this way too:
.PP
.Vb 1
\&  $db = connect Ace \-host=>\*(Aqbeta.crbm.cnrs\-mop.fr\*(Aq,\-port=>20000100;
.Ve
.PP
The return value is an Ace handle to use to access the database, or
undef if the connection fails.  If the connection fails, an error
message can be retrieved by calling Ace\->error.
.PP
You may check the status of a connection at any time with \fIping()\fR.  It
will return a true value if the database is still connected.  Note
that Ace will timeout clients that have been inactive for any length
of time.  Long-running clients should attempt to reestablish their 
connection if \fIping()\fR returns false.
.PP
.Vb 1
\&    $db\->ping() || die "not connected";
.Ve
.PP
You may perform low-level calls using the Ace client C \s-1API\s0 by calling
\&\fIdb()\fR.  This fetches an Ace::AceDB object.  See \s-1THE LOW LEVEL C API\s0 for
details on using this object.
.PP
.Vb 1
\&    $low_level = $db\->db();
.Ve
.SS "\fIconnect()\fP \*(-- single argument form"
.IX Subsection "connect() single argument form"
.Vb 1
\&  $db = Ace\->connect(\*(Aqsace://stein.cshl.org:1880\*(Aq)
.Ve
.PP
Ace\->\fIconnect()\fR also accepts a single argument form using a URL-type
syntax.  The general syntax is:
.PP
.Vb 1
\&   protocol://hostname:port/path
.Ve
.PP
The \fI:port\fR and \fI/path\fR parts are protocol-dependent as described
above.
.PP
Protocols:
.IP "sace://hostname:port" 4
.IX Item "sace://hostname:port"
Connect to a socket server at the indicated hostname and port.  Example:
.Sp
.Vb 1
\&   sace://stein.cshl.org:1880
.Ve
.Sp
If not provided, the port defaults to 2005.
.IP "rpcace://hostname:port" 4
.IX Item "rpcace://hostname:port"
Connect to an \s-1RPC\s0 server at the indicated hostname and \s-1RPC\s0 service number.  Example:
.Sp
.Vb 1
\&  rpcace://stein.cshl.org:400000
.Ve
.Sp
If not provided, the port defaults to 200005
.IP "tace:/path/to/database" 4
.IX Item "tace:/path/to/database"
Open up the local database at \fI/path/to/database\fR using tace.  Example:
.Sp
.Vb 1
\&  tace:/~acedb/elegans
.Ve
.IP "/path/to/database" 4
.IX Item "/path/to/database"
Same as the previous.
.SS "\fIclose()\fP Method"
.IX Subsection "close() Method"
You can explicitly close a database by calling its \fIclose()\fR method:
.PP
.Vb 1
\&   $db\->close();
.Ve
.PP
This is not ordinarily necessary because the database will be
automatically close when it \*(-- and all objects retrieved from it \*(-- go
out of scope.
.SS "\fIreopen()\fP Method"
.IX Subsection "reopen() Method"
The ACeDB socket server can time out.  The \fIreopen()\fR method will ping
the server and if it is not answering will reopen the connection.  If
the database is live (or could be resurrected), this method returns
true.
.SH "RETRIEVING ACEDB OBJECTS"
.IX Header "RETRIEVING ACEDB OBJECTS"
Once you have established a connection and have an Ace databaes
handle, several methods can be used to query the \s-1ACE\s0 database to
retrieve objects.  You can then explore the objects, retrieve specific
fields from them, or update them using the \fIAce::Object\fR methods.
Please see Ace::Object.
.SS "\fIfetch()\fP method"
.IX Subsection "fetch() method"
.Vb 11
\&    $count   = $db\->fetch($class,$name_pattern);
\&    $object  = $db\->fetch($class,$name);
\&    @objects = $db\->fetch($class,$name_pattern,[$count,$offset]);
\&    @objects = $db\->fetch(\-name=>$name_pattern,
\&                          \-class=>$class
\&                          \-count=>$count,
\&                          \-offset=>$offset,
\&                          \-fill=>$fill,
\&                          \-filltag=>$tag,
\&                          \-total=>\e$total);
\&    @objects = $db\->fetch(\-query=>$query);
.Ve
.PP
\&\fIAce::fetch()\fR retrieves objects from the database based on their class
and name.  You may retrieve a single object by requesting its name, or
a group of objects by fetching a name \fIpattern\fR.  A pattern contains
one or more wildcard characters, where \*(L"*\*(R" stands for zero or more
characters, and \*(L"?\*(R" stands for any single character.
.PP
This method behaves differently depending on whether it is called in a
scalar or a list context, and whether it is asked to search for a name
pattern or a simple name.
.PP
When called with a class and a simple name, it returns the object
referenced by that time, or undef, if no such object exists.  In an
array context, it will return an empty list.
.PP
When called with a class and a name pattern in a list context, \fIfetch()\fR
returns the list of objects that match the name.  When called with a
pattern in a scalar context, \fIfetch()\fR returns the \fInumber\fR of objects
that match without actually retrieving them from the database.  Thus,
it is similar to \fIcount()\fR.
.PP
In the examples below, the first line of code will fetch the Sequence
object whose database \s-1ID\s0 is \fID12345\fR.  The second line will retrieve
all objects matching the pattern \fID1234*\fR.  The third line will
return the count of objects that match the same pattern.
.PP
.Vb 3
\&   $object =  $db\->fetch(Sequence => \*(AqD12345\*(Aq);
\&   @objects = $db\->fetch(Sequence => \*(AqD1234*\*(Aq);
\&   $cnt =     $db\->fetch(Sequence =>\*(AqD1234*\*(Aq);
.Ve
.PP
A variety of communications and database errors may occur while
processing the request.  When this happens, undef or an empty list
will be returned, and a string describing the error can be retrieved
by calling Ace\->error.
.PP
When retrieving database objects, it is possible to retrieve a
\&\*(L"filled\*(R" or an \*(L"unfilled\*(R" object.  A filled object contains the entire
contents of the object, including all tags and subtags.  In the case
of certain Sequence objects, this may be a significant amount of data.
Unfilled objects consist just of the object name.  They are filled in
from the database a little bit at a time as tags are requested.  By
default, \fIfetch()\fR returns the unfilled object.  This is usually a
performance win, but if you know in advance that you will be needing
the full contents of the retrieved object (for example, to display
them in a tree browser) it can be more efficient to fetch them in
filled mode. You do this by calling \fIfetch()\fR with the argument of
\&\fB\-fill\fR set to a true value.
.PP
The \fB\-filltag\fR argument, if provided, asks the database to fill in
the subtree anchored at the indicated tag.  This will improve
performance for frequently-accessed subtrees.  For example:
.PP
.Vb 3
\&   @objects = $db\->fetch(\-name    => \*(AqD123*\*(Aq,
\&                         \-class   => \*(AqSequence\*(Aq,
\&                         \-filltag => \*(AqVisible\*(Aq);
.Ve
.PP
This will fetch all Sequences named D123* and fill in their Visible
trees in a single operation.
.PP
Other arguments in the named parameter calling form are \fB\-count\fR, to
retrieve a certain maximum number of objects, and \fB\-offset\fR, to
retrieve objects beginning at the indicated offset into the list.  If
you want to limit the number of objects returned, but wish to learn
how many objects might have been retrieved, pass a reference to a
scalar variable in the \fB\-total\fR argument.  This will return the
object count.  This example shows how to fetch 100 Sequence
objects, starting at Sequence number 500:
.PP
.Vb 1
\&  @some_sequences = $db\->fetch(\*(AqSequence\*(Aq,\*(Aq*\*(Aq,100,500);
.Ve
.PP
The next example uses the named argument form to fetch 100 Sequence
objects starting at Sequence number 500, and leave the total number of
Sequences in \f(CW$total:\fR
.PP
.Vb 4
\&  @some_sequences = $db\->fetch(\-class  => \*(AqSequence\*(Aq,
\&                               \-count  => 100,
\&                               \-offset => 500,
\&                               \-total  => \e$total);
.Ve
.PP
Notice that if you leave out the \fB\-name\fR argument the \*(L"*\*(R" wildcard is 
assumed.
.PP
You may also pass an arbitrary Ace query string with the \fB\-query\fR
argument.  This will supersede any name and class you provide.
Example:
.PP
.Vb 3
\&  @ready_dnas= $db\->fetch(\-query=>
\&      \*(Aqfind Annotation Ready_for_submission ; follow gene ; 
\&       follow derived_sequence ; >DNA\*(Aq);
.Ve
.PP
If your request is likely to retrieve very many objects, \fIfetch()\fR many
consume a lot of memory, even if \fB\-fill\fR is false.  Consider using
\&\fB\f(BIfetch_many()\fB\fR instead (see below).  Also see the \fIget()\fR method, which
is equivalent to the simple two-argument form of \fIfetch()\fR.
.IP "\fIget()\fR method" 4
.IX Item "get() method"
.Vb 1
\&   $object = $db\->get($class,$name [,$fill]);
.Ve
.Sp
The \fIget()\fR method will return one and only one AceDB object
identified by its class and name.  The optional \f(CW$fill\fR argument can be
used to control how much data is retrieved from the database. If \f(CW$fill\fR
is absent or undefined, then the method will return a lightweight
\&\*(L"stub\*(R" object that is filled with information as requested in a lazy
fashion. If \f(CW$fill\fR is the number \*(L"1\*(R" then the retrieved object contains
all the relevant information contained within the database.  Any other
true value of \f(CW$fill\fR will be treated as a tag name: the returned object
will be prefilled with the subtree to the right of that tag.
.Sp
Examples:
.Sp
.Vb 2
\&   # return lightweight stub for Author object "Sulston JE."
\&   $author = $db\->get(Author=>\*(AqSulston JE\*(Aq);
\&
\&   # return heavyweight object
\&   $author = $db\->get(Author=>\*(AqSulston JE\*(Aq,1);
\&
\&   # return object containing the Address subtree
\&   $author = $db\->get(Author=>\*(AqSulston JE\*(Aq,\*(AqAddress\*(Aq);
.Ve
.Sp
The \fIget()\fR method is equivalent to this form of the \fIfetch()\fR
method:
.Sp
.Vb 1
\&   $object = $db\->fetch($class=>$name);
.Ve
.SS "\fIaql()\fP method"
.IX Subsection "aql() method"
.Vb 2
\&    $count   = $db\->aql($aql_query);
\&    @objects = $db\->aql($aql_query);
.Ve
.PP
\&\fIAce::aql()\fR will perform an \s-1AQL\s0 query on the database.  In a scalar
context it returns the number of rows returned.  In an array context
it returns a list of rows.  Each row is an anonymous array containing
the columns returned by the query as an Ace::Object.
.PP
If an \s-1AQL\s0 error is encountered, will return undef or an empty list and
set Ace\->error to the error message.
.PP
Note that this routine is not optimized \*(-- there is no iterator
defined.  All results are returned synchronously, leading to large
memory consumption for certain queries.
.SS "\fIput()\fP method"
.IX Subsection "put() method"
.Vb 1
\&   $cnt = $db\->put($obj1,$obj2,$obj3);
.Ve
.PP
This method will put the list of objects into the database,
overwriting like-named objects if they are already there.  This can
be used to copy an object from one database to another, provided that
the models are compatible.
.PP
The method returns the count of objects successfully written into the
database.  In case of an error, processing will stop at the last
object successfully written and an error message will be placed in
Ace\->\fIerror()\fR;
.SS "\fIparse()\fP method"
.IX Subsection "parse() method"
.Vb 1
\&  $object = $db\->parse(\*(Aqdata to parse\*(Aq);
.Ve
.PP
This will parse the Ace tags contained within the \*(L"data to parse\*(R"
string, convert it into an object in the databse, and return the
resulting Ace::Object.  In case of a parse error, the undefined value
will be returned and a (hopefully informative) description of the
error will be returned by Ace\->\fIerror()\fR.
.PP
For example:
.PP
.Vb 8
\&  $author = $db\->parse(<<END);
\&  Author : "Glimitz JR"
\&  Full_name "Jonathan R. Glimitz"
\&  Mail  "128 Boylston Street"
\&  Mail  "Boston, MA"
\&  Mail  "USA"
\&  Laboratory GM
\&  END
.Ve
.PP
This method can also be used to parse several objects, but only the
last object successfully parsed will be returned.
.SS "\fIparse_longtext()\fP method"
.IX Subsection "parse_longtext() method"
.Vb 1
\&  $object = $db\->parse($title,$text);
.Ve
.PP
This will parse the long text (which may contain carriage returns and
other funny characters) and place it into the database with the given
title.  In case of a parse error, the undefined value will be returned
and a (hopefully informative) description of the error will be
returned by Ace\->\fIerror()\fR; otherwise, a LongText object will be returned.
.PP
For example:
.PP
.Vb 6
\&  $author = $db\->parse_longtext(\*(AqA Novel Inhibitory Domain\*(Aq,<<END);
\&  We have discovered a novel inhibitory domain that inhibits
\&  many classes of proteases, including metallothioproteins.
\&  This inhibitory domain appears in three different gene families studied
\&  to date...
\&  END
.Ve
.SS "\fIparse_file()\fP method"
.IX Subsection "parse_file() method"
.Vb 2
\&  @objects = $db\->parse_file(\*(Aq/path/to/file\*(Aq);
\&  @objects = $db\->parse_file(\*(Aq/path/to/file\*(Aq,1);
.Ve
.PP
This will call \fIparse()\fR to parse each of the objects found in the
indicated .ace file, returning the list of objects successfully loaded
into the database.
.PP
By default, parsing will stop at the first object that causes a parse
error.  If you wish to forge on after an error, pass a true value as
the second argument to this method.
.PP
Any parse error messages are accumulated in Ace\->\fIerror()\fR.
.SS "\fInew()\fP method"
.IX Subsection "new() method"
.Vb 1
\&  $object = $db\->new($class => $name);
.Ve
.PP
This method creates a new object in the database of type \f(CW$class\fR and
name \f(CW$name\fR.  If successful, it returns the newly-created object.
Otherwise it returns undef and sets \f(CW$db\fR\->\fIerror()\fR.
.PP
\&\f(CW$name\fR may contain \fIsprintf()\fR\-style patterns.  If one of the patterns is
\&\f(CW%d\fR (or a variant), Acedb uses a class-specific unique numbering to return
a unique name.  For example:
.PP
.Vb 1
\&  $paper = $db\->new(Paper => \*(Aqwgb%06d\*(Aq);
.Ve
.PP
The object is created in the database atomically.  There is no chance to rollback as there is
in Ace::Object's object editing methods.
.PP
See also the Ace::Object\->\fIadd()\fR and \fIreplace()\fR methods.
.SS "\fIlist()\fP method"
.IX Subsection "list() method"
.Vb 5
\&    @objects = $db\->list(class,pattern,[count,offset]);
\&    @objects = $db\->list(\-class=>$class,
\&                         \-name=>$name_pattern,
\&                         \-count=>$count,
\&                         \-offset=>$offset);
.Ve
.PP
This is a deprecated method.  Use \fIfetch()\fR instead.
.SS "\fIcount()\fP method"
.IX Subsection "count() method"
.Vb 2
\&    $count = $db\->count($class,$pattern);
\&    $count = $db\->count(\-query=>$query);
.Ve
.PP
This function queries the database for a list of objects matching the
specified class and pattern, and returns the object count.  For large
sets of objects this is much more time and memory effective than
fetching the entire list.
.PP
The class and name pattern are the same as the \fIlist()\fR method above.
.PP
You may also provide a \fB\-query\fR argument to instead specify an
arbitrary \s-1ACE\s0 query such as \*(L"find Author \s-1COUNT\s0 Paper > 80\*(R".  See
\&\fIfind()\fR below.
.SS "\fIfind()\fP method"
.IX Subsection "find() method"
.Vb 5
\&    @objects = $db\->find($query_string);
\&    @objects = $db\->find(\-query => $query_string,
\&                         \-offset=> $offset,
\&                         \-count => $count
\&                         \-fill  => $fill);
.Ve
.PP
This allows you to pass arbitrary Ace query strings to the server and
retrieve all objects that are returned as a result.  For example, this
code fragment retrieves all papers written by Jean and Danielle
Thierry-Mieg.
.PP
.Vb 1
\&    @papers = $db\->find(\*(Aqauthor IS "Thierry\-Mieg *" ; >Paper\*(Aq);
.Ve
.PP
You can find the full query syntax reference guide plus multiple
examples at http://probe.nalusda.gov:8000/acedocs/index.html#query.
.PP
In the named parameter calling form, \fB\-count\fR, \fB\-offset\fR, and
\&\fB\-fill\fR have the same meanings as in \fB\f(BIfetch()\fB\fR.
.SS "\fIfetch_many()\fP method"
.IX Subsection "fetch_many() method"
.Vb 1
\&    $obj = $db\->fetch_many($class,$pattern);
\&
\&    $obj = $db\->fetch_many(\-class=>$class,
\&                           \-name =>$pattern,
\&                           \-fill =>$filled,
\&                           \-chunksize=>$chunksize);
\&
\&    $obj = $db\->fetch_many(\-query=>$query);
.Ve
.PP
If you expect to retrieve many objects, you can fetch an iterator
across the data set.  This is friendly both in terms of network
bandwidth and memory consumption.  It is simple to use:
.PP
.Vb 4
\&    $i = $db\->fetch_many(Sequence,\*(Aq*\*(Aq);  # all sequences!!!!
\&    while ($obj = $i\->next) {
\&       print $obj\->asTable;
\&    }
.Ve
.PP
The iterator will return undef when it has finished iterating, and
cannot be used again.  You can have multiple iterators open at once
and they will operate independently of each other.
.PP
Like \fB\f(BIfetch()\fB\fR, \fB\f(BIfetch_many()\fB\fR takes an optional \fB\-fill\fR (or
\&\fB\-filled\fR) argument which retrieves the entire object rather than
just its name.  This is efficient on a network with high latency if 
you expect to be touching many parts of the object (rather than
just retrieving the value of a few tags).
.PP
\&\fB\f(BIfetch_many()\fB\fR retrieves objects from the database in groups of a
certain maximum size, 40 by default.  This can be tuned using the
optional \fB\-chunksize\fR argument.  Chunksize is only a hint to the
database.  It may return fewer objects per transaction, particularly
if the objects are large.
.PP
You may provide raw Ace query string with the \fB\-query\fR argument.  If
present the \fB\-name\fR and \fB\-class\fR arguments will be ignored.
.SS "\fIfind_many()\fP method"
.IX Subsection "find_many() method"
This is an alias for \fIfetch_many()\fR.  It is now deprecated.
.SS "\fIkeyset()\fP method"
.IX Subsection "keyset() method"
.Vb 1
\&    @objects = $db\->keyset($keyset_name);
.Ve
.PP
This method returns all objects in a named keyset.  Wildcard
characters are accepted, in which case all keysets that match the
pattern will be retrieved and merged into a single list of unique
objects.
.SS "\fIgrep()\fP method"
.IX Subsection "grep() method"
.Vb 10
\&    @objects = $db\->grep($grep_string);
\&    $count   = $db\->grep($grep_string);
\&    @objects = $db\->grep(\-pattern => $grep_string,
\&                         \-offset=> $offset,
\&                         \-count => $count,
\&                         \-fill  => $fill,
\&                         \-filltag => $filltag,
\&                         \-total => \e$total,
\&                         \-long  => 1,
\&                        );
.Ve
.PP
This performs a \*(L"grep\*(R" on the database, returning all object names or
text that contain the indicated grep pattern.  In a scalar context
this call will return the number of matching objects.  In an array
context, the list of matching objects are retrieved.  There is also a
named-parameter form of the call, which allows you to specify the
number of objects to retrieve, the offset from the beginning of the
list to retrieve from, whether the retrieved objects should be filled
initially.  You can use \fB\-total\fR to discover the total number of
objects that match, while only retrieving a portion of the list.
.PP
By default, grep uses a fast search that only examines class names and
lexiques.  By providing a true value to the \fB\-long\fR parameter, you
can search inside LongText and other places that are not usually
touched on, at the expense of much more \s-1CPU\s0 time.
.PP
Due to \*(L"not listable\*(R" objects that may match during grep, the list of
objects one can retrieve may not always match the count.
.SS "\fImodel()\fP method"
.IX Subsection "model() method"
.Vb 1
\&  $model = $db\->model(\*(AqAuthor\*(Aq);
.Ve
.PP
This will return an \fIAce::Model\fR object corresponding to the
indicated class.
.SS "\fInew()\fP method"
.IX Subsection "new() method"
.Vb 3
\&   $obj = $db\->new($class,$name);
\&   $obj = $db\->new(\-class=>$class,
\&                   \-name=>$name);
.Ve
.PP
Create a new object in the database with the indicated class and name
and return a pointer to it.  Will return undef if the object already
exists in the database.  The object isn't actually written into the database
until you call \fIAce::Object::commit()\fR.
.SS "\fIraw_query()\fP method"
.IX Subsection "raw_query() method"
.Vb 1
\&    $r = $db\->raw_query(\*(AqModel\*(Aq);
.Ve
.PP
Send a command to the database and return its unprocessed output.
This method is necessary to gain access to features that are not yet
implemented in this module, such as model browsing and complex
queries.
.SS "\fIclasses()\fP method"
.IX Subsection "classes() method"
.Vb 2
\&   @classes = $db\->classes();
\&   @all_classes = $db\->classes(1);
.Ve
.PP
This method returns a list of all the object classes known to the
server.  In a list context it returns an array of class names.  In a
scalar context, it the number of classes defined in the database.
.PP
Ordinarily \fI\fIclasses()\fI\fR will return only those classes that are
exposed to the user interface for browsing, the so-called \*(L"visible\*(R"
classes.  Pass a true argument to the call to retrieve non-visible
classes as well.
.SS "\fIclass_count()\fP method"
.IX Subsection "class_count() method"
.Vb 1
\&   %classes = $db\->class_count()
.Ve
.PP
This returns a hash in which the keys are the class names and the
values are the total number of objects in that class.  All classes
are returned, including invisible ones.  Use this method if you need
to count all classes simultaneously.  If you only want to count one
or two classes, it may be more efficient to call \fIcount($class_name)\fR
instead.
.PP
This method transiently uses a lot of memory.  It should not be used
with Ace 4.5 servers, as they contain a memory leak in the counting
routine.
.SS "\fIstatus()\fP method"
.IX Subsection "status() method"
.Vb 2
\&    %status = $db\->status;
\&    $status = $db\->status;
.Ve
.PP
Returns various bits of status information from the server.  In an
array context, returns a hash of hashes.  In a scalar context, returns a
reference to a hash of hashes.  Keys and subkeys are as follows
.PP
.Vb 4
\&   code
\&           program     name of acedb binary
\&           version     version of acedb binary
\&           build       build date of acedb binary in format Jan 25 2003 16:21:24
\&
\&   database
\&           title       name of the database
\&           version     version of the database
\&           dbformat    database format version number
\&           directory   directory in which the database is stored
\&           session     session number
\&           user        user under which server is running
\&           write       whether the server has write access
\&           address     global address \- not known if this is useful
\&
\&   resources
\&           classes     number of classes defined
\&           keys        number of keys defined
\&           memory      amount of memory used by acedb objects (bytes)
.Ve
.PP
For example, to get the program version:
.PP
.Vb 1
\&   my $version = $db\->status\->{code}{version};
.Ve
.SS "\fItitle()\fP method"
.IX Subsection "title() method"
.Vb 1
\&    my $title = $db\->title
.Ve
.PP
Returns the version of the current database, equivalent
to \f(CW$db\fR\->status\->{database}{title};
.SS "\fIversion()\fP method"
.IX Subsection "version() method"
.Vb 1
\&    my $version = $db\->version;
.Ve
.PP
Returns the version of the current database, equivalent 
to \f(CW$db\fR\->status\->{database}{version};
.SS "\fIdate_style()\fP method"
.IX Subsection "date_style() method"
.Vb 3
\&  $style = $db\->date_style();
\&  $style = $db\->date_style(\*(Aqace\*(Aq);
\&  $style = $db\->date_style(\*(Aqjava\*(Aq);
.Ve
.PP
For historical reasons, AceDB can display dates using either of two
different formats.  The first format, which I call \*(L"ace\*(R" style, puts
the year first, as in \*(L"1997\-10\-01\*(R".  The second format, which I call
\&\*(L"java\*(R" style, puts the day first, as in \*(L"01 Oct 1997 00:00:00\*(R" (this
is also the style recommended for Internet dates).  The default is to
use the latter notation.
.PP
\&\fB\f(BIdate_style()\fB\fR can be used to set or retrieve the current style.
Called with no arguments, it returns the current style, which will be
one of \*(L"ace\*(R" or \*(L"java.\*(R"  Called with an argument, it will set the
style to one or the other.
.SS "\fItimestamps()\fP method"
.IX Subsection "timestamps() method"
.Vb 2
\&  $timestamps_on = $db\->timestamps();
\&  $db\->timestamps(1);
.Ve
.PP
Whenever a data object is updated, AceDB records the time and date of
the update, and the user \s-1ID\s0 it was running under.  Ordinarily, the
retrieval of timestamp information is suppressed to conserve memory
and bandwidth.  To turn on timestamps, call the \fB\f(BItimestamps()\fB\fR method 
with a true value.  You can retrieve the current value of the setting
by calling the method with no arguments.
.PP
Note that activating timestamps disables some of the speed
optimizations in AcePerl.  Thus they should only be activated if you
really need the information.
.SS "\fIauto_save()\fP"
.IX Subsection "auto_save()"
Sets or queries the \fIauto_save\fR variable.  If true, the \*(L"save\*(R"
command will be issued automatically before the connection to the
database is severed.  The default is true.
.PP
Examples:
.PP
.Vb 2
\&   $db\->auto_save(1);
\&   $flag = $db\->auto_save;
.Ve
.SS "\fIerror()\fP method"
.IX Subsection "error() method"
.Vb 1
\&    Ace\->error;
.Ve
.PP
This returns the last error message.  Like \s-1UNIX\s0 errno, this variable
is not reset between calls, so its contents are only valid after a
method call has returned a result value indicating a failure.
.PP
For your convenience, you can call \fIerror()\fR in any of several ways:
.PP
.Vb 3
\&    print Ace\->error();
\&    print $db\->error();  # $db is an Ace database handle
\&    print $obj\->error(); # $object is an Ace::Object
.Ve
.PP
There's also a global named \f(CW$Ace::Error\fR that you are free to use.
.SS "\fIdatetime()\fP and \fIdate()\fP"
.IX Subsection "datetime() and date()"
.Vb 4
\&  $datetime = Ace\->datetime($time);
\&  $today    = Ace\->datetime();
\&  $date     = Ace\->date($time);
\&  $today    = Ace\->date([$time]);
.Ve
.PP
These convenience functions convert the \s-1UNIX\s0 timestamp given by \f(CW$time\fR
(seconds since the epoch) into a datetime string in the format that
\&\s-1ACEDB\s0 requires.  \fIdate()\fR will truncate the time portion.
.PP
If not provided, \f(CW$time\fR defaults to \fIlocaltime()\fR.
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
.SS "\fIdebug()\fP"
.IX Subsection "debug()"
.Vb 1
\&  $debug_level = Ace\->debug([$new_level])
.Ve
.PP
This class method gets or sets the debug level.  Higher integers
increase verbosity.  0 or undef turns off debug messages.
.SS "\fIname2db()\fP"
.IX Subsection "name2db()"
.Vb 1
\& $db = Ace\->name2db($name [,$database])
.Ve
.PP
This class method associates a database \s-1URL\s0 with an Ace database
object. This is used internally by the Ace::Object class in order to
discover what database they \*(L"belong\*(R" to.
.SS "\fIcache()\fP"
.IX Subsection "cache()"
Get or set the Cache::SizeAwareFileCache object, if one has been
created.
.SS "\fImemory_cache_fetch()\fP"
.IX Subsection "memory_cache_fetch()"
.Vb 1
\&  $obj = $db\->memory_cache_fetch($class,$name)
.Ve
.PP
Given an object class and name return a copy of the object from the
in-memory cache.  The object will only be cached if a copy of the
object already exists in memory space.  This is ordinarily called
internally.
.SS "memory_cache_store($obj)"
.IX Subsection "memory_cache_store($obj)"
Store an object into the memory cache.  This is ordinarily called
internally.
.SS "memory_cache_delete($obj)"
.IX Subsection "memory_cache_delete($obj)"
Delete an object from the memory cache. This is ordinarily called
internally.
.SS "\fImemory_cache_clear()\fP"
.IX Subsection "memory_cache_clear()"
Completely clears the memory cache.
.SS "\fIfile_cache_fetch()\fP"
.IX Subsection "file_cache_fetch()"
.Vb 1
\&  $obj = $db\->file_cache_fetch($class,$name)
.Ve
.PP
Given an object class and name return a copy of the object from the
file cache.  This is ordinarily called internally.
.SS "file_cache_store($obj)"
.IX Subsection "file_cache_store($obj)"
Store an object into the file cache.  This is ordinarily called
internally.
.SS "file_cache_delete($obj)"
.IX Subsection "file_cache_delete($obj)"
Delete an object from the file cache.  This is ordinarily called
internally.
.SH "THE LOW LEVEL C API"
.IX Header "THE LOW LEVEL C API"
Internally Ace.pm makes C\-language calls to libace to send query
strings to the server and to retrieve the results.  The class that
exports the low-level calls is named Ace::AceDB.
.PP
The following methods are available in Ace::AceDB:
.IP "new($host,$port,$query_timeout)" 4
.IX Item "new($host,$port,$query_timeout)"
Connect to the host \f(CW$host\fR at port \f(CW$port\fR. Queries will time out after
\&\f(CW$query_timeout\fR seconds.  If timeout is not specified, it defaults to
120 (two minutes).
.Sp
If successful, this call returns an Ace::AceDB connection object.
Otherwise, it returns undef.  Example:
.Sp
.Vb 2
\&  $acedb = Ace::AceDB\->new(\*(Aqlocalhost\*(Aq,200005,5) 
\&           || die "Couldn\*(Aqt connect";
.Ve
.Sp
The Ace::AceDB object can also be accessed from the high-level Ace
interface by calling the \fIACE::db()\fR method:
.Sp
.Vb 2
\&  $db = Ace\->new(\-host=>\*(Aqlocalhost\*(Aq,\-port=>200005);
\&  $acedb = $db\->db();
.Ve
.IP "query($request)" 4
.IX Item "query($request)"
Send the query string \f(CW$request\fR to the server and return a true value
if successful.  You must then call \fIread()\fR repeatedly in order to fetch
the query result.
.IP "\fIread()\fR" 4
.IX Item "read()"
Read the result from the last query sent to the server and return it
as a string.  \s-1ACE\s0 may return the result in pieces, breaking between
whole objects.  You may need to read repeatedly in order to fetch the
entire result.  Canonical example:
.Sp
.Vb 5
\&  $acedb\->query("find Sequence D*");
\&  die "Got an error ",$acedb\->error() if $acedb\->status == STATUS_ERROR;
\&  while ($acedb\->status == STATUS_PENDING) {
\&     $result .= $acedb\->read;
\&  }
.Ve
.IP "\fIstatus()\fR" 4
.IX Item "status()"
Return the status code from the last operation.  Status codes are
exported by default when you \fBuse\fR Ace.pm.  The status codes you may
see are:
.Sp
.Vb 4
\&  STATUS_WAITING    The server is waiting for a query.
\&  STATUS_PENDING    A query has been sent and Ace is waiting for
\&                    you to read() the result.
\&  STATUS_ERROR      A communications or syntax error has occurred
.Ve
.IP "\fIerror()\fR" 4
.IX Item "error()"
Returns a more detailed error code supplied by the Ace server.  Check
this value when \s-1STATUS_ERROR\s0 has been returned.  These constants are
also exported by default.  Possible values:
.Sp
.Vb 4
\& ACE_INVALID
\& ACE_OUTOFCONTEXT
\& ACE_SYNTAXERROR
\& ACE_UNRECOGNIZED
.Ve
.Sp
Please see the ace client library documentation for a full description
of these error codes and their significance.
.IP "\fIencore()\fR" 4
.IX Item "encore()"
This method may return true after you have performed one or more
\&\fIread()\fR operations, and indicates that there is more data to read.  You
will not ordinarily have to call this method.
.SH "BUGS"
.IX Header "BUGS"
1. The \s-1ACE\s0 model should be consulted prior to updating the database.
.PP
2. There is no automatic recovery from connection errors.
.PP
3. Debugging has only one level of verbosity, despite the best
of intentions.
.PP
4. Performance is poor when fetching big objects, because of 
many object references that must be created.  This could be
improved.
.PP
5. When called in an array context at(\*(L"tag[0]\*(R") should return the
current tag's entire column.  It returns the current subtree instead.
.PP
6. There is no way to add comments to objects.
.PP
7. When timestamps are active, many optimizations are disabled.
.PP
8. Item number eight is still missing.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Ace::Object, Ace::Local, Ace::Model,
Ace::Sequence,Ace::Sequence::Multi.
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs\-mop.fr>
.PP
Copyright (c) 1997\-1998 Cold Spring Harbor Laboratory
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  See \s-1DISCLAIMER\s0.txt for
disclaimers of warranty.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1194:" 4
.IX Item "Around line 1194:"
\&'=item' outside of any '=over'
.IP "Around line 1224:" 4
.IX Item "Around line 1224:"
You forgot a '=back' before '=head2'
