.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Bio::Phylo::Forest::NodeRole 3"
.TH Bio::Phylo::Forest::NodeRole 3 "2014-02-08" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Phylo::Forest::NodeRole \- Extra behaviours for a node in a phylogenetic tree
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& # some way to get nodes:
\& use Bio::Phylo::IO;
\& my $string = \*(Aq((A,B),C);\*(Aq;
\& my $forest = Bio::Phylo::IO\->parse(
\&    \-format => \*(Aqnewick\*(Aq,
\&    \-string => $string
\& );
\&
\& # prints \*(AqBio::Phylo::Forest\*(Aq
\& print ref $forest;
\&
\& foreach my $tree ( @{ $forest\->get_entities } ) {
\&
\&    # prints \*(AqBio::Phylo::Forest::Tree\*(Aq
\&    print ref $tree;
\&
\&    foreach my $node ( @{ $tree\->get_entities } ) {
\&
\&       # prints \*(AqBio::Phylo::Forest::Node\*(Aq
\&       print ref $node;
\&
\&       # node has a parent, i.e. is not root
\&       if ( $node\->get_parent ) {
\&          $node\->set_branch_length(1);
\&       }
\&
\&       # node is root
\&       else {
\&          $node\->set_branch_length(0);
\&       }
\&    }
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines a node object and its methods. The node is fairly
syntactically rich in terms of navigation, and additional getters are provided to
further ease navigation from node to node. Typical first daughter \-> next sister
traversal and recursion is possible, but there are also shrinkwrapped methods
that return for example all terminal descendants of the focal node, or all
internals, etc.
.PP
Node objects are inserted into tree objects, although technically the tree
object is only a container holding all the nodes together. Unless there are
orphans all nodes can be reached without recourse to the tree object.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Node constructor.
.Sp
.Vb 10
\& Type    : Constructor
\& Title   : new
\& Usage   : my $node = Bio::Phylo::Forest::Node\->new;
\& Function: Instantiates a Bio::Phylo::Forest::Node object
\& Returns : Bio::Phylo::Forest::Node
\& Args    : All optional:
\&           \-parent          => $parent,
\&           \-taxon           => $taxon,
\&           \-branch_length   => 0.423e+2,
\&           \-first_daughter  => $f_daughter,
\&           \-last_daughter   => $l_daughter,
\&           \-next_sister     => $n_sister,
\&           \-previous_sister => $p_sister,
\&           \-name            => \*(Aqnode_name\*(Aq,
\&           \-desc            => \*(Aqthis is a node\*(Aq,
\&           \-score           => 0.98,
\&           \-generic         => {
\&                \-posterior => 0.98,
\&                \-bootstrap => 0.80
\&           }
.Ve
.IP "\fInew_from_bioperl()\fR" 4
.IX Item "new_from_bioperl()"
Node constructor from bioperl Bio::Tree::NodeI argument.
.Sp
.Vb 10
\& Type    : Constructor
\& Title   : new_from_bioperl
\& Usage   : my $node =
\&           Bio::Phylo::Forest::Node\->new_from_bioperl(
\&               $bpnode
\&           );
\& Function: Instantiates a Bio::Phylo::Forest::Node object
\&           from a bioperl node object.
\& Returns : Bio::Phylo::Forest::Node
\& Args    : An objects that implements Bio::Tree::NodeI
\& Notes   : The following BioPerl properties are copied:
\&           BioPerl output:        Bio::Phylo output:
\&           \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&           id                     get_name
\&           branch_length          get_branch_length
\&           description            get_desc
\&           bootstrap              get_generic(\*(Aqbootstrap\*(Aq)
\&           
\&           In addition all BioPerl tags and values are copied
\&           to set_generic( \*(Aqtag\*(Aq => \*(Aqvalue\*(Aq );
.Ve
.IP "\fIprune_child()\fR" 4
.IX Item "prune_child()"
Removes argument child node (and its descendants) from invocants children.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : prune_child
\& Usage   : $parent\->prune_child($child);
\& Function: Removes $child (and its descendants) from $parent\*(Aqs children
\& Returns : Modified object.
\& Args    : A valid argument is Bio::Phylo::Forest::Node object.
.Ve
.IP "\fIcollapse()\fR" 4
.IX Item "collapse()"
Collapse node.
.Sp
.Vb 10
\& Type    : Mutator
\& Title   : collapse
\& Usage   : $node\->collapse;
\& Function: Attaches invocant\*(Aqs children to invocant\*(Aqs parent.
\& Returns : Modified object.
\& Args    : NONE
\& Comments: If defined, adds invocant\*(Aqs branch 
\&           length to that of its children. If
\&           $node is in a tree, removes itself
\&           from that tree.
.Ve
.IP "\fIset_first_daughter()\fR" 4
.IX Item "set_first_daughter()"
Sets argument as invocant's first daughter.
.Sp
.Vb 8
\& Type    : Mutator
\& Title   : set_first_daughter
\& Usage   : $node\->set_first_daughter($f_daughter);
\& Function: Assigns a node\*(Aqs leftmost daughter.
\& Returns : Modified object.
\& Args    : Undefines the first daughter if no
\&           argument given. A valid argument is
\&           a Bio::Phylo::Forest::Node object.
.Ve
.IP "\fIset_last_daughter()\fR" 4
.IX Item "set_last_daughter()"
Sets argument as invocant's last daughter.
.Sp
.Vb 9
\& Type    : Mutator
\& Title   : set_last_daughter
\& Usage   : $node\->set_last_daughter($l_daughter);
\& Function: Assigns a node\*(Aqs rightmost daughter.
\& Returns : Modified object.
\& Args    : A valid argument consists of a
\&           Bio::Phylo::Forest::Node object. If
\&           no argument is given, the value is
\&           set to undefined.
.Ve
.IP "\fIset_previous_sister()\fR" 4
.IX Item "set_previous_sister()"
Sets argument as invocant's previous sister.
.Sp
.Vb 9
\& Type    : Mutator
\& Title   : set_previous_sister
\& Usage   : $node\->set_previous_sister($p_sister);
\& Function: Assigns a node\*(Aqs previous sister (to the left).
\& Returns : Modified object.
\& Args    : A valid argument consists of
\&           a Bio::Phylo::Forest::Node object.
\&           If no argument is given, the value
\&           is set to undefined.
.Ve
.IP "\fIset_next_sister()\fR" 4
.IX Item "set_next_sister()"
Sets argument as invocant's next sister.
.Sp
.Vb 10
\& Type    : Mutator
\& Title   : set_next_sister
\& Usage   : $node\->set_next_sister($n_sister);
\& Function: Assigns or retrieves a node\*(Aqs
\&           next sister (to the right).
\& Returns : Modified object.
\& Args    : A valid argument consists of a
\&           Bio::Phylo::Forest::Node object.
\&           If no argument is given, the
\&           value is set to undefined.
.Ve
.IP "\fIset_node_below()\fR" 4
.IX Item "set_node_below()"
Sets new (unbranched) node below invocant.
.Sp
.Vb 6
\& Type    : Mutator
\& Title   : set_node_below
\& Usage   : my $new_node = $node\->set_node_below;
\& Function: Creates a new node below $node
\& Returns : New node if tree was modified, undef otherwise
\& Args    : NONE
.Ve
.IP "\fIset_root_below()\fR" 4
.IX Item "set_root_below()"
Reroots below invocant.
.Sp
.Vb 8
\& Type    : Mutator
\& Title   : set_root_below
\& Usage   : $node\->set_root_below;
\& Function: Creates a new tree root below $node
\& Returns : New root if tree was modified, undef otherwise
\& Args    : NONE
\& Comments: Implementation incomplete: returns spurious 
\&           results when $node is grandchild of current root.
.Ve
.SS "\s-1ACCESSORS\s0"
.IX Subsection "ACCESSORS"
.IP "\fIget_first_daughter()\fR" 4
.IX Item "get_first_daughter()"
Gets invocant's first daughter.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_first_daughter
\& Usage   : my $f_daughter = $node\->get_first_daughter;
\& Function: Retrieves a node\*(Aqs leftmost daughter.
\& Returns : Bio::Phylo::Forest::Node
\& Args    : NONE
.Ve
.IP "\fIget_last_daughter()\fR" 4
.IX Item "get_last_daughter()"
Gets invocant's last daughter.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_last_daughter
\& Usage   : my $l_daughter = $node\->get_last_daughter;
\& Function: Retrieves a node\*(Aqs rightmost daughter.
\& Returns : Bio::Phylo::Forest::Node
\& Args    : NONE
.Ve
.IP "\fIget_previous_sister()\fR" 4
.IX Item "get_previous_sister()"
Gets invocant's previous sister.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_previous_sister
\& Usage   : my $p_sister = $node\->get_previous_sister;
\& Function: Retrieves a node\*(Aqs previous sister (to the left).
\& Returns : Bio::Phylo::Forest::Node
\& Args    : NONE
.Ve
.IP "\fIget_next_sister()\fR" 4
.IX Item "get_next_sister()"
Gets invocant's next sister.
.Sp
.Vb 6
\& Type    : Accessor
\& Title   : get_next_sister
\& Usage   : my $n_sister = $node\->get_next_sister;
\& Function: Retrieves a node\*(Aqs next sister (to the right).
\& Returns : Bio::Phylo::Forest::Node
\& Args    : NONE
.Ve
.IP "\fIget_ancestors()\fR" 4
.IX Item "get_ancestors()"
Gets invocant's ancestors.
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_ancestors
\& Usage   : my @ancestors = @{ $node\->get_ancestors };
\& Function: Returns an array reference of ancestral nodes,
\&           ordered from young to old (i.e. $ancestors[\-1] is root).
\& Returns : Array reference of Bio::Phylo::Forest::Node
\&           objects.
\& Args    : NONE
.Ve
.IP "\fIget_root()\fR" 4
.IX Item "get_root()"
Gets root relative to the invocant, i.e. by walking up the path of ancestors
.Sp
.Vb 6
\& Type    : Query
\& Title   : get_root
\& Usage   : my $root = $node\->get_root;
\& Function: Gets root relative to the invocant
\& Returns : Bio::Phylo::Forest::Node           
\& Args    : NONE
.Ve
.IP "\fIget_farthest_node()\fR" 4
.IX Item "get_farthest_node()"
Gets node farthest away from the invocant. By default this is nodal distance,
but when supplied an optional true argument it is based on patristic distance
instead.
.Sp
.Vb 6
\& Type    : Query
\& Title   : get_farthest_node
\& Usage   : my $farthest = $node\->get_farthest_node;
\& Function: Gets node farthest away from the invocant.
\& Returns : Bio::Phylo::Forest::Node           
\& Args    : Optional, TRUE value to use patristic instead of nodal distance
.Ve
.IP "\fIget_sisters()\fR" 4
.IX Item "get_sisters()"
Gets invocant's sisters.
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_sisters
\& Usage   : my @sisters = @{ $node\->get_sisters };
\& Function: Returns an array reference of sisters,
\&           ordered from left to right.
\& Returns : Array reference of
\&           Bio::Phylo::Forest::Node objects.
\& Args    : NONE
.Ve
.IP "\fIget_child()\fR" 4
.IX Item "get_child()"
Gets invocant's i'th child.
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_child
\& Usage   : my $child = $node\->get_child($i);
\& Function: Returns the child at index $i
\& Returns : A Bio::Phylo::Forest::Node object.
\& Args    : An index (integer) $i
\& Comments: if no index is specified, first
\&           child is returned
.Ve
.IP "\fIget_descendants()\fR" 4
.IX Item "get_descendants()"
Gets invocant's descendants.
.Sp
.Vb 9
\& Type    : Query
\& Title   : get_descendants
\& Usage   : my @descendants = @{ $node\->get_descendants };
\& Function: Returns an array reference of
\&           descendants, recursively ordered
\&           breadth first.
\& Returns : Array reference of
\&           Bio::Phylo::Forest::Node objects.
\& Args    : none.
.Ve
.IP "\fIget_terminals()\fR" 4
.IX Item "get_terminals()"
Gets invocant's terminal descendants.
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_terminals
\& Usage   : my @terminals = @{ $node\->get_terminals };
\& Function: Returns an array reference
\&           of terminal descendants.
\& Returns : Array reference of
\&           Bio::Phylo::Forest::Node objects.
\& Args    : NONE
.Ve
.IP "\fIget_internals()\fR" 4
.IX Item "get_internals()"
Gets invocant's internal descendants.
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_internals
\& Usage   : my @internals = @{ $node\->get_internals };
\& Function: Returns an array reference
\&           of internal descendants.
\& Returns : Array reference of
\&           Bio::Phylo::Forest::Node objects.
\& Args    : NONE
.Ve
.IP "\fIget_mrca()\fR" 4
.IX Item "get_mrca()"
Gets invocant's most recent common ancestor shared with argument.
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_mrca
\& Usage   : my $mrca = $node\->get_mrca($other_node);
\& Function: Returns the most recent common ancestor
\&           of $node and $other_node.
\& Returns : Bio::Phylo::Forest::Node
\& Args    : A Bio::Phylo::Forest::Node
\&           object in the same tree.
.Ve
.IP "\fIget_leftmost_terminal()\fR" 4
.IX Item "get_leftmost_terminal()"
Gets invocant's leftmost terminal descendant.
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_leftmost_terminal
\& Usage   : my $leftmost_terminal =
\&           $node\->get_leftmost_terminal;
\& Function: Returns the leftmost
\&           terminal descendant of $node.
\& Returns : Bio::Phylo::Forest::Node
\& Args    : NONE
.Ve
.IP "\fIget_rightmost_terminal()\fR" 4
.IX Item "get_rightmost_terminal()"
Gets invocant's rightmost terminal descendant
.Sp
.Vb 8
\& Type    : Query
\& Title   : get_rightmost_terminal
\& Usage   : my $rightmost_terminal =
\&           $node\->get_rightmost_terminal;
\& Function: Returns the rightmost
\&           terminal descendant of $node.
\& Returns : Bio::Phylo::Forest::Node
\& Args    : NONE
.Ve
.IP "\fIget_subtree()\fR" 4
.IX Item "get_subtree()"
Returns the tree subtended by the invocant
.Sp
.Vb 6
\& Type    : Query
\& Title   : get_subtree
\& Usage   : my $tree = $node\->get_subtree;
\& Function: Returns the tree subtended by the invocant
\& Returns : Bio::Phylo::Forest::Tree
\& Args    : NONE
.Ve
.SS "\s-1TESTS\s0"
.IX Subsection "TESTS"
.IP "\fIis_terminal()\fR" 4
.IX Item "is_terminal()"
Tests if invocant is a terminal node.
.Sp
.Vb 9
\& Type    : Test
\& Title   : is_terminal
\& Usage   : if ( $node\->is_terminal ) {
\&              # do something
\&           }
\& Function: Returns true if node has
\&           no children (i.e. is terminal).
\& Returns : BOOLEAN
\& Args    : NONE
.Ve
.IP "\fIis_internal()\fR" 4
.IX Item "is_internal()"
Tests if invocant is an internal node.
.Sp
.Vb 9
\& Type    : Test
\& Title   : is_internal
\& Usage   : if ( $node\->is_internal ) {
\&              # do something
\&           }
\& Function: Returns true if node
\&           has children (i.e. is internal).
\& Returns : BOOLEAN
\& Args    : NONE
.Ve
.IP "\fIis_preterminal()\fR" 4
.IX Item "is_preterminal()"
Tests if all direct descendents are terminal
.Sp
.Vb 8
\& Type    : Test
\& Title   : is_preterminal
\& Usage   : if ( $node\->is_preterminal ) {
\&              # do something
\&           }
\& Function: Returns true if all direct descendents are terminal
\& Returns : BOOLEAN
\& Args    : NONE
.Ve
.IP "\fIis_first()\fR" 4
.IX Item "is_first()"
Tests if invocant is first sibling in left-to-right order.
.Sp
.Vb 9
\& Type    : Test
\& Title   : is_first
\& Usage   : if ( $node\->is_first ) {
\&              # do something
\&           }
\& Function: Returns true if first sibling 
\&           in left\-to\-right order.
\& Returns : BOOLEAN
\& Args    : NONE
.Ve
.IP "\fIis_last()\fR" 4
.IX Item "is_last()"
Tests if invocant is last sibling in left-to-right order.
.Sp
.Vb 9
\& Type    : Test
\& Title   : is_last
\& Usage   : if ( $node\->is_last ) {
\&              # do something
\&           }
\& Function: Returns true if last sibling 
\&           in left\-to\-right order.
\& Returns : BOOLEAN
\& Args    : NONE
.Ve
.IP "\fIis_root()\fR" 4
.IX Item "is_root()"
Tests if invocant is a root.
.Sp
.Vb 8
\& Type    : Test
\& Title   : is_root
\& Usage   : if ( $node\->is_root ) {
\&              # do something
\&           }
\& Function: Returns true if node is a root       
\& Returns : BOOLEAN
\& Args    : NONE
.Ve
.IP "\fIis_descendant_of()\fR" 4
.IX Item "is_descendant_of()"
Tests if invocant is descendant of argument.
.Sp
.Vb 10
\& Type    : Test
\& Title   : is_descendant_of
\& Usage   : if ( $node\->is_descendant_of($grandparent) ) {
\&              # do something
\&           }
\& Function: Returns true if the node is
\&           a descendant of the argument.
\& Returns : BOOLEAN
\& Args    : putative ancestor \- a
\&           Bio::Phylo::Forest::Node object.
.Ve
.IP "\fIis_ancestor_of()\fR" 4
.IX Item "is_ancestor_of()"
Tests if invocant is ancestor of argument.
.Sp
.Vb 10
\& Type    : Test
\& Title   : is_ancestor_of
\& Usage   : if ( $node\->is_ancestor_of($grandchild) ) {
\&              # do something
\&           }
\& Function: Returns true if the node
\&           is an ancestor of the argument.
\& Returns : BOOLEAN
\& Args    : putative descendant \- a
\&           Bio::Phylo::Forest::Node object.
.Ve
.IP "\fIis_sister_of()\fR" 4
.IX Item "is_sister_of()"
Tests if invocant is sister of argument.
.Sp
.Vb 10
\& Type    : Test
\& Title   : is_sister_of
\& Usage   : if ( $node\->is_sister_of($sister) ) {
\&              # do something
\&           }
\& Function: Returns true if the node is
\&           a sister of the argument.
\& Returns : BOOLEAN
\& Args    : putative sister \- a
\&           Bio::Phylo::Forest::Node object.
.Ve
.IP "\fIis_child_of()\fR" 4
.IX Item "is_child_of()"
Tests if invocant is child of argument.
.Sp
.Vb 10
\& Type    : Test
\& Title   : is_child_of
\& Usage   : if ( $node\->is_child_of($parent) ) {
\&              # do something
\&           }
\& Function: Returns true if the node is
\&           a child of the argument.
\& Returns : BOOLEAN
\& Args    : putative parent \- a
\&           Bio::Phylo::Forest::Node object.
.Ve
.IP "\fIis_outgroup_of()\fR" 4
.IX Item "is_outgroup_of()"
Test if invocant is outgroup of argument nodes.
.Sp
.Vb 10
\& Type    : Test
\& Title   : is_outgroup_of
\& Usage   : if ( $node\->is_outgroup_of(\e@ingroup) ) {
\&              # do something
\&           }
\& Function: Tests whether the set of
\&           \e@ingroup is monophyletic
\&           with respect to the $node.
\& Returns : BOOLEAN
\& Args    : A reference to an array of
\&           Bio::Phylo::Forest::Node objects;
\& Comments: This method is essentially the same as
\&           &Bio::Phylo::Forest::Tree::is_monophyletic.
.Ve
.IP "\fIcan_contain()\fR" 4
.IX Item "can_contain()"
Test if argument(s) can be a child/children of invocant.
.Sp
.Vb 10
\& Type    : Test
\& Title   : can_contain
\& Usage   : if ( $parent\->can_contain(@children) ) {
\&              # do something
\&           }
\& Function: Test if arguments can be children of invocant.
\& Returns : BOOLEAN
\& Args    : An array of Bio::Phylo::Forest::Node objects;
\& Comments: This method is an override of 
\&           Bio::Phylo::Listable::can_contain. Since node
\&           objects hold a list of their children, they
\&           inherit from the listable class and so they
\&           need to be able to validate the contents
\&           of that list before they are inserted.
.Ve
.SS "\s-1CALCULATIONS\s0"
.IX Subsection "CALCULATIONS"
.IP "\fIcalc_path_to_root()\fR" 4
.IX Item "calc_path_to_root()"
Calculates path to root.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_path_to_root
\& Usage   : my $path_to_root =
\&           $node\->calc_path_to_root;
\& Function: Returns the sum of branch
\&           lengths from $node to the root.
\& Returns : FLOAT
\& Args    : NONE
.Ve
.IP "\fIcalc_nodes_to_root()\fR" 4
.IX Item "calc_nodes_to_root()"
Calculates number of nodes to root.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_nodes_to_root
\& Usage   : my $nodes_to_root =
\&           $node\->calc_nodes_to_root;
\& Function: Returns the number of nodes
\&           from $node to the root.
\& Returns : INT
\& Args    : NONE
.Ve
.IP "\fIcalc_max_nodes_to_tips()\fR" 4
.IX Item "calc_max_nodes_to_tips()"
Calculates maximum number of nodes to tips.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_max_nodes_to_tips
\& Usage   : my $max_nodes_to_tips =
\&           $node\->calc_max_nodes_to_tips;
\& Function: Returns the maximum number
\&           of nodes from $node to tips.
\& Returns : INT
\& Args    : NONE
.Ve
.IP "\fIcalc_min_nodes_to_tips()\fR" 4
.IX Item "calc_min_nodes_to_tips()"
Calculates minimum number of nodes to tips.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_min_nodes_to_tips
\& Usage   : my $min_nodes_to_tips =
\&           $node\->calc_min_nodes_to_tips;
\& Function: Returns the minimum number of
\&           nodes from $node to tips.
\& Returns : INT
\& Args    : NONE
.Ve
.IP "\fIcalc_max_path_to_tips()\fR" 4
.IX Item "calc_max_path_to_tips()"
Calculates longest path to tips.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_max_path_to_tips
\& Usage   : my $max_path_to_tips =
\&           $node\->calc_max_path_to_tips;
\& Function: Returns the path length from
\&           $node to the tallest tip.
\& Returns : FLOAT
\& Args    : NONE
.Ve
.IP "\fIcalc_min_path_to_tips()\fR" 4
.IX Item "calc_min_path_to_tips()"
Calculates shortest path to tips.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_min_path_to_tips
\& Usage   : my $min_path_to_tips =
\&           $node\->calc_min_path_to_tips;
\& Function: Returns the path length from
\&           $node to the shortest tip.
\& Returns : FLOAT
\& Args    : NONE
.Ve
.IP "\fIcalc_patristic_distance()\fR" 4
.IX Item "calc_patristic_distance()"
Calculates patristic distance between invocant and argument.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_patristic_distance
\& Usage   : my $patristic_distance =
\&           $node\->calc_patristic_distance($other_node);
\& Function: Returns the patristic distance
\&           between $node and $other_node.
\& Returns : FLOAT
\& Args    : Bio::Phylo::Forest::Node
.Ve
.IP "\fIcalc_nodal_distance()\fR" 4
.IX Item "calc_nodal_distance()"
Calculates node distance between invocant and argument.
.Sp
.Vb 8
\& Type    : Calculation
\& Title   : calc_nodal_distance
\& Usage   : my $nodal_distance =
\&           $node\->calc_nodal_distance($other_node);
\& Function: Returns the number of nodes
\&           between $node and $other_node.
\& Returns : INT
\& Args    : Bio::Phylo::Forest::Node
.Ve
.SS "\s-1VISITOR METHODS\s0"
.IX Subsection "VISITOR METHODS"
The methods below are similar in spirit to those by the same name in Bio::Phylo::Forest::Tree,
except those in the tree class operate from the tree root, and those in this node class operate
on an invocant node, and so these process a subtree.
.IP "\fIvisit_depth_first()\fR" 4
.IX Item "visit_depth_first()"
Visits nodes depth first
.Sp
.Vb 8
\& Type    : Visitor method
\& Title   : visit_depth_first
\& Usage   : $tree\->visit_depth_first( \-pre => sub{ ... }, \-post => sub { ... } );
\& Function: Visits nodes in a depth first traversal, executes subs
\& Returns : $tree
\& Args    : Optional:
\&            # first event handler, is executed when node is reached in recursion
\&            \-pre            => sub { print "pre: ",            shift\->get_name, "\en" },
\&                        
\&            # is executed if node has a daughter, but before that daughter is processed
\&            \-pre_daughter   => sub { print "pre_daughter: ",   shift\->get_name, "\en" },
\&            
\&            # is executed if node has a daughter, after daughter has been processed 
\&            \-post_daughter  => sub { print "post_daughter: ",  shift\->get_name, "\en" },
\&            
\&            # is executed if node has no daughter
\&            \-no_daughter    => sub { print "no_daughter: ",    shift\->get_name, "\en" },                         
\&
\&            # is executed whether or not node has sisters, if it does have sisters
\&            # they\*(Aqre processed first   
\&            \-in             => sub { print "in: ",             shift\->get_name, "\en" },
\&
\&            # is executed if node has a sister, before sister is processed
\&            \-pre_sister     => sub { print "pre_sister: ",     shift\->get_name, "\en" }, 
\&            
\&            # is executed if node has a sister, after sister is processed
\&            \-post_sister    => sub { print "post_sister: ",    shift\->get_name, "\en" },         
\&            
\&            # is executed if node has no sister
\&            \-no_sister      => sub { print "no_sister: ",      shift\->get_name, "\en" }, 
\&            
\&            # is executed last          
\&            \-post           => sub { print "post: ",           shift\->get_name, "\en" },
\&            
\&            # specifies traversal order, default \*(Aqltr\*(Aq means first_daugher \-> next_sister
\&            # traversal, alternate value \*(Aqrtl\*(Aq means last_daughter \-> previous_sister traversal
\&            \-order          => \*(Aqltr\*(Aq, # ltr = left\-to\-right, \*(Aqrtl\*(Aq = right\-to\-left
\&            
\&            # passes sister node as second argument to pre_sister and post_sister subs,
\&            # and daughter node as second argument to pre_daughter and post_daughter subs
\&            \-with_relatives => 1 # or any other true value
\& Comments:
.Ve
.IP "\fIvisit_breadth_first()\fR" 4
.IX Item "visit_breadth_first()"
Visits nodes breadth first
.Sp
.Vb 6
\& Type    : Visitor method
\& Title   : visit_breadth_first
\& Usage   : $tree\->visit_breadth_first( \-pre => sub{ ... }, \-post => sub { ... } );
\& Function: Visits nodes in a breadth first traversal, executes handlers
\& Returns : $tree
\& Args    : Optional handlers in the order in which they would be executed on an internal node:
\&                        
\&            # first event handler, is executed when node is reached in recursion
\&            \-pre            => sub { print "pre: ",            shift\->get_name, "\en" },
\&            
\&            # is executed if node has a sister, before sister is processed
\&            \-pre_sister     => sub { print "pre_sister: ",     shift\->get_name, "\en" }, 
\&            
\&            # is executed if node has a sister, after sister is processed
\&            \-post_sister    => sub { print "post_sister: ",    shift\->get_name, "\en" },         
\&            
\&            # is executed if node has no sister
\&            \-no_sister      => sub { print "no_sister: ",      shift\->get_name, "\en" },             
\&            
\&            # is executed whether or not node has sisters, if it does have sisters
\&            # they\*(Aqre processed first   
\&            \-in             => sub { print "in: ",             shift\->get_name, "\en" },         
\&            
\&            # is executed if node has a daughter, but before that daughter is processed
\&            \-pre_daughter   => sub { print "pre_daughter: ",   shift\->get_name, "\en" },
\&            
\&            # is executed if node has a daughter, after daughter has been processed 
\&            \-post_daughter  => sub { print "post_daughter: ",  shift\->get_name, "\en" },
\&            
\&            # is executed if node has no daughter
\&            \-no_daughter    => sub { print "no_daughter: ",    shift\->get_name, "\en" },                         
\&            
\&            # is executed last          
\&            \-post           => sub { print "post: ",           shift\->get_name, "\en" },
\&            
\&            # specifies traversal order, default \*(Aqltr\*(Aq means first_daugher \-> next_sister
\&            # traversal, alternate value \*(Aqrtl\*(Aq means last_daughter \-> previous_sister traversal
\&            \-order          => \*(Aqltr\*(Aq, # ltr = left\-to\-right, \*(Aqrtl\*(Aq = right\-to\-left
\& Comments:
.Ve
.IP "\fIvisit_level_order()\fR" 4
.IX Item "visit_level_order()"
Visits nodes in a level order traversal.
.Sp
.Vb 7
\& Type    : Visitor method
\& Title   : visit_level_order
\& Usage   : $tree\->visit_level_order( sub{...} );
\& Function: Visits nodes in a level order traversal, executes sub
\& Returns : $tree
\& Args    : A subroutine reference that operates on visited nodes.
\& Comments:
.Ve
.SS "\s-1SERIALIZERS\s0"
.IX Subsection "SERIALIZERS"
.IP "\fIto_xml()\fR" 4
.IX Item "to_xml()"
Serializes invocant to xml.
.Sp
.Vb 6
\& Type    : Serializer
\& Title   : to_xml
\& Usage   : my $xml = $obj\->to_xml;
\& Function: Turns the invocant object (and its descendants )into an XML string.
\& Returns : SCALAR
\& Args    : NONE
.Ve
.IP "\fIto_newick()\fR" 4
.IX Item "to_newick()"
Serializes subtree subtended by invocant to newick string.
.Sp
.Vb 7
\& Type    : Serializer
\& Title   : to_newick
\& Usage   : my $newick = $obj\->to_newick;
\& Function: Turns the invocant object into a newick string.
\& Returns : SCALAR
\& Args    : takes same arguments as Bio::Phylo::Unparsers::Newick
\& Comments: takes same arguments as Bio::Phylo::Unparsers::Newick
.Ve
.IP "\fIto_dom()\fR" 4
.IX Item "to_dom()"
.Vb 7
\& Type    : Serializer
\& Title   : to_dom
\& Usage   : $node\->to_dom($dom)
\& Function: Generates an array of DOM elements from the invocant\*(Aqs
\&           descendants
\& Returns : an array of Element objects
\& Args    : DOM factory object
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
There is a mailing list at <https://groups.google.com/forum/#!forum/bio\-phylo> 
for any user or developer questions and discussions.
.IP "Bio::Phylo::Taxa::TaxonLinker" 4
.IX Item "Bio::Phylo::Taxa::TaxonLinker"
This object inherits from Bio::Phylo::Taxa::TaxonLinker, so methods
defined there are also applicable here.
.IP "Bio::Phylo::Listable" 4
.IX Item "Bio::Phylo::Listable"
This object inherits from Bio::Phylo::Listable, so methods
defined there are also applicable here.
.IP "Bio::Phylo::Manual" 4
.IX Item "Bio::Phylo::Manual"
Also see the manual: Bio::Phylo::Manual and <http://rutgervos.blogspot.com>.
.SH "CITATION"
.IX Header "CITATION"
If you use Bio::Phylo in published research, please cite it:
.PP
\&\fBRutger A Vos\fR, \fBJason Caravas\fR, \fBKlaas Hartmann\fR, \fBMark A Jensen\fR
and \fBChase Miller\fR, 2011. Bio::Phylo \- phyloinformatic analysis using Perl.
\&\fI\s-1BMC\s0 Bioinformatics\fR \fB12\fR:63.
<http://dx.doi.org/10.1186/1471\-2105\-12\-63>
