.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Jcode::Nihongo 3"
.TH Jcode::Nihongo 3 "2005-02-19" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "名前"
.IX Header "名前"
Jcode \- 日本語文字集合ハンドラ
.SH "概要"
.IX Header "概要"
.Vb 6
\& use Jcode;
\& # 
\& # 古式ゆかしく
\& Jcode::convert($str, $ocode, $icode, "z");
\& # もしくはオブジェクト指向で！
\& print Jcode\->new($str)\->h2z\->tr($from, $to)\->utf8;
.Ve
.SH "説明"
.IX Header "説明"
Jcode.pmはオブジェクト的なアプローチと従来からのアプローチの両方を
サポートしています。オブジェクト的なアプローチを使えばこんな感じで；
.PP
.Vb 1
\&  $iso_2022_jp = Jcode\->new($str)\->h2z\->jis;
.Ve
.PP
こちらよりエレガントでしょう：
.PP
.Vb 2
\&  $iso_2022_jp = $str;
\&  &jcode::convert(\e$iso_2022_jp, \*(Aqjis\*(Aq, &jcode::getcode(\e$str), "z");
.Ve
.PP
オブジェクトに馴染みの無い人のために、Jcode.pmはまだ\f(CW\*(C`getcode()\*(C'\fRと
\&\f(CW\*(C`convert()\*(C'\fRをサポートしています。
.PP
Perlのバージョンが5.8.1以上なら、Jcodeは、Perl 5.8以降の標準的な文字集合
ハンドラモジュールであるEncodeのラッパーとして振る舞います。
.SH "メソッド"
.IX Header "メソッド"
特に言及しない限り、ここで挙げるメソッドは全てJcodeオブジェクトを返します。
.SS "コンストラクタ"
.IX Subsection "コンストラクタ"
.ie n .IP "$j = Jcode\->new($str [, $icode])" 2
.el .IP "\f(CW$j\fR = Jcode\->new($str [, \f(CW$icode\fR])" 2
.IX Item "$j = Jcode->new($str [, $icode])"
\&\f(CW$strからJcodeオブジェクト\fR$jを生成します。明示的に$icodeをセットしなければ、
入力コードは自動的に判定されます。利用可能な文字集合については、下の
getcodeを参照してください。
.Sp
Perl 5.8.1以降では、\f(CW$icode\fRにはEncodeが理解できる
\&\fIどんなエンコーディング名\fRも使えます。
.Sp
.Vb 1
\&  $j = Jcode\->new($european, \*(Aqiso\-latin1\*(Aq);
.Ve
.Sp
オブジェクトを文字列化すると、EUCに変換された文字列が返ります。ですから
\&\f(CW\*(C`print $j\->euc\*(C'\fRとする代わりに、\f(CW\*(C`print $j\*(C'\fRとできます。
.RS 2
.IP "リファレンス渡し" 2
.IX Item "リファレンス渡し"
スカラー値の代わりに、以下のようにリファレンスを渡せます。
.Sp
.Vb 1
\& Jcode\->new(\e$str);
.Ve
.Sp
これはほんの少し時間を節約します。その代償として、$strの値そのものが
変換されます（ある意味、$strはjcodeオブジェクトに\*(L"tieされる\*(R"のです）。
.RE
.RS 2
.RE
.ie n .IP "$j\->set($str [, $icode])" 2
.el .IP "\f(CW$j\fR\->set($str [, \f(CW$icode\fR])" 2
.IX Item "$j->set($str [, $icode])"
\&\f(CW$jの内部文字列に\fR$strをセットします。繰り返しJcodeオブジェクトを使うときに
便利です（オブジェクトを生成する時間とメモリの節約になります）。
.Sp
.Vb 6
\& # mailboxをSJIS形式に変換
\& my $jconv = new Jcode;
\& $/ = 00;
\& while(<>){
\&     print $jconv\->set(\e$_)\->mime_decode\->sjis;
\& }
.Ve
.ie n .IP "$j\->append($str [, $icode]);" 2
.el .IP "\f(CW$j\fR\->append($str [, \f(CW$icode\fR]);" 2
.IX Item "$j->append($str [, $icode]);"
\&\f(CW$jの内部文字列に\fR$strを加えます。
.ie n .IP "$j = jcode($str [, $icode]);" 2
.el .IP "\f(CW$j\fR = jcode($str [, \f(CW$icode\fR]);" 2
.IX Item "$j = jcode($str [, $icode]);"
Jcode\->\fInew()\fR の短縮形。以下のようにできます；
.Sp
.Vb 1
\& $sjis = jcode($str)\->sjis;
.Ve
.SS "文字列のエンコード"
.IX Subsection "文字列のエンコード"
一般に、$j\->\fIencoded\fRとすることで\fIencoded\fRに変換された文字列を得ます。
.ie n .IP "$sjis = $j\->sjis" 2
.el .IP "\f(CW$sjis\fR = \f(CW$j\fR\->sjis" 2
.IX Item "$sjis = $j->sjis"
.PD 0
.ie n .IP "$euc = $j\->euc" 2
.el .IP "\f(CW$euc\fR = \f(CW$j\fR\->euc" 2
.IX Item "$euc = $j->euc"
.ie n .IP "$jis = $j\->jis" 2
.el .IP "\f(CW$jis\fR = \f(CW$j\fR\->jis" 2
.IX Item "$jis = $j->jis"
.ie n .IP "$sjis = $j\->sjis" 2
.el .IP "\f(CW$sjis\fR = \f(CW$j\fR\->sjis" 2
.IX Item "$sjis = $j->sjis"
.ie n .IP "$ucs2 = $j\->ucs2" 2
.el .IP "\f(CW$ucs2\fR = \f(CW$j\fR\->ucs2" 2
.IX Item "$ucs2 = $j->ucs2"
.ie n .IP "$utf8 = $j\->utf8" 2
.el .IP "\f(CW$utf8\fR = \f(CW$j\fR\->utf8" 2
.IX Item "$utf8 = $j->utf8"
.PD
自明でしょう。
\&\s-1WYCIWYG\s0 = What you code is what you get :)
.ie n .IP "$iso_2022_jp = $j\->iso_2022_jp" 2
.el .IP "\f(CW$iso_2022_jp\fR = \f(CW$j\fR\->iso_2022_jp" 2
.IX Item "$iso_2022_jp = $j->iso_2022_jp"
\&\f(CW\*(C`$j\->h2z\->jis\*(C'\fRと同じです。
半角カナは強制的に全角に変換されます。
.Sp
Perl 5.8.1以降では、Encodeがサポートするどんなエンコーディング名と
エイリアスでも利用できます。例えば：
.Sp
.Vb 1
\&  $european = $j\->iso_latin1; # メソッド名用に\*(Aq\-\*(Aqは\*(Aq_\*(Aqに置き換えます
.Ve
.Sp
\&\fB参考\fR：Encode::Encoderがこれと同じ小技を使っています。
.RS 2
.ie n .IP "$j\->fallback($fallback)" 2
.el .IP "\f(CW$j\fR\->fallback($fallback)" 2
.IX Item "$j->fallback($fallback)"
Perl 5.8.1以降では、Jcodeは内部の文字列をUTF\-8で保持します。
\&\fI\->encoding\fRにマップできない文字は'?'に置き換えられますが、
これはEncodeでの標準動作です。
.Sp
.Vb 2
\&  my $unistr = "\ex{262f}"; # 陰陽マーク
\&  my $j = jcode($unistr);  # $j\->euc の結果は \*(Aq?\*(Aq に
.Ve
.Sp
この振る舞いは、Encode同様、フォールバックを指定することで変更できます。
値はEncodeのものと一緒です。便宜のため、\f(CW\*(C`Jcode::FB_PERLQQ\*(C'\fR、
\&\f(CW\*(C`Jcode::FB_XMLCREF\*(C'\fR、\f(CW\*(C`Jcode::FB_HTMLCREF\*(C'\fRがEncodeのそれらへの
エイリアスになっています。
.Sp
.Vb 3
\&  print $j\->fallback(Jcode::FB_PERLQQ)\->euc;   # \*(Aq\ex{262f}\*(Aq
\&  print $j\->fallback(Jcode::FB_XMLCREF)\->euc;  # \*(Aq&#x262f;\*(Aq
\&  print $j\->fallback(Jcode::FB_HTMLCREF)\->euc; # \*(Aq&#9775;\*(Aq
.Ve
.Sp
グローバル変数\f(CW$Jcode::FALLBACK\fRにデフォルトのフォールバックが保持
されていますので、この値を代入することでオーバーライドできます。
.Sp
.Vb 1
\&  $Jcode::FALLBACK = Jcode::FB_PERLQQ; # デフォルトのフォールバックスキーマを設定
.Ve
.RE
.RS 2
.RE
.ie n .IP "[@lines =] $jcode\->jfold([$width, $newline_str, $kref])" 2
.el .IP "[@lines =] \f(CW$jcode\fR\->jfold([$width, \f(CW$newline_str\fR, \f(CW$kref\fR])" 2
.IX Item "[@lines =] $jcode->jfold([$width, $newline_str, $kref])"
\&\f(CW$width\fR（デフォルト：72）毎にjcode文字列内の行を折り返します。
\&\f(CW$widthは\fR”半角”文字の数です。全角文字は2文字としてカウントします。
.Sp
\&\f(CW$newline_str\fR（デフォルトは\*(L"\en\*(R"）で指定された改行文字が加わります。
折り返された全行をリストで返します。
.Sp
Perl 5.8.1以降は3番目の引数$krefにEUCの文字列の配列リファレンスを
渡すことで、簡易的な行頭禁則処理（ぶら下がり）を行えます。
.ie n .IP "$length = $jcode\->\fIjlength()\fR;" 2
.el .IP "\f(CW$length\fR = \f(CW$jcode\fR\->\fIjlength()\fR;" 2
.IX Item "$length = $jcode->jlength();"
バイト長ではなく、全角文字も一文字として数えた場合の文字数を返します。
.SS "MIME::Base64を使うメソッド"
.IX Subsection "MIME::Base64を使うメソッド"
下記のメソッドを使うには、MIME::Base64が必要です。インストールは単純に
.PP
.Vb 1
\&   perl \-MCPAN \-e \*(AqCPAN::Shell\->install("MIME::Base64")\*(Aq
.Ve
.PP
とします。お使いのPerlが5.6以降であるなら、MIME::Base64は
バンドルされているので、インストールの必要はありません。
.ie n .IP "$mime_header = $j\->mime_encode([$lf, $bpl])" 2
.el .IP "\f(CW$mime_header\fR = \f(CW$j\fR\->mime_encode([$lf, \f(CW$bpl\fR])" 2
.IX Item "$mime_header = $j->mime_encode([$lf, $bpl])"
\&\f(CW$strをRFC1522にあるMIME\fR\-Headerに変換します。$lfを指定すると、
行の折り返しに$lfが使われます（デフォルト：\en）。
\&\f(CW$bplを指定すると\fR、折り返すバイト数に$bplが使われます（デフォルト：76；
この数値は76以下でなければなりません）。
.Sp
Perl 5.8.1以降では、以下のようにしてもMIME Headerエンコードができます：
.Sp
.Vb 1
\&  $mime_header = $j\->MIME_Header;
.Ve
.Sp
この場合\f(CW$mime_header\fRの戻り値はMIME\-B\-encoded UTF\-8になります。
一方、\f(CW\*(C`$j\->mime_encode()\*(C'\fRはMIME\-B\-encoded ISO\-2022\-JPを返します。
最近のほとんどのメーラーはどちらもサポートしています。
.ie n .IP "$j\->mime_decode;" 2
.el .IP "\f(CW$j\fR\->mime_decode;" 2
.IX Item "$j->mime_decode;"
Jcodeオブジェクトの内部文字列をMIME\-Headerデコードします。Perl 5.8.1
以降なら、以下のようにして同じことができます：
.Sp
.Vb 1
\&  Jcode\->new($str, \*(AqMIME\-Header\*(Aq);
.Ve
.Sp
こちらの場合、ISO\-2022\-JPだけではなくUTF\-8などにも対応しており、
さらにMIME B EncodingのみならずMIME Q Encodingにも対応している
ので、Perl 5.8.1以降であればこちらを使うべきでしょう。
.SS "半角 ←→ 全角"
.IX Subsection "半角 ←→ 全角"
.ie n .IP "$j\->h2z([$keep_dakuten])" 2
.el .IP "\f(CW$j\fR\->h2z([$keep_dakuten])" 2
.IX Item "$j->h2z([$keep_dakuten])"
X201カナ（半角）をX208カナ（全角）に変換します。
\&\f(CW$keep_dakutenに真値をセットすると\fR、濁点をそのままにします
(これはつまり、「カ＋゛」は「ガ」に変換されずにそのまま
になるということです)
.Sp
\&\f(CW$j\fR\->nmatchを通じてマッチした数を取得できます。
.ie n .IP "$j\->z2h" 2
.el .IP "\f(CW$j\fR\->z2h" 2
.IX Item "$j->z2h"
X208カナ（全角）をX201カナ（半角）に変換します。
.Sp
\&\f(CW$j\fR\->nmatchを通じてマッチした数を取得できます。
.SS "正規表現エミュレータ"
.IX Subsection "正規表現エミュレータ"
\&\f(CW\*(C`\->m()\*(C'\fRと\f(CW\*(C`\->s()\*(C'\fRを使うには、Perl 5.8.1以降が
必要です。
.ie n .IP "$j\->tr($from, $to, $opt);" 2
.el .IP "\f(CW$j\fR\->tr($from, \f(CW$to\fR, \f(CW$opt\fR);" 2
.IX Item "$j->tr($from, $to, $opt);"
Jcodeオブジェクトに\f(CW\*(C`tr/$from/$to/\*(C'\fRを適用します。$fromと$toは
EUC\-JPの文字列です。Perl 5.8.1以降では、flag付きのUTF\-8文字列
も受け付けます。
.Sp
\&\f(CW$opt\fRをセットすると、\f(CW\*(C`tr/$from/$to/$opt\*(C'\fRが適用されます。\f(CW$opt\fRは
\&'c'、'd'あるいはそれらの組み合わせでなければなりません。
.Sp
\&\f(CW$j\fR\->nmatchを通じてマッチした数を取得できます。
.Sp
Perl 5.8.1以降では、trの形式に誤りのあった場合に\->error_trを通じて、
$@を取得できます。
.Sp
以下のメソッドはPerl 5.8.1以降でのみ利用可能です。
.ie n .IP "$j\->s($patter, $replace, $opt);" 2
.el .IP "\f(CW$j\fR\->s($patter, \f(CW$replace\fR, \f(CW$opt\fR);" 2
.IX Item "$j->s($patter, $replace, $opt);"
個々に\f(CW\*(C`s/$pattern/$replace/$opt\*(C'\fRを適用します。\f(CW$opt\fRは正規表現オプションと
同じです。正規表現のオプションについてはperlreを参照ください。
.Sp
\&\f(CW\*(C`$j\->tr()\*(C'\fR、\f(CW\*(C`$j\->s()\*(C'\fRはそのオブジェクト自身を返すので、
以下のように操作を連結できます。
.Sp
.Vb 1
\&  $j\->tr("A\-Z", "a\-z")\->s("foo", "bar");
.Ve
.ie n .IP "[@match = ] $j\->m($pattern, $opt);" 2
.el .IP "[@match = ] \f(CW$j\fR\->m($pattern, \f(CW$opt\fR);" 2
.IX Item "[@match = ] $j->m($pattern, $opt);"
\&\f(CW\*(C`m/$patter/$opt\*(C'\fRを適用します。このメソッドは”オブジェクトを返さない”
ので、\f(CW\*(C`$j\->s()\*(C'\fRのようにメソッドを連結できないことに注意してください。
.Sp
正規表現の形式に誤りのあった場合、\->error_m、\->error_sを通じて
$@を取得できます。
.SS "インスタンス変数"
.IX Subsection "インスタンス変数"
もしJcodeオブジェクトのインスタンス変数にアクセスしたいなら、直接それら
にアクセスするのではなく、アクセスメソッドを利用しましょう（これぞOOP
です）。
.PP
参考までに、Jcodeは（一般的な方法である）ハッシュリファレンスの代わりに、
配列リファレンスを使うことで、スピードを最適化しています（実際のところ、
アクセスメソッドを使う限りこのことを知る必要はありません； もう一度
いいますが、これはOOPなのです）。
.PP
Perl 5.8.1以降では、ハッシュリファレンスを使うように変更されました。
これにより、Jcodeの拡張はものすごく簡単になります。
.ie n .IP "$j\->r_str" 2
.el .IP "\f(CW$j\fR\->r_str" 2
.IX Item "$j->r_str"
EUC文字列へのリファレンス。
.Sp
Perl 5.8.1以降ではUTF\-8フラグの立ったUTF\-8文字列へのリファレンスです。
.ie n .IP "$j\->icode" 2
.el .IP "\f(CW$j\fR\->icode" 2
.IX Item "$j->icode"
直近の操作における入力文字コード。
.ie n .IP "$j\->nmatch" 2
.el .IP "\f(CW$j\fR\->nmatch" 2
.IX Item "$j->nmatch"
マッチした数（$j\->tr等を使ったとき）。
.SH "サブルーチン"
.IX Header "サブルーチン"
.IP "($code, [$nmatch]) = getcode($str)" 2
.IX Item "($code, [$nmatch]) = getcode($str)"
\&\f(CW$strの文字コードを返します\fR。返るコードは以下の通りです。
.Sp
.Vb 7
\& ascii   Ascii （日本語コードを含まない）
\& binary  Binary （テキストファイルではない）
\& euc     EUC\-JP
\& sjis    SHIFT_JIS
\& jis     JIS (ISO\-2022\-JP)
\& ucs2    UCS2 (Raw Unicode)
\& utf8    UTF8
.Ve
.Sp
スカラーコンテキストの代わりに配列コンテキストを使うと、何文字分の
コードが見つかったのかも返します。上の方で述べたように、$strは\e$str
でも構いません。
.Sp
\&\fBjcode.pl 利用者の方へ：\fR この関数はjcode::\fIgetcode()\fRと100%上位互換が
あります。――まあ、ほぼ100%；
.Sp
.Vb 2
\& * 戻り値が配列のとき、その順番は逆となります；
\&   jcode::getcode()は$nmatchを最初に返します。
\&
\& * jcode::getcode()は、EUC文字とSJIS文字の数が等しいとき、\*(Aqundef\*(Aqを
\&   返します。 Jcode::getcode()はEUCを返します。これはJcode.pmには
\&   中間がないためです。
.Ve
.ie n .IP "Jcode::convert($str, [$ocode, $icode, $opt])" 2
.el .IP "Jcode::convert($str, [$ocode, \f(CW$icode\fR, \f(CW$opt\fR])" 2
.IX Item "Jcode::convert($str, [$ocode, $icode, $opt])"
\&\f(CW$strを\fR$ocodeで指定した文字コードに変換します。$icodeも指定すると、
入力文字列をgetcode()でチェックする代わりに、$icodeと仮定します。
上の方で述べたように、$strは\e$strでも構いません。
.Sp
\&\fBjcode.pl 利用者の方へ：\fR この関数はjcode::\fIconvert()\fRと100%上位互換が
あります！
.SH "バグ"
.IX Header "バグ"
Perlが5.8.1以降の場合、JcodeはEncodeのラッパーとして振る舞います。
つまり、JcodeはEncode内のバグの影響を受けます。
.SH "謝辞"
.IX Header "謝辞"
このパッケージは、動機、デザインそしてコードの多くの点で、
歌代 和正 <utashiro@iij.ad.jp>氏のPerl4ライブラリjcode.plに負っています。
.PP
大崎 博基 <ohzaki@iod.ricoh.co.jp>氏は、開発の非常に初期の段階から
正規表現を磨きあげる手助けをしてくれました。
.PP
makamaka@donzoko.net の JEncode には、JcodeとEncodeをどう融合させれば
いいか大変大きな啓示を受けました。また、本日本語マニュアルも寄贈して
いただきました。
.PP
そしてJcode \s-1ML\s0 <jcode5@ring.gr.jp>の皆さん。この方達なしには、
ここまで完成しなかったことでしょう。
.SH "参考"
.IX Header "参考"
Encode
.PP
<http://www.iana.org/assignments/character\-sets>
.SH "著作権"
.IX Header "著作権"
Copyright 1999\-2005 Dan Kogai <dankogai@dan.co.jp>
.PP
This library is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
