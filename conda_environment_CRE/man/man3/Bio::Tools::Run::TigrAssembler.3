.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Run::TigrAssembler 3"
.TH Bio::Tools::Run::TigrAssembler 3 "2019-10-28" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::Run::TigrAssembler \- Wrapper for local execution of TIGR Assembler
 v2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&  use Bio::Tools::Run::TigrAssembler;
\&  # Run TIGR Assembler using an input FASTA file
\&  my $factory = Bio::Tools::Run::TigrAssembler\->new( \-minimum_overlap_length => 35 );
\&  my $asm_obj = $factory\->run($fasta_file, $qual_file);
\&  # An assembly object is returned by default
\&  for my $contig ($assembly\->all_contigs) {
\&    ... do something ...
\&  }
\&
\&  # Read some sequences
\&  use Bio::SeqIO;
\&  my $sio = Bio::SeqIO\->new(\-file => $fasta_file, \-format => \*(Aqfasta\*(Aq);
\&  my @seqs;
\&  while (my $seq = $sio\->next_seq()) {
\&    push @seqs,$seq;
\&  }
\&
\&  # Run TIGR Assembler with input sequence objects and return an assembly file
\&  my $asm_file = \*(Aqresults.tigr\*(Aq;
\&  $factory\->out_type($asm_file);
\&  $factory\->run(\e@seqs);
\&
\&  # Use LIGR Assembler instead
\&  my $ligr = Bio::Tools::Run::TigrAssembler\->new(
\&    \-program_name => \*(AqLIGR_Assembler\*(Aq,
\&    \-trimmed_seq  => 1
\&  );
\&  $ligr\->run(\e@seqs);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 3
\&  Wrapper module for the local execution of the DNA assembly program TIGR
\&  Assembler v2.0. TIGR Assembler is open source software under The Artistic
\&  License and available at: http://www.tigr.org/software/assembler/
\&
\&  This module runs TIGR Assembler by feeding it a FASTA file or sequence objects
\&  and returning an assembly file or assembly and IO objects. When the input is
\&  Bioperl object, sequences less than 39 bp long are filtered out since they are
\&  not supported by TIGR Assembler.
\&
\&  If provided in the following way, TIGR Assembler will use additional
\&  information present in the sequence descriptions for assembly:
\&    >seq_name minimum_clone_length maximum_clone_length median_clone_length
\&     clear_end5 clear_end3
\&    or
\&    >db|seq_name minimum_clone_length maximum_clone_length median_clone_length
\&     clear_end5 clear_end3
\&    e.g.
\&    >GHIBF57F 500 3000 1750 33 587
\&
\&  This module also supports LIGR Assembler, a variant of TIGR Assembler:
\&    http://sourceforge.net/projects/ligr\-assembler/
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other Bioperl
modules. Send your comments and suggestions preferably to one of the Bioperl
mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track the bugs
and their resolution.  Bug reports can be submitted via the web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Florent E Angly"
.IX Header "AUTHOR - Florent E Angly"
.Vb 1
\& Email: florent\-dot\-angly\-at\-gmail\-dot\-com
.Ve
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal
methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 7
\& Title   : new
\& Usage   : $factory\->new( \-minimum_percent  => 95,
\&                          \-minimum_length   => 50,
\&                          \-include_singlets => 1  );
\& Function: Create a TIGR Assembler factory
\& Returns : A Bio::Tools::Run::TigrAssembler object
\& Args    :
.Ve
.PP
\&\s-1TIGR\s0 Assembler options available in this module:
.PP
.Vb 10
\&  minimum_percent / minimum_overlap_similarity: the minimum percent identity
\&    that two DNA fragments must achieve over their entire region of overlap in
\&    order to be considered as a possible assembly. Adjustments are made by the
\&    program to take into account that the ends of sequences are lower quality
\&    and doubled base calls are the most frequent sequencing error.
\&  minimum_length / minimum_overlap_length: the minimum length two DNA fragments
\&    must overlap to be considered as a possible assembly (warning: this option
\&    is not strictly respected by TIGR Assembler...)
\&  include_singlets: a flag which indicates that singletons (assemblies made up
\&    of a single DNA fragment) should be included in the lassie output_file \- the
\&    default is to not include singletons.
\&  max_err_32: the maximum number + 1 of alignment errors (mismatches or gaps)
\&    allowed within any contiguous 32 base pairs in the overlap region between
\&    two DNA fragments in the same assembly. This is meant to split apart splice
\&    variants which have short splice differences and would not be disqualified
\&    by the \-p minimum_percent parameter.
\&  consider_low_scores: a flag which causes even very LOW pairwise scores to be
\&    considered \- caution using this flag may cause longer run time and a worse
\&    assembly.
\&  maximum_end: the maximum length at the end of a DNA fragment that does not
\&    match another overlapping DNA fragment (sometimes referred to as overhang)
\&    that will not disqualify a DNA fragment from becoming part of an assembly.
\&  ignore_tandem_32mers: a flag which causes tandem 32mers (a tandem 32mer is a
\&    32mer which occurs more than once in at least one sequence read) to be
\&    ignored (this is now the default behavior and this flag is for backward
\&    compatibility)
\&  use_tandem_32mers: a flag which causes tandem 32mers to be used for pairwise
\&    comparison opposite of the \-t flag which is now the default).
\&  safe_merging_stop: a flag which causes merging to stop when only sequences
\&    which appear to be repeats are left and these cannot be merged based on
\&    clone length constraints.
\&  not_random: a flag which indicates that the DNA fragments in the input_file
\&    should not be treated as random genomic fragments for the purpose of
\&    determining repeat regions.
\&  resort_after: specifies how many sequences should be merged before resorting
\&    the possible merges based on clone constraints.
.Ve
.PP
\&\s-1LIGR\s0 Assembler has the same options as \s-1TIGR\s0 Assembler, and the following:
.PP
.Vb 3
\&  incl_bad_seq: keep all sequences including potential chimeras and splice variants
\&  trimmed_seq: indicates that the sequences are trimmed. High quality scores will be
\&    given on the whole sequence length instead of just in the middle)
.Ve
.SS "out_type"
.IX Subsection "out_type"
.Vb 8
\& Title   : out_type
\& Usage   : $factory\->out_type(\*(AqBio::Assembly::ScaffoldI\*(Aq)
\& Function: Get/set the desired type of output
\& Returns : The type of results to return
\& Args    : Desired type of results to return (optional):
\&                 \*(AqBio::Assembly::IO\*(Aq object
\&                 \*(AqBio::Assembly::ScaffoldI\*(Aq object (default)
\&                 The name of a file to save the results in
.Ve
.SS "run"
.IX Subsection "run"
.Vb 10
\& Title   :   run
\& Usage   :   $factory\->run($fasta_file);
\& Function:   Run TIGR Assembler
\& Returns :   \- a Bio::Assembly::ScaffoldI object, a Bio::Assembly::IO
\&               object, a filename, or undef if all sequences were too small to
\&               be usable
\& Returns :   Assembly results (file, IO object or assembly object)
\& Args    :   \- sequence input (FASTA file or sequence object arrayref)
\&             \- optional quality score input (QUAL file or quality score object
\&               arrayref)
.Ve
.SS "_run"
.IX Subsection "_run"
.Vb 6
\& Title   :   _run
\& Usage   :   $assembler\->_run()
\& Function:   Make a system call and run Newbler
\& Returns :   An assembly file
\& Args    :   \- FASTA file, SFF file and MID, or analysis dir and MID
\&             \- optional QUAL file
.Ve
.SS "_remove_small_sequences"
.IX Subsection "_remove_small_sequences"
.Vb 7
\& Title   :   _remove_small_sequences
\& Usage   :   $assembler\->_remove_small_sequences(\e@seqs, \e@quals)
\& Function:   Remove sequences below a threshold length
\& Returns :   a new sequence object array reference
\&             a new quality score object array reference
\& Args    :   sequence object array reference
\&             quality score object array reference (optional)
.Ve
