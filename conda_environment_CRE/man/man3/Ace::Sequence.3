.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Ace::Sequence 3"
.TH Ace::Sequence 3 "2004-12-01" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Ace::Sequence \- Examine ACeDB Sequence Objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # open database connection and get an Ace::Object sequence
\&    use Ace::Sequence;
\&
\&    $db  = Ace\->connect(\-host => \*(Aqstein.cshl.org\*(Aq,\-port => 200005);
\&    $obj = $db\->fetch(Predicted_gene => \*(AqZK154.3\*(Aq);
\&
\&    # Wrap it in an Ace::Sequence object 
\&    $seq = Ace::Sequence\->new($obj);
\&
\&    # Find all the exons
\&    @exons = $seq\->features(\*(Aqexon\*(Aq);
\&
\&    # Find all the exons predicted by various versions of "genefinder"
\&    @exons = $seq\->features(\*(Aqexon:genefinder.*\*(Aq);
\&
\&    # Iterate through the exons, printing their start, end and DNA
\&    for my $exon (@exons) {
\&      print join "\et",$exon\->start,$exon\->end,$exon\->dna,"\en";
\&    }
\&
\&    # Find the region 1000 kb upstream of the first exon
\&    $sub = Ace::Sequence\->new(\-seq=>$exons[0],
\&                              \-offset=>\-1000,\-length=>1000);
\&
\&    # Find all features in that area
\&    @features = $sub\->features;
\&
\&    # Print its DNA
\&    print $sub\->dna;
\&
\&    # Create a new Sequence object from the first 500 kb of chromosome 1
\&    $seq = Ace::Sequence\->new(\-name=>\*(AqCHROMOSOME_I\*(Aq,\-db=>$db,
\&                              \-offset=>0,\-length=>500_000);
\&
\&    # Get the GFF dump as a text string
\&    $gff = $seq\->gff;
\&
\&    # Limit dump to Predicted_genes
\&    $gff_genes = $seq\->gff(\-features=>\*(AqPredicted_gene\*(Aq);
\&
\&    # Return a GFF object (using optional GFF.pm module from Sanger)
\&    $gff_obj = $seq\->GFF;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIAce::Sequence\fR, and its allied classes Ace::Sequence::Feature and
Ace::Sequence::FeatureList, provide a convenient interface to the
ACeDB Sequence classes and the \s-1GFF\s0 sequence feature file format.
.PP
Using this class, you can define a region of the genome by using a
landmark (sequenced clone, link, superlink, predicted gene), an offset
from that landmark, and a distance.  Offsets and distances can be
positive or negative.  This will return an \fIAce::Sequence\fR object.
Once a region is defined, you may retrieve its \s-1DNA\s0 sequence, or query
the database for any features that may be contained within this
region.  Features can be returned as objects (using the
\&\fIAce::Sequence::Feature\fR class), as \s-1GFF\s0 text-only dumps, or in the
form of the \s-1GFF\s0 class defined by the Sanger Centre's \s-1GFF\s0.pm module.
.PP
This class builds on top of Ace and Ace::Object.  Please see
their manual pages before consulting this one.
.SH "Creating New Ace::Sequence Objects, the \fInew()\fP Method"
.IX Header "Creating New Ace::Sequence Objects, the new() Method"
.Vb 1
\& $seq = Ace::Sequence\->new($object);
\&
\& $seq = Ace::Sequence\->new(\-source  => $object,
\&                           \-offset  => $offset,
\&                           \-length  => $length,
\&                           \-refseq  => $reference_sequence);
\&
\& $seq = Ace::Sequence\->new(\-name    => $name,
\&                           \-db      => $db,
\&                           \-offset  => $offset,
\&                           \-length  => $length,
\&                           \-refseq  => $reference_sequence);
.Ve
.PP
In order to create an \fIAce::Sequence\fR you will need an active \fIAce\fR
database accessor.  Sequence regions are defined using a \*(L"source\*(R"
sequence, an offset, and a length.  Optionally, you may also provide a
\&\*(L"reference sequence\*(R" to establish the coordinate system for all
inquiries.  Sequences may be generated from existing \fIAce::Object\fR
sequence objects, from other \fIAce::Sequence\fR and
\&\fIAce::Sequence::Feature\fR objects, or from a sequence name and a
database handle.
.PP
The class method named \fInew()\fR is the interface to these facilities.  In
its simplest, one-argument form, you provide \fInew()\fR with a
previously-created \fIAce::Object\fR that points to Sequence or
sequence-like object (the meaning of \*(L"sequence-like\*(R" is explained in
more detail below.)  The \fInew()\fR method will return an \fIAce::Sequence\fR
object extending from the beginning of the object through to its
natural end.
.PP
In the named-parameter form of \fInew()\fR, the following arguments are
recognized:
.IP "\-source" 4
.IX Item "-source"
The sequence source.  This must be an \fIAce::Object\fR of the \*(L"Sequence\*(R" 
class, or be a sequence-like object containing the SMap tag (see
below).
.IP "\-offset" 4
.IX Item "-offset"
An offset from the beginning of the source sequence.  The retrieved
\&\fIAce::Sequence\fR will begin at this position.  The offset can be any
positive or negative integer.  Offets are \fB0\-based\fR.
.IP "\-length" 4
.IX Item "-length"
The length of the sequence to return.  Either a positive or negative
integer can be specified.  If a negative length is given, the returned 
sequence will be complemented relative to the source sequence.
.IP "\-refseq" 4
.IX Item "-refseq"
The sequence to use to establish the coordinate system for the
returned sequence.  Normally the source sequence is used to establish
the coordinate system, but this can be used to override that choice.
You can provide either an \fIAce::Object\fR or just a sequence name for
this argument.  The source and reference sequences must share a common
ancestor, but do not have to be directly related.  An attempt to use a
disjunct reference sequence, such as one on a different chromosome,
will fail.
.IP "\-name" 4
.IX Item "-name"
As an alternative to using an \fIAce::Object\fR with the \fB\-source\fR
argument, you may specify a source sequence using \fB\-name\fR and \fB\-db\fR.
The \fIAce::Sequence\fR module will use the provided database accessor to
fetch a Sequence object with the specified name. \fInew()\fR will return
undef is no Sequence by this name is known.
.IP "\-db" 4
.IX Item "-db"
This argument is required if the source sequence is specified by name
rather than by object reference.
.PP
If \fInew()\fR is successful, it will create an \fIAce::Sequence\fR object and
return it.  Otherwise it will return undef and return a descriptive
message in Ace\->\fIerror()\fR.  Certain programming errors, such as a
failure to provide required arguments, cause a fatal error.
.SS "Reference Sequences and the Coordinate System"
.IX Subsection "Reference Sequences and the Coordinate System"
When retrieving information from an \fIAce::Sequence\fR, the coordinate
system is based on the sequence segment selected at object creation
time.  That is, the \*(L"+1\*(R" strand is the natural direction of the
\&\fIAce::Sequence\fR object, and base pair 1 is its first base pair.  This
behavior can be overridden by providing a reference sequence to the
\&\fInew()\fR method, in which case the orientation and position of the
reference sequence establishes the coordinate system for the object.
.PP
In addition to the reference sequence, there are two other sequences
used by \fIAce::Sequence\fR for internal bookeeping.  The \*(L"source\*(R"
sequence corresponds to the smallest ACeDB sequence object that
completely encloses the selected sequence segment.  The \*(L"parent\*(R"
sequence is the smallest ACeDB sequence object that contains the
\&\*(L"source\*(R".  The parent is used to derive the length and orientation of
source sequences that are not directly associated with \s-1DNA\s0 objects.
.PP
In many cases, the source sequence will be identical to the sequence
initially passed to the \fInew()\fR method.  However, there are exceptions
to this rule.  One common exception occurs when the offset and/or
length cross the boundaries of the passed-in sequence.  In this case,
the ACeDB database is searched for the smallest sequence that contains 
both endpoints of the \fIAce::Sequence\fR object.
.PP
The other common exception occurs in Ace 4.8, where there is support
for \*(L"sequence-like\*(R" objects that contain the \f(CW\*(C`SMap\*(C'\fR (\*(L"Sequence Map\*(R")
tag.  The \f(CW\*(C`SMap\*(C'\fR tag provides genomic location information for
arbitrary object \*(-- not just those descended from the Sequence class.
This allows ACeDB to perform genome map operations on objects that are
not directly related to sequences, such as genetic loci that have been
interpolated onto the physical map.  When an \f(CW\*(C`SMap\*(C'\fR\-containing object
is passed to the \fIAce::Sequence\fR \fInew()\fR method, the module will again
choose the smallest ACeDB Sequence object that contains both
end-points of the desired region.
.PP
If an \fIAce::Sequence\fR object is used to create a new \fIAce::Sequence\fR
object, then the original object's source is inherited.
.SH "Object Methods"
.IX Header "Object Methods"
Once an \fIAce::Sequence\fR object is created, you can query it using the
following methods:
.SS "\fIasString()\fP"
.IX Subsection "asString()"
.Vb 1
\&  $name = $seq\->asString;
.Ve
.PP
Returns a human-readable identifier for the sequence in the form
\&\fISource/start\-end\fR, where \*(L"Source\*(R" is the name of the source
sequence, and \*(L"start\*(R" and \*(L"end\*(R" are the endpoints of the sequence
relative to the source (using 1\-based indexing).  This method is
called automatically when the \fIAce::Sequence\fR is used in a string
context.
.SS "\fIsource_seq()\fP"
.IX Subsection "source_seq()"
.Vb 1
\&  $source = $seq\->source_seq;
.Ve
.PP
Return the source of the \fIAce::Sequence\fR.
.SS "\fIparent_seq()\fP"
.IX Subsection "parent_seq()"
.Vb 1
\&  $parent = $seq\->parent_seq;
.Ve
.PP
Return the immediate ancestor of the sequence.  The parent of the
top-most sequence (such as the \s-1CHROMOSOME\s0 link) is itself.  This
method is used internally to ascertain the length of source sequences
which are not associated with a \s-1DNA\s0 object.
.PP
\&\s-1NOTE:\s0 this procedure is a trifle funky and cannot reliably be used to
traverse upwards to the top-most sequence.  The reason for this is
that it will return an \fIAce::Sequence\fR in some cases, and an
\&\fIAce::Object\fR in others.  Use \fIget_parent()\fR to traverse upwards
through a uniform series of \fIAce::Sequence\fR objects upwards.
.SS "refseq([$seq])"
.IX Subsection "refseq([$seq])"
.Vb 1
\&  $refseq = $seq\->refseq;
.Ve
.PP
Returns the reference sequence, if one is defined.
.PP
.Vb 1
\&  $seq\->refseq($new_ref);
.Ve
.PP
Set the reference sequence. The reference sequence must share the same
ancestor with \f(CW$seq\fR.
.SS "\fIstart()\fP"
.IX Subsection "start()"
.Vb 1
\&  $start = $seq\->start;
.Ve
.PP
Start of this sequence, relative to the source sequence, using 1\-based
indexing.
.SS "\fIend()\fP"
.IX Subsection "end()"
.Vb 1
\&  $end = $seq\->end;
.Ve
.PP
End of this sequence, relative to the source sequence, using 1\-based
indexing.
.SS "\fIoffset()\fP"
.IX Subsection "offset()"
.Vb 1
\&  $offset = $seq\->offset;
.Ve
.PP
Offset of the beginning of this sequence relative to the source
sequence, using 0\-based indexing.  The offset may be negative if the
beginning of the sequence is to the left of the beginning of the
source sequence.
.SS "\fIlength()\fP"
.IX Subsection "length()"
.Vb 1
\&  $length = $seq\->length;
.Ve
.PP
The length of this sequence, in base pairs.  The length may be
negative if the sequence's orientation is reversed relative to the
source sequence.  Use \fIabslength()\fR to obtain the absolute value of
the sequence length.
.SS "\fIabslength()\fP"
.IX Subsection "abslength()"
.Vb 1
\&  $length = $seq\->abslength;
.Ve
.PP
Return the absolute value of the length of the sequence.
.SS "\fIstrand()\fP"
.IX Subsection "strand()"
.Vb 1
\&  $strand = $seq\->strand;
.Ve
.PP
Returns +1 for a sequence oriented in the natural direction of the
genomic reference sequence, or \-1 otherwise.
.SS "\fIreversed()\fP"
.IX Subsection "reversed()"
Returns true if the segment is reversed relative to the canonical
genomic direction.  This is the same as \f(CW$seq\fR\->strand < 0.
.SS "\fIdna()\fP"
.IX Subsection "dna()"
.Vb 1
\&  $dna = $seq\->dna;
.Ve
.PP
Return the \s-1DNA\s0 corresponding to this sequence.  If the sequence length
is negative, the reverse complement of the appropriate segment will be
returned.
.PP
ACeDB allows Sequences to exist without an associated \s-1DNA\s0 object
(which typically happens during intermediate stages of a sequencing
project.  In such a case, the returned sequence will contain the
correct number of \*(L"\-\*(R" characters.
.SS "\fIname()\fP"
.IX Subsection "name()"
.Vb 1
\&  $name = $seq\->name;
.Ve
.PP
Return the name of the source sequence as a string.
.SS "\fIget_parent()\fP"
.IX Subsection "get_parent()"
.Vb 1
\&  $parent = $seq\->parent;
.Ve
.PP
Return the immediate ancestor of this \fIAce::Sequence\fR (i.e., the
sequence that contains this one).  The return value is a new
\&\fIAce::Sequence\fR or undef, if no parent sequence exists.
.SS "\fIget_children()\fP"
.IX Subsection "get_children()"
.Vb 1
\&  @children = $seq\->get_children();
.Ve
.PP
Returns all subsequences that exist as independent objects in the
ACeDB database.  What exactly is returned is dependent on the data
model.  In older ACeDB databases, the only subsequences are those
under the catchall Subsequence tag.  In newer ACeDB databases, the
objects returned correspond to objects to the right of the S_Child
subtag using a tag[2] syntax, and may include Predicted_genes,
Sequences, Links, or other objects.  The return value is a list of
\&\fIAce::Sequence\fR objects.
.SS "\fIfeatures()\fP"
.IX Subsection "features()"
.Vb 3
\&  @features = $seq\->features;
\&  @features = $seq\->features(\*(Aqexon\*(Aq,\*(Aqintron\*(Aq,\*(AqPredicted_gene\*(Aq);
\&  @features = $seq\->features(\*(Aqexon:GeneFinder\*(Aq,\*(AqPredicted_gene:hand.*\*(Aq);
.Ve
.PP
\&\fIfeatures()\fR returns an array of \fISequence::Feature\fR objects.  If
called without arguments, \fIfeatures()\fR returns all features that cross
the sequence region.  You may also provide a filter list to select a
set of features by type and subtype.  The format of the filter list
is:
.PP
.Vb 1
\&  type:subtype
.Ve
.PP
Where \fItype\fR is the class of the feature (the \*(L"feature\*(R" field of the
\&\s-1GFF\s0 format), and \fIsubtype\fR is a description of how the feature was
derived (the \*(L"source\*(R" field of the \s-1GFF\s0 format).  Either of these
fields can be absent, and either can be a regular expression.  More
advanced filtering is not supported, but is provided by the Sanger
Centre's \s-1GFF\s0 module.
.PP
The order of the features in the returned list is not specified.  To
obtain features sorted by position, use this idiom:
.PP
.Vb 1
\&  @features = sort { $a\->start <=> $b\->start } $seq\->features;
.Ve
.SS "\fIfeature_list()\fP"
.IX Subsection "feature_list()"
.Vb 1
\&  my $list = $seq\->feature_list();
.Ve
.PP
This method returns a summary list of the features that cross the
sequence in the form of a Ace::Feature::List object.  From the
Ace::Feature::List object you can obtain the list of feature names
and the number of each type.  The feature list is obtained from the
ACeDB server with a single short transaction, and therefore has much
less overhead than \fIfeatures()\fR.
.PP
See Ace::Feature::List for more details.
.SS "\fItranscripts()\fP"
.IX Subsection "transcripts()"
This returns a list of Ace::Sequence::Transcript objects, which are
specializations of Ace::Sequence::Feature.  See Ace::Sequence::Transcript
for details.
.SS "\fIclones()\fP"
.IX Subsection "clones()"
This returns a list of Ace::Sequence::Feature objects containing
reconstructed clones.  This is a nasty hack, because \s-1ACEDB\s0 currently
records clone ends, but not the clones themselves, meaning that we
will not always know both ends of the clone.  In this case the missing
end has a synthetic position of \-99,999,999 or +99,999,999.  Sorry.
.SS "\fIgff()\fP"
.IX Subsection "gff()"
.Vb 3
\&  $gff = $seq\->gff();
\&  $gff = $seq\->gff(\-abs      => 1,
\&                   \-features => [\*(Aqexon\*(Aq,\*(Aqintron:GeneFinder\*(Aq]);
.Ve
.PP
This method returns a \s-1GFF\s0 file as a scalar.  The following arguments
are optional:
.IP "\-abs" 4
.IX Item "-abs"
Ordinarily the feature entries in the \s-1GFF\s0 file will be returned in
coordinates relative to the start of the \fIAce::Sequence\fR object.
Position 1 will be the start of the sequence object, and the \*(L"+\*(R"
strand will be the sequence object's natural orientation.  However if
a true value is provided to \fB\-abs\fR, the coordinate system used will
be relative to the start of the source sequence, i.e. the native ACeDB
Sequence object (usually a cosmid sequence or a link).
.Sp
If a reference sequence was provided when the \fIAce::Sequence\fR was
created, it will be used by default to set the coordinate system.
Relative coordinates can be reenabled by providing a false value to
\&\fB\-abs\fR.
.Sp
Ordinarily the coordinate system manipulations automatically \*(L"do what
you want\*(R" and you will not need to adjust them.  See also the \fIabs()\fR
method described below.
.IP "\-features" 4
.IX Item "-features"
The \fB\-features\fR argument filters the features according to a list of
types and subtypes.  The format is identical to the one described for
the \fIfeatures()\fR method.  A single filter may be provided as a scalar
string.  Multiple filters may be passed as an array reference.
.PP
See also the \s-1\fIGFF\s0()\fR method described next.
.SS "\s-1\fIGFF\s0()\fP"
.IX Subsection "GFF()"
.Vb 3
\&  $gff_object = $seq\->gff;
\&  $gff_object = $seq\->gff(\-abs      => 1,
\&                   \-features => [\*(Aqexon\*(Aq,\*(Aqintron:GeneFinder\*(Aq]);
.Ve
.PP
The \s-1\fIGFF\s0()\fR method takes the same arguments as \fIgff()\fR described above,
but it returns a \fIGFF::GeneFeatureSet\fR object from the \s-1GFF\s0.pm
module.  If the \s-1GFF\s0 module is not installed, this method will generate 
a fatal error.
.SS "\fIabsolute()\fP"
.IX Subsection "absolute()"
.Vb 2
\& $abs = $seq\->absolute;
\& $abs = $seq\->absolute(1);
.Ve
.PP
This method controls whether the coordinates of features are returned
in absolute or relative coordinates.  \*(L"Absolute\*(R" coordinates are
relative to the underlying source or reference sequence.  \*(L"Relative\*(R"
coordinates are relative to the \fIAce::Sequence\fR object.  By default,
coordinates are relative unless \fInew()\fR was provided with a reference
sequence.  This default can be examined and changed using \fIabsolute()\fR.
.SS "\fIautomerge()\fP"
.IX Subsection "automerge()"
.Vb 2
\&  $merge = $seq\->automerge;
\&  $seq\->automerge(0);
.Ve
.PP
This method controls whether groups of features will automatically be
merged together by the \fIfeatures()\fR call.  If true (the default), then
the left and right end of clones will be merged into \*(L"clone\*(R" features,
introns, exons and \s-1CDS\s0 entries will be merged into
Ace::Sequence::Transcript objects, and similarity entries will be
merged into Ace::Sequence::GappedAlignment objects.
.SS "\fIdb()\fP"
.IX Subsection "db()"
.Vb 1
\&  $db = $seq\->db;
.Ve
.PP
Returns the Ace database accessor associated with this sequence.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Ace, Ace::Object, Ace::Sequence::Feature,
Ace::Sequence::FeatureList, \s-1GFF\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs\-mop.fr>
.PP
Many thanks to David Block <dblock@gene.pbi.nrc.ca> for finding and
fixing the nasty off-by-one errors.
.PP
Copyright (c) 1999, Lincoln D. Stein
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  See \s-1DISCLAIMER\s0.txt for
disclaimers of warranty.
