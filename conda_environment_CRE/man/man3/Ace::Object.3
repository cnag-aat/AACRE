.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Ace::Object 3"
.TH Ace::Object 3 "2005-04-20" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Ace::Object \- Manipulate  Ace Data Objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    # open database connection and get an object
\&    use Ace;
\&    $db = Ace\->connect(\-host => \*(Aqbeta.crbm.cnrs\-mop.fr\*(Aq,
\&                       \-port => 20000100);
\&    $sequence  = $db\->fetch(Sequence => \*(AqD12345\*(Aq);
\&    
\&    # Inspect the object
\&    $r    = $sequence\->at(\*(AqVisible.Overlap_Right\*(Aq);
\&    @row  = $sequence\->row;
\&    @col  = $sequence\->col;
\&    @tags = $sequence\->tags;
\&    
\&    # Explore object substructure
\&    @more_tags = $sequence\->at(\*(AqVisible\*(Aq)\->tags;
\&    @col       = $sequence\->at("Visible.$more_tags[1]")\->col;
\&
\&    # Follow a pointer into database
\&    $r     = $sequence\->at(\*(AqVisible.Overlap_Right\*(Aq)\->fetch;
\&    $next  = $r\->at(\*(AqVisible.Overlap_left\*(Aq)\->fetch;
\&
\&    # Classy way to do the same thing
\&    $r     = $sequence\->Overlap_right;
\&    $next  = $sequence\->Overlap_left;
\&
\&    # Pretty\-print object
\&    print $sequence\->asString;
\&    print $sequence\->asTabs;
\&    print $sequence\->asHTML;
\&
\&    # Update object
\&    $sequence\->replace(\*(AqVisible.Overlap_Right\*(Aq,$r,\*(AqM55555\*(Aq);
\&    $sequence\->add(\*(AqVisible.Homology\*(Aq,\*(AqGR91198\*(Aq);
\&    $sequence\->delete(\*(AqSource.Clone\*(Aq,\*(AqMBR122\*(Aq);
\&    $sequence\->commit();
\&
\&    # Rollback changes
\&    $sequence\->rollback()
\&
\&    # Get errors
\&    print $sequence\->error;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIAce::Object\fR is the base class for objects returned from \s-1ACEDB\s0
databases. Currently there is only one type of \fIAce::Object\fR, but
this may change in the future to support more interesting
object-specific behaviors.
.PP
Using the \fIAce::Object\fR interface, you can explore the internal
structure of an \fIAce::Object\fR, retrieve its content, and convert it
into various types of text representation.  You can also fetch a
representation of any object as a \s-1GIF\s0 image.
.PP
If you have write access to the databases, add new data to an object,
replace existing data, or kill it entirely.  You can also create a new
object de novo and write it into the database.
.PP
For information on connecting to \s-1ACEDB\s0 databases and querying them,
see Ace.
.SH "ACEDB::OBJECT METHODS"
.IX Header "ACEDB::OBJECT METHODS"
The structure of an Ace::Object is very similar to that of an Acedb
object.  It is a tree structure like this one (an Author object):
.PP
.Vb 10
\& Thierry\-Mieg J\->Full_name \->Jean Thierry\-Mieg
\&                  |
\&                 Laboratory\->FF
\&                  |
\&                 Address\->Mail\->CRBM duCNRS
\&                  |        |     |
\&                  |        |    BP 5051
\&                  |        |     |
\&                  |        |    34033 Montpellier
\&                  |        |     |
\&                  |        |    FRANCE
\&                  |        |
\&                  |       E_mail\->mieg@kaa.cnrs\-mop.fr
\&                  |        |
\&                  |       Phone \->33\-67\-613324
\&                  |        |
\&                  |       Fax   \->33\-67\-521559
\&                  |
\&                 Paper\->The C. elegans sequencing project
\&                         |
\&                        Genome Project Database
\&                         |
\&                        Genome Sequencing
\&                         |
\&                         How to get ACEDB for your Sun
\&                         |
\&                        ACEDB is Hungry
.Ve
.PP
Each object in the tree has two pointers, a \*(L"right\*(R" pointer to the
node on its right, and a \*(L"down\*(R" pointer to the node beneath it.  Right
pointers are used to store hierarchical relationships, such as
Address\->Mail\->E_mail, while down pointers are used to store lists,
such as the multiple papers written by the Author.
.PP
Each node in the tree has a type and a name.  Types include integers,
strings, text, floating point numbers, as well as specialized
biological types, such as \*(L"dna\*(R" and \*(L"peptide.\*(R"  Another fundamental
type is \*(L"tag,\*(R" which is a text identifier used to label portions of
the tree.  Examples of tags include \*(L"Paper\*(R" and \*(L"Laboratory\*(R" in the
example above.
.PP
In addition to these built-in types, there are constructed types known
as classes.  These types are specified by the data model.  In the
above example, \*(L"Thierry-Mieg J\*(R" is an object of the \*(L"Author\*(R" class,
and \*(L"Genome Project Database\*(R" is an object of the \*(L"Paper\*(R" class.  An
interesting feature of objects is that you can follow them into the
database, retrieving further information.  For example, after
retrieving the \*(L"Genome Project Database\*(R" Paper from the Author object,
you could fetch more information about it, either by following \fBits\fR
right pointer, or by using one of the specialized navigation routines
described below.
.SS "\fInew()\fP method"
.IX Subsection "new() method"
.Vb 4
\&    $object = new Ace::Object($class,$name,$database);
\&    $object = new Ace::Object(\-class=>$class,
\&                              \-name=>$name,
\&                              \-db=>database);
.Ve
.PP
You can create a new Ace::Object from scratch by calling the \fInew()\fR
routine with the object's class, its identifier and a handle to the
database to create it in.  The object won't actually be created in the
database until you \fIadd()\fR one or more tags to it and \fIcommit()\fR it (see
below).  If you do not provide a database handle, the object will be
created in memory only.
.PP
Arguments can be passed positionally, or as named parameters, as shown
above.
.PP
This routine is usually used internally.  See also \fIadd_row()\fR,
\&\fIadd_tree()\fR, \fIdelete()\fR and \fIreplace()\fR for ways to manipulate this object.
.SS "\fIname()\fP method"
.IX Subsection "name() method"
.Vb 1
\&    $name = $object\->name();
.Ve
.PP
Return the name of the Ace::Object.  This happens automatically
whenever you use the object in a context that requires a string or a
number.  For example:
.PP
.Vb 2
\&    $object = $db\->fetch(Author,"Thierry\-Mieg J");
\&    print "$object did not write \*(AqPride and Prejudice.\*(Aq\en";
.Ve
.SS "\fIclass()\fP method"
.IX Subsection "class() method"
.Vb 1
\&    $class = $object\->class();
.Ve
.PP
Return the class of the object.  The return value may be one of
\&\*(L"float,\*(R" \*(L"int,\*(R" \*(L"date,\*(R" \*(L"tag,\*(R" \*(L"txt,\*(R" \*(L"dna,\*(R" \*(L"peptide,\*(R" and \*(L"scalar.\*(R"
(The last is used internally by Perl to represent objects created
programatically prior to committing them to the database.)  The class
may also be a user-constructed type such as Sequence, Clone or
Author.  These user-constructed types usually have an initial capital
letter.
.SS "\fIdb()\fP method"
.IX Subsection "db() method"
.Vb 1
\&     $db = $object\->db();
.Ve
.PP
Return the database that the object is associated with.
.SS "\fIisClass()\fP method"
.IX Subsection "isClass() method"
.Vb 1
\&     $bool = $object\->isClass();
.Ve
.PP
Returns true if the object is a class (can be fetched from the
database).
.SS "\fIisTag()\fP method"
.IX Subsection "isTag() method"
.Vb 1
\&     $bool = $object\->isTag();
.Ve
.PP
Returns true if the object is a tag.
.SS "\fItags()\fP method"
.IX Subsection "tags() method"
.Vb 1
\&     @tags = $object\->tags();
.Ve
.PP
Return all the top-level tags in the object as a list.  In the Author
example above, the returned list would be
('Full_name','Laboratory','Address','Paper').
.PP
You can fetch tags more deeply nested in the structure by navigating
inwards using the methods listed below.
.SS "\fIright()\fP and \fIdown()\fP methods"
.IX Subsection "right() and down() methods"
.Vb 4
\&     $subtree = $object\->right;
\&     $subtree = $object\->right($position);      
\&     $subtree = $object\->down;
\&     $subtree = $object\->down($position);
.Ve
.PP
\&\fB\f(BIright()\fB\fR and \fB\f(BIdown()\fB\fR provide a low-level way of traversing the
tree structure by following the tree's right and down pointers.
Called without any arguments, these two methods will move one step.
Called with a numeric argument >= 0 they will move the indicated
number of steps (zero indicates no movement).
.PP
.Vb 2
\&     $full_name = $object\->right\->right;
\&     $full_name = $object\->right(2);
\&
\&     $city = $object\->right\->down\->down\->right\->right\->down\->down;
\&     $city = $object\->right\->down(2)\->right(2)\->down(2);
.Ve
.PP
If \f(CW$object\fR contains the \*(L"Thierry-Mieg J\*(R" Author object, then the first
series of accesses shown above retrieves the string \*(L"Jean
Thierry-Mieg\*(R" and the second retrieves \*(L"34033 Montpellier.\*(R"  If the
right or bottom pointers are \s-1NULL,\s0 these methods will return undef.
.PP
In addition to being somewhat awkard, you will probably never need to
use these methods.  A simpler way to retrieve the same information
would be to use the \fIat()\fR method described in the next section.
.PP
The \fIright()\fR and \fIdown()\fR methods always walk through the tree of the
current object.  They do not follow object pointers into the database.
Use \fB\f(BIfetch()\fB\fR (or the deprecated \fB\f(BIpick()\fB\fR or \fB\f(BIfollow()\fB\fR methods)
instead.
.SS "\fIat()\fP method"
.IX Subsection "at() method"
.Vb 2
\&    $subtree    = $object\->at($tag_path);
\&    @values     = $object\->at($tag_path);
.Ve
.PP
\&\fIat()\fR is a simple way to fetch the portion of the tree that you are
interested in.  It takes a single argument, a simple tag or a path.  A
simple tag, such as \*(L"Full_name\*(R", must correspond to a tag in the
column immediately to the right of the root of the tree.  A path such
as \*(L"Address.Mail\*(R" is a dot-delimited path to the subtree.  Some
examples are given below.
.PP
.Vb 2
\&    ($full_name)   = $object\->at(\*(AqFull_name\*(Aq);
\&    @address_lines = $object\->at(\*(AqAddress.Mail\*(Aq);
.Ve
.PP
The second line above is equivalent to:
.PP
.Vb 1
\&    @address = $object\->at(\*(AqAddress\*(Aq)\->at(\*(AqMail\*(Aq);
.Ve
.PP
Called without a tag name, \fIat()\fR just dereferences the object,
returning whatever is to the right of it, the same as
\&\f(CW$object\fR\->right
.PP
If a path component already has a dot in it, you may escape the dot
with a backslash, as in:
.PP
.Vb 2
\&    $s=$db\->fetch(\*(AqSequence\*(Aq,\*(AqM4\*(Aq);
\&    @homologies = $s\->at(\*(AqHomol.DNA_homol.yk192f7\e.3\*(Aq;
.Ve
.PP
This also demonstrates that path components don't necessarily have to
be tags, although in practice they usually are.
.PP
\&\fIat()\fR returns slightly different results depending on the context in
which it is called.  In a list context, it returns the column of
values to the \fBright\fR of the tag.  However, in a scalar context, it
returns the subtree rooted at the tag.  To appreciate the difference,
consider these two cases:
.PP
.Vb 2
\&    $name1   = $object\->at(\*(AqFull_name\*(Aq);
\&    ($name2) = $object\->at(\*(AqFull_name\*(Aq);
.Ve
.PP
After these two statements run, \f(CW$name1\fR will be the tag object named
\&\*(L"Full_name\*(R", and \f(CW$name2\fR will be the text object \*(L"Jean Thierry-Mieg\*(R",
The relationship between the two is that \f(CW$name1\fR\->right leads to
\&\f(CW$name2\fR.  This is a powerful and useful construct, but it can be a trap
for the unwary.  If this behavior drives you crazy, use this
construct:
.PP
.Vb 1
\&    $name1   = $object\->at(\*(AqFull_name\*(Aq)\->at();
.Ve
.PP
For finer control over navigation, path components can include
optional indexes to indicate navigation to the right of the current
path component.  Here is the syntax:
.PP
.Vb 1
\&    $object\->at(\*(Aqtag1[index1].tag2[index2].tag3[index3]...\*(Aq);
.Ve
.PP
Indexes are zero-based.  An index of [0] indicates no movement
relative to the current component, and is the same as not using an
index at all.  An index of [1] navigates one step to the right, [2]
moves two steps to the right, and so on.  Using the Thierry-Mieg
object as an example again, here are the results of various indexes:
.PP
.Vb 4
\&    $object = $db\->fetch(Author,"Thierry\-Mieg J");
\&    $a = $object\->at(\*(AqAddress[0]\*(Aq)   \-\-> "Address"
\&    $a = $object\->at(\*(AqAddress[1]\*(Aq)   \-\-> "Mail"
\&    $a = $object\->at(\*(AqAddress[2]\*(Aq)   \-\-> "CRBM duCNRS"
.Ve
.PP
In an array context, the last index in the path does something very
interesting.  It returns the entire column of data K steps to the
right of the path, where K is the index.  This is used to implement
so-called \*(L"tag[2]\*(R" syntax, and is very useful in some circumstances.
For example, here is a fragment of code to return the Thierry-Mieg
object's full address without having to refer to each of the
intervening \*(L"Mail\*(R", \*(L"E_Mail\*(R" and \*(L"Phone\*(R" tags explicitly.
.PP
.Vb 3
\&   @address = $object\->at(\*(AqAddress[2]\*(Aq);
\&   \-\-> (\*(AqCRBM duCNRS\*(Aq,\*(AqBP 5051\*(Aq,\*(Aq34033 Montpellier\*(Aq,\*(AqFRANCE\*(Aq,
\&        \*(Aqmieg@kaa.cnrs\-mop.fr,\*(Aq33\-67\-613324\*(Aq,\*(Aq33\-67\-521559\*(Aq)
.Ve
.PP
Similarly, \*(L"tag[3]\*(R" will return the column of data three hops to the
right of the tag.  \*(L"tag[1]\*(R" is identical to \*(L"tag\*(R" (with no index), and
will return the column of data to the immediate right.  There is no
special behavior associated with using \*(L"tag[0]\*(R" in an array context;
it will always return the subtree rooted at the indicated tag.
.PP
Internal indices such as \*(L"Homol[2].BLASTN\*(R", do not have special
behavior in an array context.  They are always treated as if they were
called in a scalar context.
.PP
Also see \fB\f(BIcol()\fB\fR and \fB\f(BIget()\fB\fR.
.SS "\fIget()\fP method"
.IX Subsection "get() method"
.Vb 4
\&    $subtree    = $object\->get($tag);
\&    @values     = $object\->get($tag);
\&    @values     = $object\->get($tag, $position);
\&    @values     = $object\->get($tag => $subtag, $position);
.Ve
.PP
The \fIget()\fR method will perform a breadth-first search through the
object (columns first, followed by rows) for the tag indicated by the
argument, returning the column of the portion of the subtree it points
to.  For example, this code fragment will return the value of the
\&\*(L"Fax\*(R" tag.
.PP
.Vb 2
\&    ($fax_no) = $object\->get(\*(AqFax\*(Aq);
\&         \-\-> "33\-67\-521559"
.Ve
.PP
The list versus scalar context semantics are the same as in \fIat()\fR, so
if you want to retrieve the scalar value pointed to by the indicated
tag, either use a list context as shown in the example, above, or a
dereference, as in:
.PP
.Vb 4
\&     $fax_no = $object\->get(\*(AqFax\*(Aq);
\&         \-\-> "Fax"
\&     $fax_no = $object\->get(\*(AqFax\*(Aq)\->at;
\&         \-\-> "33\-67\-521559"
.Ve
.PP
An optional second argument to \fB\f(BIget()\fB\fR, \f(CW$position\fR, allows you to
navigate the tree relative to the retrieved subtree.  Like the \fB\f(BIat()\fB\fR
navigational indexes, \f(CW$position\fR must be a number greater than or equal
to zero.  In a scalar context, \f(CW$position\fR moves rightward through the
tree.  In an array context, \f(CW$position\fR implements \*(L"tag[2]\*(R" semantics.
.PP
For example:
.PP
.Vb 2
\&     $fax_no = $object\->get(\*(AqFax\*(Aq,0);
\&          \-\-> "Fax"
\&
\&     $fax_no = $object\->get(\*(AqFax\*(Aq,1);
\&          \-\-> "33\-67\-521559"
\&
\&     $fax_no = $object\->get(\*(AqFax\*(Aq,2);
\&          \-\-> undef  # nothing beyond the fax number
\&
\&     @address = $object\->get(\*(AqAddress\*(Aq,2);
\&          \-\-> (\*(AqCRBM duCNRS\*(Aq,\*(AqBP 5051\*(Aq,\*(Aq34033 Montpellier\*(Aq,\*(AqFRANCE\*(Aq,
\&               \*(Aqmieg@kaa.cnrs\-mop.fr,\*(Aq33\-67\-613324\*(Aq,\*(Aq33\-67\-521559\*(Aq)
.Ve
.PP
It is important to note that \fB\f(BIget()\fB\fR only traverses tags.  It will
not traverse nodes that aren't tags, such as strings, integers or
objects.  This is in keeping with the behavior of the Ace query
language \*(L"show\*(R" command.
.PP
This restriction can lead to confusing results.  For example, consider
the following object:
.PP
.Vb 10
\& Clone: B0280  Position    Map            Sequence\-III  Ends   Left   3569
\&                                                               Right  3585
\&                           Pmap           ctg377        \-1040  \-1024
\&               Positive    Positive_locus nhr\-10
\&               Sequence    B0280
\&               Location    RW
\&               FingerPrint Gel_Number     0
\&                           Canonical_for  T20H1
\&                                          K10E5
\&                           Bands          1354          18
.Ve
.PP
The following attempt to fetch the left and right positions of the
clone will fail, because the search for the \*(L"Left\*(R" and \*(L"Right\*(R" tags
cannot traverse \*(L"Sequence-III\*(R", which is an object, not a tag:
.PP
.Vb 2
\&  my $left = $clone\->get(\*(AqLeft\*(Aq);    # will NOT work
\&  my $right = $clone\->get(\*(AqRight\*(Aq);  # neither will this one
.Ve
.PP
You must explicitly step over the non-tag node in order to make this
query work.  This syntax will work:
.PP
.Vb 2
\&  my $left = $clone\->get(\*(AqMap\*(Aq,1)\->get(\*(AqLeft\*(Aq);   # works
\&  my $left = $clone\->get(\*(AqMap\*(Aq,1)\->get(\*(AqRight\*(Aq);  # works
.Ve
.PP
Or you might prefer to use the tag[2] syntax here:
.PP
.Vb 1
\&  my($left,$right) = $clone\->get(\*(AqMap\*(Aq,1)\->at(\*(AqEnds[2]\*(Aq);
.Ve
.PP
Although not frequently used, there is a form of \fIget()\fR which allows
you to stack subtags:
.PP
.Vb 1
\&    $locus = $object\->get(\*(AqPositive\*(Aq=>\*(AqPositive_locus\*(Aq);
.Ve
.PP
Only on subtag is allowed.  You can follow this by a position if wish
to offset from the subtag.
.PP
.Vb 1
\&    $locus = $object\->get(\*(AqPositive\*(Aq=>\*(AqPositive_locus\*(Aq,1);
.Ve
.SS "\fIsearch()\fP method"
.IX Subsection "search() method"
This is a deprecated synonym for \fIget()\fR.
.SS "Autogenerated Access Methods"
.IX Subsection "Autogenerated Access Methods"
.Vb 6
\&     $scalar = $object\->Name_of_tag;
\&     $scalar = $object\->Name_of_tag($position);
\&     @array  = $object\->Name_of_tag;
\&     @array  = $object\->Name_of_tag($position);
\&     @array  = $object\->Name_of_tag($subtag=>$position);
\&     @array  = $object\->Name_of_tag(\-fill=>$tag);
.Ve
.PP
The module attempts to autogenerate data access methods as needed.
For example, if you refer to a method named \*(L"Fax\*(R" (which doesn't
correspond to any of the built-in methods), then the code will call
the \fB\f(BIget()\fB\fR method to find a tag named \*(L"Fax\*(R" and return its
contents.
.PP
Unlike \fIget()\fR, this method will \fBalways step into objects\fR.  This
means that:
.PP
.Vb 1
\&   $map = $clone\->Map;
.Ve
.PP
will return the Sequence_Map object pointed to by the Clone's Map tag
and not simply a pointer to a portion of the Clone tree.  Therefore
autogenerated methods are functionally equivalent to the following:
.PP
.Vb 1
\&   $map = $clone\->get(\*(AqMap\*(Aq)\->fetch;
.Ve
.PP
The scalar context semantics are also slightly different.  In a scalar
context, the autogenerated function will *always* move one step to the
right.
.PP
The list context semantics are identical to \fIget()\fR.  If you want to
dereference all members of a multivalued tag, you have to do so manually:
.PP
.Vb 5
\&  @papers = $author\->Paper;
\&  foreach (@papers) { 
\&    my $paper = $_\->fetch;
\&    print  $paper\->asString;
\&  }
.Ve
.PP
You can provide an optional positional index to rapidly navigate
through the tree or to obtain tag[2] behavior.  In the following
examples, the first two return the object's Fax number, and the third
returns all data two hops to the right of Address.
.PP
.Vb 4
\&     $object   = $db\->fetch(Author => \*(AqThierry\-Mieg J\*(Aq);
\&     ($fax_no) = $object\->Fax;
\&     $fax_no   = $object\->Fax(1);
\&     @address  = $object\->Address(2);
.Ve
.PP
You may also position at a subtag, using this syntax:
.PP
.Vb 1
\&     $representative = $object\->Laboratory(\*(AqRepresentative\*(Aq);
.Ve
.PP
Both named tags and positions can be combined as follows:
.PP
.Vb 1
\&     $lab_address = $object\->Laboratory(Address=>2);
.Ve
.PP
If you provide a \-fill=>$tag argument, then the object fetch will
automatically fill the specified subtree, greatly improving
performance.  For example:
.PP
.Vb 1
\&      $lab_address = $object\->Laboratory(\-filled=>\*(AqAddress\*(Aq);
.Ve
.PP
** \s-1NOTE:\s0 In a scalar context, if the node to the right of the tag is
** an object, the method will perform an implicit dereference of the
** object.  For example, in the case of:
.PP
.Vb 1
\&    $lab = $author\->Laboratory;
.Ve
.PP
**NOTE: The object returned is the dereferenced Laboratory object, not
a node in the Author object.  You can control this by giving the
autogenerated method a numeric offset, such as \fILaboratory\fR\|(0) or
\&\fILaboratory\fR\|(1).  For backwards compatibility, Laboratory('@') is
equivalent to \fILaboratory\fR\|(1).
.PP
The semantics of the autogenerated methods have changed subtly between
version 1.57 (the last stable release) and version 1.62.  In earlier
versions, calling an autogenerated method in a scalar context returned
the subtree rooted at the tag.  In the current version, an implicit
\&\fIright()\fR and dereference is performed.
.SS "\fIfetch()\fP method"
.IX Subsection "fetch() method"
.Vb 2
\&    $new_object = $object\->fetch;
\&    $new_object = $object\->fetch($tag);
.Ve
.PP
Follow object into the database, returning a new object.  This is
the best way to follow object references.  For example:
.PP
.Vb 2
\&    $laboratory = $object\->at(\*(AqLaboratory\*(Aq)\->fetch;
\&    print $laboratory\->asString;
.Ve
.PP
Because the previous example is a frequent idiom, the optional \f(CW$tag\fR
argument allows you to combine the two operations into a single one:
.PP
.Vb 1
\&    $laboratory = $object\->fetch(\*(AqLaboratory\*(Aq);
.Ve
.SS "\fIfollow()\fP method"
.IX Subsection "follow() method"
.Vb 3
\&    @papers        = $object\->follow(\*(AqPaper\*(Aq);
\&    @filled_papers = $object\->follow(\-tag=>\*(AqPaper\*(Aq,\-filled=>1);
\&    @filled_papers = $object\->follow(\-tag=>\*(AqPaper\*(Aq,\-filled=>\*(AqAuthor\*(Aq);
.Ve
.PP
The \fIfollow()\fR method will follow a tag into the database, dereferencing
the column to its right and returning the objects resulting from this
operation.  Beware!  If you follow a tag that points to an object,
such as the Author \*(L"Paper\*(R" tag, you will get a list of all the Paper
objects.  If you follow a tag that points to a scalar, such as
\&\*(L"Full_name\*(R", you will get an empty string.  In a scalar context, this
method will return the number of objects that would have been
followed.
.PP
The full named-argument form of this call accepts the arguments
\&\fB\-tag\fR (mandatory) and \fB\-filled\fR (optional).  The former points to
the tag to follow.  The latter accepts a boolean argument or the name
of a subtag.  A numeric true argument will return completely \*(L"filled\*(R"
objects, increasing network and memory usage, but possibly boosting
performance if you have a high database access latency.
Alternatively, you may provide the name of a tag to follow, in which
case just the named portion of the subtree in the followed objects
will be filled (v.g.)
.PP
For backward compatability, if \fIfollow()\fR is called without any
arguments, it will act like \fIfetch()\fR.
.SS "\fIpick()\fP method"
.IX Subsection "pick() method"
Deprecated method.  This has the same semantics as \fIfetch()\fR, which
should be used instead.
.SS "\fIcol()\fP method"
.IX Subsection "col() method"
.Vb 2
\&     @column = $object\->col;
\&     @column = $object\->col($position);
.Ve
.PP
\&\fB\f(BIcol()\fB\fR flattens a portion of the tree by returning the column one
hop to the right of the current subtree. You can provide an additional
positional index to navigate through the tree using \*(L"tag[2]\*(R" behavior.
This example returns the author's mailing address:
.PP
.Vb 1
\&  @mailing_address = $object\->at(\*(AqAddress.Mail\*(Aq)\->col();
.Ve
.PP
This example returns the author's entire address including mail,
e\-mail and phone:
.PP
.Vb 1
\&  @address = $object\->at(\*(AqAddress\*(Aq)\->col(2);
.Ve
.PP
It is equivalent to any of these calls:
.PP
.Vb 3
\&  $object\->at(\*(AqAddress[2]\*(Aq);
\&  $object\->get(\*(AqAddress\*(Aq,2);
\&  $object\->Address(2);
.Ve
.PP
Use whatever syntax is most comfortable for you.
.PP
In a scalar context, \fB\f(BIcol()\fB\fR returns the number of items in the
column.
.SS "\fIrow()\fP method"
.IX Subsection "row() method"
.Vb 2
\&     @row=$object\->row();
\&     @row=$object\->row($position);
.Ve
.PP
\&\fB\f(BIrow()\fB\fR will return the row of data to the right of the object.  The
first member of the list will be the object itself.  In the case of
the \*(L"Thierry-Mieg J\*(R" object, the example below will return the list
('Address','Mail','\s-1CRBM\s0 duCNRS').
.PP
.Vb 1
\&     @row = $object\->Address\->row();
.Ve
.PP
You can provide an optional position to move rightward one or more
places before retrieving the row.  This code fragment will return
('Mail','\s-1CRBM\s0 duCNRS'):
.PP
.Vb 1
\&     @row = $object\->Address\->row(1);
.Ve
.PP
In a scalar context, \fB\f(BIrow()\fB\fR returns the number of items in the row.
.SS "\fIasString()\fP method"
.IX Subsection "asString() method"
.Vb 1
\&    $object\->asString;
.Ve
.PP
\&\fIasString()\fR returns a pretty-printed \s-1ASCII\s0 representation of the object
tree.
.SS "\fIasTable()\fP method"
.IX Subsection "asTable() method"
.Vb 1
\&    $object\->asTable;
.Ve
.PP
\&\fIasTable()\fR returns the object as a tab-delimited text table.
.SS "\fIasAce()\fP method"
.IX Subsection "asAce() method"
.Vb 1
\&    $object\->asAce;
.Ve
.PP
\&\fIasAce()\fR returns the object as a tab-delimited text table in \*(L".ace\*(R"
format.
.SS "\fIasHTML()\fP method"
.IX Subsection "asHTML() method"
.Vb 2
\&   $object\->asHTML;
\&   $object\->asHTML(\e&tree_traversal_code);
.Ve
.PP
\&\fIasHTML()\fR returns an \s-1HTML 3\s0 table representing the object, suitable for
incorporation into a Web browser page.  The callback routine, if
provided, will have a chance to modify the object representation
before it is incorporated into the table, for example by turning it
into an \s-1HREF\s0 link.  The callback takes a single argument containing
the object, and must return a string-valued result.  It may also
return a list as its result, in which case the first member of the
list is the string representation of the object, and the second
member is a boolean indicating whether to prune the table at this
level.  For example, you can prune large repetitive lists.
.PP
Here's a complete example:
.PP
.Vb 3
\&   sub process_cell {
\&     my $obj = shift;
\&     return "$obj" unless $obj\->isObject || $obj\->isTag;
\&
\&     my @col = $obj\->col;
\&     my $cnt = scalar(@col);
\&     return ("$obj \-\- $cnt members",1);  # prune
\&            if $cnt > 10                 # if subtree to big
\&
\&     # tags are bold
\&     return "<B>$obj</B>" if $obj\->isTag;  
\&
\&     # objects are blue
\&     return qq{<FONT COLOR="blue">$obj</FONT>} if $obj\->isObject; 
\&   }
\&
\&   $object\->asHTML(\e&process_cell);
.Ve
.SS "\fIasXML()\fP method"
.IX Subsection "asXML() method"
.Vb 1
\&   $result = $object\->asXML;
.Ve
.PP
\&\fIasXML()\fR returns a well-formed \s-1XML\s0 representation of the object.  The
particular representation is still under discussion, so this feature
is primarily for demonstration.
.SS "\fIasGIF()\fP method"
.IX Subsection "asGIF() method"
.Vb 8
\&  ($gif,$boxes) = $object\->asGIF();
\&  ($gif,$boxes) = $object\->asGIF(\-clicks=>[[$x1,$y1],[$x2,$y2]...]
\&                                 \-dimensions=> [$width,$height],
\&                                 \-coords    => [$top,$bottom],
\&                                 \-display   => $display_type,
\&                                 \-view      => $view_type,
\&                                 \-getcoords => $true_or_false
\&                                 );
.Ve
.PP
\&\fIasGIF()\fR returns the object as a \s-1GIF\s0 image.  The contents of the \s-1GIF\s0
will be whatever xace would ordinarily display in graphics mode, and
will vary for different object classes.
.PP
You can optionally provide asGIF with a \fB\-clicks\fR argument to
simulate the action of a user clicking on the image.  The click
coordinates should be formatted as an array reference that contains a
series of two-element subarrays, each corresponding to the X and Y
coordinates of a single mouse click.  There is currently no way to
pass information about middle or right mouse clicks, dragging
operations, or keystrokes.  You may also specify a \fB\-dimensions\fR to
control the width and height of the returned \s-1GIF.\s0  Since there is no
way of obtaining the preferred size of the image in advance, this is
not usually useful.
.PP
The optional \fB\-display\fR argument allows you to specify an alternate
display for the object.  For example, Clones can be displayed either
with the \s-1PMAP\s0 display or with the \s-1TREE\s0 display.  If not specified, the
default display is used.
.PP
The optional \fB\-view\fR argument allows you to specify an alternative
view for \s-1MAP\s0 objects only.  If not specified, you'll get the default
view.
.PP
The option \fB\-coords\fR argument allows you to provide the top and
bottom of the display for \s-1MAP\s0 objects only.  These coordinates are in
the map's native coordinate system (cM, bp).  By default, AceDB will
show most (but not necessarily all) of the map according to xace's
display rules.  If you call this method with the \fB\-getcoords\fR
argument and a true value, it will return a two-element array
containing the coordinates of the top and bottom of the map.
.PP
\&\fIasGIF()\fR returns a two-element array.  The first element is the \s-1GIF\s0
data.  The second element is an array reference that indicates special 
areas of the image called \*(L"boxes.\*(R"  Boxes are rectangular areas that
surround buttons, and certain displayed objects.  Using the contents
of the boxes array, you can turn the \s-1GIF\s0 image into a client-side
image map.  Unfortunately, not everything that is clickable is
represented as a box.  You still have to pass clicks on unknown image
areas back to the server for processing.
.PP
Each box in the array is a hash reference containing the following
keys:
.PP
.Vb 4
\&    \*(Aqcoordinates\*(Aq  => [$left,$top,$right,$bottom]
\&    \*(Aqclass\*(Aq        => object class or "BUTTON"
\&    \*(Aqname\*(Aq         => object name, if any
\&    \*(Aqcomment\*(Aq      => a text comment of some sort
.Ve
.PP
\&\fIcoordinates\fR points to an array of points indicating the top-left and 
bottom-right corners of the rectangle.  \fIclass\fR indicates the class
of the object this rectangle surrounds.  It may be a database object,
or the special word \*(L"\s-1BUTTON\*(R"\s0 for one of the display action buttons.
\&\fIname\fR indicates the name of the object or the button.  \fIcomment\fR is 
some piece of information about the object in question.  You can
display it in the status bar of the browser or in a popup window if
your browser provides that facility.
.SS "\fIasDNA()\fP and \fIasPeptide()\fP methods"
.IX Subsection "asDNA() and asPeptide() methods"
.Vb 2
\&    $dna = $object\->asDNA();
\&    $peptide = $object\->asPeptide();
.Ve
.PP
If you are dealing with a sequence object of some sort, these methods
will return strings corresponding to the \s-1DNA\s0 or peptide sequence in
\&\s-1FASTA\s0 format.
.SS "\fIadd_row()\fP method"
.IX Subsection "add_row() method"
.Vb 4
\&    $result_code = $object\->add_row($tag=>$value);    
\&    $result_code = $object\->add_row($tag=>[list,of,values]);    
\&    $result_code = $object\->add(\-path=>$tag,
\&                                \-value=>$value);
.Ve
.PP
\&\fIadd_row()\fR updates the tree by adding data to the indicated tag path.  The
example given below adds the value \*(L"555\-1212\*(R" to a new Address entry
named \*(L"Pager\*(R".  You may call \fIadd_row()\fR a second time to add a new value
under this tag, creating multi-valued entries.
.PP
.Vb 1
\& $object\->add_row(\*(AqAddress.Pager\*(Aq=>\*(Aq555\-1212\*(Aq);
.Ve
.PP
You may provide a list of values to add an entire row of data.  For
example:
.PP
.Vb 1
\& $sequence\->add_row(\*(AqAssembly_tags\*(Aq=>[\*(AqFinished Left\*(Aq,38949,38952,\*(AqAC3\*(Aq]);
.Ve
.PP
Actually, the array reference is not entirely necessary, and if you
prefer you can use this more concise notation:
.PP
.Vb 1
\& $sequence\->add_row(\*(AqAssembly_tags\*(Aq,\*(AqFinished Left\*(Aq,38949,38952,\*(AqAC3\*(Aq);
.Ve
.PP
No check is done against the database model for the correct data type
or tag path.  The update isn't actually performed until you call
\&\fIcommit()\fR, at which time a result code indicates whether the database
update was successful.
.PP
You may create objects that reference other objects this way:
.PP
.Vb 4
\&    $lab = new Ace::Object(\*(AqLaboratory\*(Aq,\*(AqLM\*(Aq,$db);
\&    $lab\->add_row(\*(AqFull_name\*(Aq,\*(AqThe Laboratory of Medicine\*(Aq);
\&    $lab\->add_row(\*(AqCity\*(Aq,\*(AqCincinatti\*(Aq);
\&    $lab\->add_row(\*(AqCountry\*(Aq,\*(AqUSA\*(Aq);
\&
\&    $author = new Ace::Object(\*(AqAuthor\*(Aq,\*(AqSmith J\*(Aq,$db);
\&    $author\->add_row(\*(AqFull_name\*(Aq,\*(AqJoseph M. Smith\*(Aq);
\&    $author\->add_row(\*(AqLaboratory\*(Aq,$lab);
\&
\&    $lab\->commit();
\&    $author\->commit();
.Ve
.PP
The result code indicates whether the addition was syntactically
correct.  \fIadd_row()\fR will fail if you attempt to add a duplicate entry
(that is, one with exactly the same tag and value).  In this case, use
\&\fIreplace()\fR instead.  Currently there is no checking for an attempt to
add multiple values to a single-valued (\s-1UNIQUE\s0) tag.  The error will
be detected and reported at \fIcommit()\fR time however.
.PP
The \fIadd()\fR method is an alias for \fIadd_row()\fR.
.PP
See also the Ace\->\fInew()\fR method.
.SS "\fIadd_tree()\fP"
.IX Subsection "add_tree()"
.Vb 2
\&  $result_code = $object\->add_tree($tag=>$ace_object);
\&  $result_code = $object\->add_tree(\-tag=>$tag,\-tree=>$ace_object);
.Ve
.PP
The \fIadd_tree()\fR method will insert an entire Ace subtree into the object
to the right of the indicated tag.  This can be used to build up
complex Ace objects, or to copy portions of objects from one database
to another.  The first argument is a tag path, and the second is the
tree that you wish to insert.  As with \fIadd_row()\fR the database will
only be updated when you call \fIcommit()\fR.
.PP
When inserting a subtree, you must be careful to remember that
everything to the *right* of the node that you are pointing at will be
inserted; not the node itself.  For example, given this Sequence
object:
.PP
.Vb 7
\&  Sequence AC3
\&    DB_info     Database    EMBL
\&    Assembly_tags   Finished Left   1   4   AC3
\&                    Clone left end      1   4   AC3
\&                    Clone right end     5512    5515    K07C5
\&                                        38949   38952   AC3
\&                    Finished Right      38949   38952   AC3
.Ve
.PP
If we use at('Assembly_tags') to fetch the subtree rooted on the
\&\*(L"Assembly_tags\*(R" tag, it is the tree to the right of this tag,
beginning with \*(L"Finished Left\*(R", that will be inserted.
.PP
Here is an example of copying the \*(L"Assembly_tags\*(R" subtree
from one database object to another:
.PP
.Vb 3
\& $remote = Ace\->connect(\-port=>200005)  || die "can\*(Aqt connect";
\& $ac3 = $remote\->fetch(Sequence=>\*(AqAC3\*(Aq) || die "can\*(Aqt get AC7";
\& my $assembly = $ac3\->at(\*(AqAssembly_tags\*(Aq);
\&
\& $local = Ace\->connect(\-path=>\*(Aq~acedb\*(Aq) || die "can\*(Aqt connect";
\& $AC3copy = Ace::Object\->new(Sequence=>\*(AqAC3copy\*(Aq,$local);
\& $AC3copy\->add_tree(\*(AqAssembly_tags\*(Aq=>$tags);
\& $AC3copy\->commit || warn $AC3copy\->error;
.Ve
.PP
Notice that this syntax will not work the way you think it should:
.PP
.Vb 1
\& $AC3copy\->add_tree(\*(AqAssembly_tags\*(Aq=>$ac3\->at(\*(AqAssembly_tags\*(Aq));
.Ve
.PP
This is because call \fIat()\fR in an array context returns the column to
the right of the tag, not the tag itself.
.PP
Here's an example of building up a complex structure from scratch
using a combination of \fIadd()\fR and \fIadd_tree()\fR:
.PP
.Vb 8
\& $newObj = Ace::Object\->new(Sequence=>\*(AqA555\*(Aq,$local);
\& my $assembly = Ace::Object\->new(tag=>\*(AqAssembly_tags\*(Aq);
\& $assembly\->add(\*(AqFinished Left\*(Aq=>[10,20,\*(AqABC\*(Aq]);
\& $assembly\->add(\*(AqClone right end\*(Aq=>[1000,2000,\*(AqDEF\*(Aq]);
\& $assembly\->add(\*(AqClone right end\*(Aq=>[8000,9876,\*(AqFRED\*(Aq]);
\& $assembly\->add(\*(AqFinished Right\*(Aq=>[1000,3000,\*(AqETHEL\*(Aq]);
\& $newObj\->add_tree(\*(AqAssembly_tags\*(Aq=>$assembly);
\& $newObj\->commit || warn $newObj\->error;
.Ve
.SS "\fIdelete()\fP method"
.IX Subsection "delete() method"
.Vb 3
\&    $result_code = $object\->delete($tag_path,$value);
\&    $result_code = $object\->delete(\-path=>$tag_path,
\&                                   \-value=>$value);
.Ve
.PP
Delete the indicated tag and value from the object.  This example
deletes the address line \*(L"\s-1FRANCE\*(R"\s0 from the Author's mailing address:
.PP
.Vb 1
\&    $object\->delete(\*(AqAddress.Mail\*(Aq,\*(AqFRANCE\*(Aq);
.Ve
.PP
No actual database deletion occurs until you call \fIcommit()\fR.  The
\&\fIdelete()\fR result code indicates whether the deletion was successful.
Currently it is always true, since the database model is not checked.
.SS "\fIreplace()\fP method"
.IX Subsection "replace() method"
.Vb 4
\&    $result_code = $object\->replace($tag_path,$oldvalue,$newvalue);
\&    $result_code = $object\->replace(\-path=>$tag_path,
\&                                    \-old=>$oldvalue,
\&                                    \-new=>$newvalue);
.Ve
.PP
Replaces the indicated tag and value with the new value.  This example
changes the address line \*(L"\s-1FRANCE\*(R"\s0 to \*(L"\s-1LANGUEDOC\*(R"\s0 in the Author's
mailing address:
.PP
.Vb 1
\&    $object\->delete(\*(AqAddress.Mail\*(Aq,\*(AqFRANCE\*(Aq,\*(AqLANGUEDOC\*(Aq);
.Ve
.PP
No actual database changes occur until you call \fIcommit()\fR.  The
\&\fIdelete()\fR result code indicates whether the replace was successful.
Currently is true if the old value was identified.
.SS "\fIcommit()\fP method"
.IX Subsection "commit() method"
.Vb 1
\&     $result_code = $object\->commit;
.Ve
.PP
Commits all \fIadd()\fR, \fIreplace()\fR and \fIdelete()\fR operations to the database.
It can also be used to write a completely new object into the
database.  The result code indicates whether the object was
successfully written.  If an error occurred, further details can be
found in the Ace\->\fIerror()\fR error string.
.SS "\fIrollback()\fP method"
.IX Subsection "rollback() method"
.Vb 1
\&    $object\->rollback;
.Ve
.PP
Discard all adds, deletions and replacements, returning the object to
the state it was in prior to the last \fIcommit()\fR.
.PP
\&\fIrollback()\fR works by deleting the object from Perl memory and fetching
the object anew from AceDB.  If someone has changed the object in the
database while you were working with it, you will see this version,
ot the one you originally fetched.
.PP
If you are creating an entirely new object, you \fImust\fR add at least
one tag in order to enter the object into the database.
.SS "\fIkill()\fP method"
.IX Subsection "kill() method"
.Vb 1
\&    $result_code = $object\->kill;
.Ve
.PP
This will remove the object from the database immediately and
completely.  It does not wait for a \fIcommit()\fR, and does not respond to
a \fIrollback()\fR.  If successful, you will be left with an empty object
that contains just the class and object names.  Use with care!
.PP
In the case of failure, which commonly happens when the database is
not open for writing, this method will return undef.  A description of
the problem can be found by calling the \fIerror()\fR method.
.SS "\fIdate_style()\fP method"
.IX Subsection "date_style() method"
.Vb 1
\&   $object\->date_style(\*(Aqace\*(Aq);
.Ve
.PP
This is a convenience method that can be used to set the date format
for all objects returned by the database.  It is exactly equivalent to
.PP
.Vb 1
\&   $object\->db\->date_style(\*(Aqace\*(Aq);
.Ve
.PP
Note that the text representation of the date will change for all
objects returned from this database, not just the current one.
.SS "\fIisRoot()\fP method"
.IX Subsection "isRoot() method"
.Vb 1
\&    print "Top level object" if $object\->isRoot;
.Ve
.PP
This method will return true if the object is a \*(L"top level\*(R" object,
that is the root of an object tree rather than a subtree.
.SS "\fImodel()\fP method"
.IX Subsection "model() method"
.Vb 1
\&    $model = $object\->model;
.Ve
.PP
This method will return the object's model as an Ace::Model object, or
undef if the object does not have a model. See Ace::Model for
details.
.SS "\fItimestamp()\fP method"
.IX Subsection "timestamp() method"
.Vb 1
\&   $stamp = $object\->timestamp;
.Ve
.PP
The \fB\f(BItimestamp()\fB\fR method will retrieve the modification time and date
from the object.  This works both with top level objects and with
subtrees.  Timestamp handling must be turned on in the database, or
\&\fB\f(BItimestamp()\fB\fR will return undef.
.PP
The returned timestamp is actually a UserSession object which can be
printed and explored like any other object.  However, there is
currently no useful information in UserSession other than its name.
.SS "\fIcomment()\fP method"
.IX Subsection "comment() method"
.Vb 1
\&   $comment = $object\->comment;
.Ve
.PP
This returns the comment attached to an object or object subtree, if
any.  Comments are \fIComment\fR objects and have the interesting
property that a single comment can refer to multiple objects.  If
there is no comment attached to the current subtree, this method will
return undef.
.PP
Currently you cannot create a new comment in AcePerl or edit an old
one.
.SS "\fIerror()\fP method"
.IX Subsection "error() method"
.Vb 1
\&    $error = $object\->error;
.Ve
.PP
Returns the error from the previous operation, if any.  As in
\&\fIAce::error()\fR, this string will only have meaning if the previous
operation returned a result code indicating an error.
.SS "\fIfactory()\fP method"
.IX Subsection "factory() method"
\&\s-1WARNING\s0 \- \s-1THIS IS DEFUNCT AND NO LONGER WORKS.\s0  \s-1USE THE\s0 Ace\->\fIclass()\fR \s-1METHOD INSTEAD\s0
.PP
.Vb 1
\&    $package = $object\->factory;
.Ve
.PP
When a root Ace object instantiates its tree of tags and values, it
creates a hierarchical structure of Ace::Object objects.  The
\&\fIfactory()\fR method determines what class to bless these subsidiary
objects into.  By default, they are Ace::Object objects, but you can
override this method in a child class in order to create more
specialized Ace::Object classes.  The method should return a string
corresponding to the package to bless the object into.  It receives
the current Ace::Object as its first argument.
.SS "\fIdebug()\fP method"
.IX Subsection "debug() method"
.Vb 1
\&    $object\->debug(1);
.Ve
.PP
Change the debugging mode.  A zero turns off debugging messages.
Integer values produce debug messages on standard error.  Higher
integers produce progressively more verbose messages.  This actually
is just a front end to Ace\->\fIdebug()\fR, so the debugging level is global.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Ace, Ace::Model, Ace::Object, Ace::Local,
Ace::Sequence,Ace::Sequence::Multi
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org> with extensive help from Jean
Thierry-Mieg <mieg@kaa.crbm.cnrs\-mop.fr>
.PP
Copyright (c) 1997\-1998, Lincoln D. Stein
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  See \s-1DISCLAIMER\s0.txt for
disclaimers of warranty.
