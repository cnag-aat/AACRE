.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Graph 3"
.TH Graph 3 "2015-09-29" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Graph \- graph data structures and algorithms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        use Graph;
\&        my $g0 = Graph\->new;             # A directed graph.
\&
\&        use Graph::Directed;
\&        my $g1 = Graph::Directed\->new;   # A directed graph.
\&
\&        use Graph::Undirected;
\&        my $g2 = Graph::Undirected\->new; # An undirected graph.
\&
\&        $g\->add_edge(...);
\&        $g\->has_edge(...)
\&        $g\->delete_edge(...);
\&
\&        $g\->add_vertex(...);
\&        $g\->has_vertex(...);
\&        $g\->delete_vertex(...);
\&
\&        $g\->vertices(...)
\&        $g\->edges(...)
\&
\&        # And many, many more, see below.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Non-Description"
.IX Subsection "Non-Description"
This module is not for \fBdrawing\fR or \fBrendering\fR any sort of
\&\fIgraphics\fR or \fIimages\fR, business, visualization, or otherwise.
.SS "Description"
.IX Subsection "Description"
Instead, this module is for creating \fIabstract data structures\fR
called graphs, and for doing various operations on those.
.SS "Perl 5.6.0 minimum"
.IX Subsection "Perl 5.6.0 minimum"
The implementation depends on a Perl feature called \*(L"weak references\*(R"
and Perl 5.6.0 was the first to have those.
.SS "Constructors"
.IX Subsection "Constructors"
.IP "new" 4
.IX Item "new"
Create an empty graph.
.IP "Graph\->new(%options)" 4
.IX Item "Graph->new(%options)"
The options are a hash with option names as the hash keys and the option
values as the hash values.
.Sp
The following options are available:
.RS 4
.IP "directed" 8
.IX Item "directed"
A boolean option telling that a directed graph should be created.
Often somewhat redundant because a directed graph is the default
for the Graph class or one could simply use the \f(CW\*(C`new()\*(C'\fR constructor
of the Graph::Directed class.
.Sp
You can test the directness of a graph with \f(CW$g\fR\->\fIis_directed()\fR and
\&\f(CW$g\fR\->\fIis_undirected()\fR.
.IP "undirected" 8
.IX Item "undirected"
A boolean option telling that an undirected graph should be created.
One could also use the \f(CW\*(C`new()\*(C'\fR constructor the Graph::Undirected class
instead.
.Sp
Note that while often it is possible to think undirected graphs as
bidirectional graphs, or as directed graphs with edges going both ways,
in this module directed graphs and undirected graphs are two different
things that often behave differently.
.Sp
You can test the directness of a graph with \f(CW$g\fR\->\fIis_directed()\fR and
\&\f(CW$g\fR\->\fIis_undirected()\fR.
.IP "refvertexed" 8
.IX Item "refvertexed"
.PD 0
.IP "refvertexed_stringified" 8
.IX Item "refvertexed_stringified"
.PD
If you want to use references (including Perl objects) as vertices,
use \f(CW\*(C`refvertexed\*(C'\fR.
.Sp
Note that using \f(CW\*(C`refvertexed\*(C'\fR means that internally the memory
address of the reference (for example, a Perl object) is used as the
\&\*(L"identifier\*(R" of the vertex, not the stringified form of the reference,
even if you have defined your own stringification using \f(CW\*(C`overload\*(C'\fR.
.Sp
This avoids the problem of the stringified references potentially
being identical (because they are identical in value, for example)
even if the references are different.  If you really want to use
references \fBand\fR their stringified forms as the identities, use the
\&\f(CW\*(C`refvertexed_stringified\*(C'\fR.  But please do \fBnot\fR stringify different
objects to the same stringified value.
.IP "unionfind" 8
.IX Item "unionfind"
If the graph is undirected, you can specify the \f(CW\*(C`unionfind\*(C'\fR parameter
to use the so-called union-find scheme to speed up the computation of
\&\fIconnected components\fR of the graph (see \*(L"is_connected\*(R",
\&\*(L"connected_components\*(R", \*(L"connected_component_by_vertex\*(R",
\&\*(L"connected_component_by_index\*(R", and \*(L"same_connected_components\*(R").
If \f(CW\*(C`unionfind\*(C'\fR is used, adding edges (and vertices) becomes slower,
but connectedness queries become faster.  You \fBmust not\fR delete egdes or
vertices of an unionfind graph, only add them.  You can test a graph for
\&\*(L"union-findness\*(R" with
.IP "has_union_find" 8
.IX Item "has_union_find"
Returns true if the graph was created with a true \f(CW\*(C`unionfind\*(C'\fR parameter.
.IP "vertices" 8
.IX Item "vertices"
An array reference of vertices to add.
.IP "edges" 8
.IX Item "edges"
An array reference of array references of edge vertices to add.
.RE
.RS 4
.RE
.IP "copy" 4
.IX Item "copy"
.PD 0
.IP "copy_graph" 4
.IX Item "copy_graph"
.PD
.Vb 1
\&    my $c = $g\->copy_graph;
.Ve
.Sp
Create a shallow copy of the structure (vertices and edges) of the
graph.  If you want a deep copy that includes attributes, see
\&\*(L"deep_copy\*(R".  The copy will have the same directedness as the
original, and if the original was a \f(CW\*(C`compat02\*(C'\fR graph, the copy will be, too.
.Sp
Also the following vertex/edge attributes are copied:
.Sp
.Vb 2
\&  refvertexed/hypervertexed/countvertexed/multivertexed
\&  hyperedged/countedged/multiedged/omniedged
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR: You can get an even shallower copy of a graph by
.Sp
.Vb 1
\&    my $c = $g\->new;
.Ve
.Sp
This will copy only the graph properties (directed, and so forth),
but none of the vertices or edges.
.IP "deep_copy" 4
.IX Item "deep_copy"
.PD 0
.IP "deep_copy_graph" 4
.IX Item "deep_copy_graph"
.PD
.Vb 1
\&    my $c = $g\->deep_copy_graph;
.Ve
.Sp
Create a deep copy of the graph (vertices, edges, and attributes) of
the graph.  If you want a shallow copy that does not include
attributes, see \*(L"copy\*(R".
.Sp
Note that copying code references only works with Perls 5.8 or later,
and even then only if B::Deparse can reconstruct your code.  This
functionality uses either Storable or Data::Dumper behind the scenes,
depending on which is available (Storable is preferred).
.IP "undirected_copy" 4
.IX Item "undirected_copy"
.PD 0
.IP "undirected_copy_graph" 4
.IX Item "undirected_copy_graph"
.PD
.Vb 1
\&    my $c = $g\->undirected_copy_graph;
.Ve
.Sp
Create an undirected shallow copy (vertices and edges) of the directed graph
so that for any directed edge (u, v) there is an undirected edge (u, v).
.IP "undirected_copy_clear_cache" 4
.IX Item "undirected_copy_clear_cache"
.Vb 1
\&    @path = $g\->undirected_copy_clear_cache;
.Ve
.Sp
See \*(L"Clearing cached results\*(R".
.IP "directed_copy" 4
.IX Item "directed_copy"
.PD 0
.IP "directed_copy_graph" 4
.IX Item "directed_copy_graph"
.PD
.Vb 1
\&    my $c = $g\->directed_copy_graph;
.Ve
.Sp
Create a directed shallow copy (vertices and edges) of the undirected graph
so that for any undirected edge (u, v) there are two directed edges (u, v)
and (v, u).
.IP "transpose" 4
.IX Item "transpose"
.PD 0
.IP "transpose_graph" 4
.IX Item "transpose_graph"
.PD
.Vb 1
\&    my $t = $g\->transpose_graph;
.Ve
.Sp
Create a directed shallow transposed copy (vertices and edges) of the
directed graph so that for any directed edge (u, v) there is a directed
edge (v, u).
.Sp
You can also transpose a single edge with
.RS 4
.IP "transpose_edge" 8
.IX Item "transpose_edge"
.Vb 1
\&    $g\->transpose_edge($u, $v)
.Ve
.RE
.RS 4
.RE
.IP "complete_graph" 4
.IX Item "complete_graph"
.PD 0
.IP "complete" 4
.IX Item "complete"
.PD
.Vb 1
\&    my $c = $g\->complete_graph;
.Ve
.Sp
Create a complete graph that has the same vertices as the original graph.
A complete graph has an edge between every pair of vertices.
.IP "complement_graph" 4
.IX Item "complement_graph"
.PD 0
.IP "complement" 4
.IX Item "complement"
.PD
.Vb 1
\&    my $c = $g\->complement_graph;
.Ve
.Sp
Create a complement graph that has the same vertices as the original graph.
A complement graph has an edge (u,v) if and only if the original
graph does not have edge (u,v).
.IP "subgraph" 4
.IX Item "subgraph"
.Vb 2
\&   my $c = $g\->subgraph(\e@src, \e@dst);
\&   my $c = $g\->subgraph(\e@src);
.Ve
.Sp
Creates a subgraph of a given graph.  The created subgraph has the
same graph properties (directedness, and so forth) as the original
graph, but none of the attributes (graph, vertex, or edge).
.Sp
A vertex is added to the subgraph if it is in the original graph.
.Sp
An edge is added to the subgraph if there is an edge in the original
graph that starts from the \f(CW\*(C`src\*(C'\fR set of vertices and ends in the
\&\f(CW\*(C`dst\*(C'\fR set of vertices.
.Sp
You can leave out \f(CW\*(C`dst\*(C'\fR in which case \f(CW\*(C`dst\*(C'\fR is assumed to be the same:
this is called a \fIvertex-induced subgraph\fR.
.PP
See also \*(L"random_graph\*(R" for a random constructor.
.SS "Basics"
.IX Subsection "Basics"
.IP "add_vertex" 4
.IX Item "add_vertex"
.Vb 1
\&    $g\->add_vertex($v)
.Ve
.Sp
Add the vertex to the graph.  Returns the graph.
.Sp
By default idempotent, but a graph can be created \fIcountvertexed\fR.
.Sp
A vertex is also known as a \fInode\fR.
.Sp
Adding \f(CW\*(C`undef\*(C'\fR as vertex is not allowed.
.Sp
Note that unless you have isolated vertices (or \fIcountvertexed\fR
vertices), you do not need to explicitly use \f(CW\*(C`add_vertex\*(C'\fR since
\&\*(L"add_edge\*(R" will implicitly add its vertices.
.IP "add_edge" 4
.IX Item "add_edge"
.Vb 1
\&    $g\->add_edge($u, $v)
.Ve
.Sp
Add the edge to the graph.  Implicitly first adds the vertices if the
graph does not have them.  Returns the graph.
.Sp
By default idempotent, but a graph can be created \fIcountedged\fR.
.Sp
An edge is also known as an \fIarc\fR.
.IP "has_vertex" 4
.IX Item "has_vertex"
.Vb 1
\&    $g\->has_vertex($v)
.Ve
.Sp
Return true if the vertex exists in the graph, false otherwise.
.IP "has_edge" 4
.IX Item "has_edge"
.Vb 1
\&    $g\->has_edge($u, $v)
.Ve
.Sp
Return true if the edge exists in the graph, false otherwise.
.IP "delete_vertex" 4
.IX Item "delete_vertex"
.Vb 1
\&    $g\->delete_vertex($v)
.Ve
.Sp
Delete the vertex from the graph.  Returns the graph, even if the
vertex did not exist in the graph.
.Sp
If the graph has been created \fImultivertexed\fR or \fIcountvertexed\fR
and a vertex has been added multiple times, the vertex will require
at least an equal number of deletions to become completely deleted.
.IP "delete_vertices" 4
.IX Item "delete_vertices"
.Vb 1
\&    $g\->delete_vertices($v1, $v2, ...)
.Ve
.Sp
Delete the vertices from the graph.  Returns the graph, even if none
of the vertices existed in the graph.
.Sp
If the graph has been created \fImultivertexed\fR or \fIcountvertexed\fR
and a vertex has been added multiple times, the vertex will require
at least an equal number of deletions to become completely deleteted.
.IP "delete_edge" 4
.IX Item "delete_edge"
.Vb 1
\&    $g\->delete_edge($u, $v)
.Ve
.Sp
Delete the edge from the graph.  Returns the graph, even
if the edge did not exist in the graph.
.Sp
If the graph has been created \fImultivertexed\fR or \fIcountedged\fR
and an edge has been added multiple times, the edge will require
at least an equal number of deletions to become completely deleted.
.IP "delete_edges" 4
.IX Item "delete_edges"
.Vb 1
\&    $g\->delete_edges($u1, $v1, $u2, $v2, ...)
.Ve
.Sp
Delete the edges from the graph.  Returns the graph, even if none
of the edges existed in the graph.
.Sp
If the graph has been created \fImultivertexed\fR or \fIcountedged\fR
and an edge has been added multiple times, the edge will require
at least an equal number of deletions to become completely deleted.
.SS "Displaying"
.IX Subsection "Displaying"
Graphs have stringification overload, so you can do things like
.PP
.Vb 1
\&    print "The graph is $g\en"
.Ve
.PP
One-way (directed, unidirected) edges are shown as '\-', two-way
(undirected, bidirected) edges are shown as '='.  If you want to,
you can call the stringification via the method
.IP "stringify" 4
.IX Item "stringify"
.SS "Boolean"
.IX Subsection "Boolean"
Graphs have boolifying overload, so you can do things like
.PP
.Vb 1
\&    if ($g) { print "The graph is: $g\en" }
.Ve
.PP
which works even if the graph is empty.  In fact, the boolify
always returns true.  If you want to test for example for vertices,
test for vertices.
.IP "boolify" 4
.IX Item "boolify"
.SS "Comparing"
.IX Subsection "Comparing"
Testing for equality can be done either by the overloaded \f(CW\*(C`eq\*(C'\fR
operator
.PP
.Vb 1
\&    $g eq "a\-b,a\-c,d"
.Ve
.PP
or by the method
.IP "eq" 4
.IX Item "eq"
.Vb 1
\&    $g\->eq("a\-b,a\-c,d")
.Ve
.PP
The equality testing compares the stringified forms, and therefore it
assumes total equality, not isomorphism: all the vertices must be
named the same, and they must have identical edges between them.
.PP
For unequality there are correspondingly the overloaded \f(CW\*(C`ne\*(C'\fR
operator and the method
.IP "ne" 4
.IX Item "ne"
.Vb 1
\&    $g\->ne("a\-b,a\-c,d")
.Ve
.PP
See also \*(L"Isomorphism\*(R".
.SS "Paths and Cycles"
.IX Subsection "Paths and Cycles"
Paths and cycles are simple extensions of edges: paths are edges
starting from where the previous edge ended, and cycles are paths
returning back to the start vertex of the first edge.
.IP "add_path" 4
.IX Item "add_path"
.Vb 1
\&   $g\->add_path($a, $b, $c, ..., $x, $y, $z)
.Ve
.Sp
Add the edges \f(CW$a\fR\-$b, \f(CW$b\fR\-$c, ..., \f(CW$x\fR\-$y, \f(CW$y\fR\-$z to the graph.
Returns the graph.
.IP "has_path" 4
.IX Item "has_path"
.Vb 1
\&   $g\->has_path($a, $b, $c, ..., $x, $y, $z)
.Ve
.Sp
Return true if the graph has all the edges \f(CW$a\fR\-$b, \f(CW$b\fR\-$c, ..., \f(CW$x\fR\-$y, \f(CW$y\fR\-$z,
false otherwise.
.IP "delete_path" 4
.IX Item "delete_path"
.Vb 1
\&   $g\->delete_path($a, $b, $c, ..., $x, $y, $z)
.Ve
.Sp
Delete all the edges edges \f(CW$a\fR\-$b, \f(CW$b\fR\-$c, ..., \f(CW$x\fR\-$y, \f(CW$y\fR\-$z
(regardless of whether they exist or not).  Returns the graph.
.IP "add_cycle" 4
.IX Item "add_cycle"
.Vb 1
\&   $g\->add_cycle($a, $b, $c, ..., $x, $y, $z)
.Ve
.Sp
Add the edges \f(CW$a\fR\-$b, \f(CW$b\fR\-$c, ..., \f(CW$x\fR\-$y, \f(CW$y\fR\-$z, and \f(CW$z\fR\-$a to the graph.
Returns the graph.
.IP "has_cycle" 4
.IX Item "has_cycle"
.PD 0
.IP "has_this_cycle" 4
.IX Item "has_this_cycle"
.PD
.Vb 1
\&   $g\->has_cycle($a, $b, $c, ..., $x, $y, $z)
.Ve
.Sp
Return true if the graph has all the edges \f(CW$a\fR\-$b, \f(CW$b\fR\-$c, ..., \f(CW$x\fR\-$y, \f(CW$y\fR\-$z,
and \f(CW$z\fR\-$a, false otherwise.
.Sp
\&\fB\s-1NOTE:\s0\fR This does not \fIdetect\fR cycles, see \*(L"has_a_cycle\*(R" and
\&\*(L"find_a_cycle\*(R".
.IP "delete_cycle" 4
.IX Item "delete_cycle"
.Vb 1
\&   $g\->delete_cycle($a, $b, $c, ..., $x, $y, $z)
.Ve
.Sp
Delete all the edges edges \f(CW$a\fR\-$b, \f(CW$b\fR\-$c, ..., \f(CW$x\fR\-$y, \f(CW$y\fR\-$z, and \f(CW$z\fR\-$a
(regardless of whether they exist or not).  Returns the graph.
.IP "has_a_cycle" 4
.IX Item "has_a_cycle"
.Vb 1
\&   $g\->has_a_cycle
.Ve
.Sp
Returns true if the graph has a cycle, false if not.
.IP "find_a_cycle" 4
.IX Item "find_a_cycle"
.Vb 1
\&   $g\->find_a_cycle
.Ve
.Sp
Returns a cycle if the graph has one (as a list of vertices), an empty
list if no cycle can be found.
.Sp
Note that this just returns the vertices of \fIa cycle\fR: not any
particular cycle, just the first one it finds.  A repeated call
might find the same cycle, or it might find a different one, and
you cannot call this repeatedly to find all the cycles.
.SS "Graph Types"
.IX Subsection "Graph Types"
.IP "is_simple_graph" 4
.IX Item "is_simple_graph"
.Vb 1
\&    $g\->is_simple_graph
.Ve
.Sp
Return true if the graph has no multiedges, false otherwise.
.IP "is_pseudo_graph" 4
.IX Item "is_pseudo_graph"
.Vb 1
\&    $g\->is_pseudo_graph
.Ve
.Sp
Return true if the graph has any multiedges or any self-loops,
false otherwise.
.IP "is_multi_graph" 4
.IX Item "is_multi_graph"
.Vb 1
\&    $g\->is_multi_graph
.Ve
.Sp
Return true if the graph has any multiedges but no self-loops,
false otherwise.
.IP "is_directed_acyclic_graph" 4
.IX Item "is_directed_acyclic_graph"
.PD 0
.IP "is_dag" 4
.IX Item "is_dag"
.PD
.Vb 2
\&    $g\->is_directed_acyclic_graph
\&    $g\->is_dag
.Ve
.Sp
Return true if the graph is directed and acyclic, false otherwise.
.IP "is_cyclic" 4
.IX Item "is_cyclic"
.Vb 1
\&    $g\->is_cyclic
.Ve
.Sp
Return true if the graph is cyclic (contains at least one cycle).
(This is identical to \f(CW\*(C`has_a_cycle\*(C'\fR.)
.Sp
To find at least one such cycle, see \*(L"find_a_cycle\*(R".
.IP "is_acyclic" 4
.IX Item "is_acyclic"
Return true if the graph is acyclic (does not contain any cycles).
.PP
To find a cycle, use \*(L"find_a_cycle\*(R".
.SS "Transitivity"
.IX Subsection "Transitivity"
.IP "is_transitive" 4
.IX Item "is_transitive"
.Vb 1
\&    $g\->is_transitive
.Ve
.Sp
Return true if the graph is transitive, false otherwise.
.IP "TransitiveClosure_Floyd_Warshall" 4
.IX Item "TransitiveClosure_Floyd_Warshall"
.PD 0
.IP "transitive_closure" 4
.IX Item "transitive_closure"
.PD
.Vb 1
\&    $tcg = $g\->TransitiveClosure_Floyd_Warshall
.Ve
.Sp
Return the transitive closure graph of the graph.
.PP
You can query the reachability from \f(CW$u\fR to \f(CW$v\fR with
.IP "is_reachable" 4
.IX Item "is_reachable"
.Vb 1
\&    $tcg\->is_reachable($u, $v)
.Ve
.PP
See Graph::TransitiveClosure for more information about creating
and querying transitive closures.
.PP
With
.IP "transitive_closure_matrix" 4
.IX Item "transitive_closure_matrix"
.Vb 1
\&   $tcm = $g\->transitive_closure_matrix;
.Ve
.PP
you can (create if not existing and) query the transitive closure
matrix that underlies the transitive closure graph.  See
Graph::TransitiveClosure::Matrix for more information.
.SS "Mutators"
.IX Subsection "Mutators"
.IP "add_vertices" 4
.IX Item "add_vertices"
.Vb 1
\&    $g\->add_vertices(\*(Aqd\*(Aq, \*(Aqe\*(Aq, \*(Aqf\*(Aq)
.Ve
.Sp
Add zero or more vertices to the graph.  Returns the graph.
.IP "add_edges" 4
.IX Item "add_edges"
.Vb 2
\&    $g\->add_edges([\*(Aqd\*(Aq, \*(Aqe\*(Aq], [\*(Aqf\*(Aq, \*(Aqg\*(Aq])
\&    $g\->add_edges(qw(d e f g));
.Ve
.Sp
Add zero or more edges to the graph.  The edges are specified as
a list of array references, or as a list of vertices where the
even (0th, 2nd, 4th, ...) items are start vertices and the odd
(1st, 3rd, 5th, ...) are the corresponding end vertices.
Returns the graph.
.SS "Accessors"
.IX Subsection "Accessors"
.IP "is_directed" 4
.IX Item "is_directed"
.PD 0
.IP "directed" 4
.IX Item "directed"
.PD
.Vb 2
\&    $g\->is_directed()
\&    $g\->directed()
.Ve
.Sp
Return true if the graph is directed, false otherwise.
.IP "is_undirected" 4
.IX Item "is_undirected"
.PD 0
.IP "undirected" 4
.IX Item "undirected"
.PD
.Vb 2
\&    $g\->is_undirected()
\&    $g\->undirected()
.Ve
.Sp
Return true if the graph is undirected, false otherwise.
.IP "is_refvertexed" 4
.IX Item "is_refvertexed"
.PD 0
.IP "is_refvertexed_stringified" 4
.IX Item "is_refvertexed_stringified"
.IP "refvertexed" 4
.IX Item "refvertexed"
.IP "refvertexed_stringified" 4
.IX Item "refvertexed_stringified"
.PD
Return true if the graph can handle references (including Perl objects)
as vertices.
.IP "vertices" 4
.IX Item "vertices"
.Vb 2
\&    my $V = $g\->vertices
\&    my @V = $g\->vertices
.Ve
.Sp
In scalar context, return the number of vertices in the graph.
In list context, return the vertices, in no particular order.
.IP "has_vertices" 4
.IX Item "has_vertices"
.Vb 1
\&    $g\->has_vertices()
.Ve
.Sp
Return true if the graph has any vertices, false otherwise.
.IP "edges" 4
.IX Item "edges"
.Vb 2
\&    my $E = $g\->edges
\&    my @E = $g\->edges
.Ve
.Sp
In scalar context, return the number of edges in the graph.
In list context, return the edges, in no particular order.
\&\fIThe edges are returned as anonymous arrays listing the vertices.\fR
.IP "has_edges" 4
.IX Item "has_edges"
.Vb 1
\&    $g\->has_edges()
.Ve
.Sp
Return true if the graph has any edges, false otherwise.
.IP "is_connected" 4
.IX Item "is_connected"
.Vb 1
\&    $g\->is_connected
.Ve
.Sp
For an undirected graph, return true is the graph is connected, false
otherwise.  Being connected means that from every vertex it is possible
to reach every other vertex.
.Sp
If the graph has been created with a true \f(CW\*(C`unionfind\*(C'\fR parameter,
the time complexity is (essentially) O(V), otherwise O(V log V).
.Sp
See also \*(L"connected_components\*(R", \*(L"connected_component_by_index\*(R",
\&\*(L"connected_component_by_vertex\*(R", and \*(L"same_connected_components\*(R",
and \*(L"biconnectivity\*(R".
.Sp
For directed graphs, see \*(L"is_strongly_connected\*(R"
and \*(L"is_weakly_connected\*(R".
.IP "connected_components" 4
.IX Item "connected_components"
.Vb 1
\&    @cc = $g\->connected_components()
.Ve
.Sp
For an undirected graph, returns the vertices of the connected
components of the graph as a list of anonymous arrays.  The ordering
of the anonymous arrays or the ordering of the vertices inside the
anonymous arrays (the components) is undefined.
.Sp
For directed graphs, see \*(L"strongly_connected_components\*(R"
and \*(L"weakly_connected_components\*(R".
.IP "connected_component_by_vertex" 4
.IX Item "connected_component_by_vertex"
.Vb 1
\&    $i = $g\->connected_component_by_vertex($v)
.Ve
.Sp
For an undirected graph, return an index identifying the connected
component the vertex belongs to, the indexing starting from zero.
.Sp
For the inverse, see \*(L"connected_component_by_index\*(R".
.Sp
If the graph has been created with a true \f(CW\*(C`unionfind\*(C'\fR parameter,
the time complexity is (essentially) O(1), otherwise O(V log V).
.Sp
See also \*(L"biconnectivity\*(R".
.Sp
For directed graphs, see \*(L"strongly_connected_component_by_vertex\*(R"
and \*(L"weakly_connected_component_by_vertex\*(R".
.IP "connected_component_by_index" 4
.IX Item "connected_component_by_index"
.Vb 1
\&    @v = $g\->connected_component_by_index($i)
.Ve
.Sp
For an undirected graph, return the vertices of the ith connected
component, the indexing starting from zero.  The order of vertices is
undefined, while the order of the connected components is same as from
\&\fIconnected_components()\fR.
.Sp
For the inverse, see \*(L"connected_component_by_vertex\*(R".
.Sp
For directed graphs, see \*(L"strongly_connected_component_by_index\*(R"
and \*(L"weakly_connected_component_by_index\*(R".
.IP "same_connected_components" 4
.IX Item "same_connected_components"
.Vb 1
\&    $g\->same_connected_components($u, $v, ...)
.Ve
.Sp
For an undirected graph, return true if the vertices are in the same
connected component.
.Sp
If the graph has been created with a true \f(CW\*(C`unionfind\*(C'\fR parameter,
the time complexity is (essentially) O(1), otherwise O(V log V).
.Sp
For directed graphs, see \*(L"same_strongly_connected_components\*(R"
and \*(L"same_weakly_connected_components\*(R".
.IP "connected_graph" 4
.IX Item "connected_graph"
.Vb 1
\&    $cg = $g\->connected_graph
.Ve
.Sp
For an undirected graph, return its connected graph.
.IP "connectivity_clear_cache" 4
.IX Item "connectivity_clear_cache"
.Vb 1
\&    $g\->connectivity_clear_cache
.Ve
.Sp
See \*(L"Clearing cached results\*(R".
.Sp
See \*(L"Connected Graphs and Their Components\*(R" for further discussion.
.IP "biconnectivity" 4
.IX Item "biconnectivity"
.Vb 1
\&    my ($ap, $bc, $br) = $g\->biconnectivity
.Ve
.Sp
For an undirected graph, return the various biconnectivity components
of the graph: the articulation points (cut vertices), biconnected
components, and bridges.
.Sp
Note: currently only handles connected graphs.
.IP "is_biconnected" 4
.IX Item "is_biconnected"
.Vb 1
\&   $g\->is_biconnected
.Ve
.Sp
For an undirected graph, return true if the graph is biconnected
(if it has no articulation points, also known as cut vertices).
.IP "is_edge_connected" 4
.IX Item "is_edge_connected"
.Vb 1
\&   $g\->is_edge_connected
.Ve
.Sp
For an undirected graph, return true if the graph is edge-connected
(if it has no bridges).
.Sp
Note: more precisely, this would be called is_edge_biconnected,
since there is a more general concept of being k\-connected.
.IP "is_edge_separable" 4
.IX Item "is_edge_separable"
.Vb 1
\&   $g\->is_edge_separable
.Ve
.Sp
For an undirected graph, return true if the graph is edge-separable
(if it has bridges).
.Sp
Note: more precisely, this would be called is_edge_biseparable,
since there is a more general concept of being k\-connected.
.IP "articulation_points" 4
.IX Item "articulation_points"
.PD 0
.IP "cut_vertices" 4
.IX Item "cut_vertices"
.PD
.Vb 1
\&   $g\->articulation_points
.Ve
.Sp
For an undirected graph, return the articulation points (cut vertices)
of the graph as a list of vertices.  The order is undefined.
.IP "biconnected_components" 4
.IX Item "biconnected_components"
.Vb 1
\&   $g\->biconnected_components
.Ve
.Sp
For an undirected graph, return the biconnected components of the
graph as a list of anonymous arrays of vertices in the components.
The ordering of the anonymous arrays or the ordering of the vertices
inside the anonymous arrays (the components) is undefined.  Also note
that one vertex can belong to more than one biconnected component.
.IP "biconnected_component_by_vertex" 4
.IX Item "biconnected_component_by_vertex"
.Vb 1
\&   $i = $g\->biconnected_component_by_index($v)
.Ve
.Sp
For an undirected graph, return the indices identifying the biconnected
components the vertex belongs to, the indexing starting from zero.
The order of of the components is undefined.
.Sp
For the inverse, see \*(L"connected_component_by_index\*(R".
.Sp
For directed graphs, see \*(L"strongly_connected_component_by_index\*(R"
and \*(L"weakly_connected_component_by_index\*(R".
.IP "biconnected_component_by_index" 4
.IX Item "biconnected_component_by_index"
.Vb 1
\&   @v = $g\->biconnected_component_by_index($i)
.Ve
.Sp
For an undirected graph, return the vertices in the ith biconnected
component of the graph as an anonymous arrays of vertices in the
component.  The ordering of the vertices within a component is
undefined.  Also note that one vertex can belong to more than one
biconnected component.
.IP "same_biconnected_components" 4
.IX Item "same_biconnected_components"
.Vb 1
\&    $g\->same_biconnected_components($u, $v, ...)
.Ve
.Sp
For an undirected graph, return true if the vertices are in the same
biconnected component.
.IP "biconnected_graph" 4
.IX Item "biconnected_graph"
.Vb 1
\&    $bcg = $g\->biconnected_graph
.Ve
.Sp
For an undirected graph, return its biconnected graph.
.Sp
See \*(L"Connected Graphs and Their Components\*(R" for further discussion.
.IP "bridges" 4
.IX Item "bridges"
.Vb 1
\&   $g\->bridges
.Ve
.Sp
For an undirected graph, return the bridges of the graph as a list of
anonymous arrays of vertices in the bridges.  The order of bridges and
the order of vertices in them is undefined.
.IP "biconnectivity_clear_cache" 4
.IX Item "biconnectivity_clear_cache"
.Vb 1
\&    $g\->biconnectivity_clear_cache
.Ve
.Sp
See \*(L"Clearing cached results\*(R".
.IP "strongly_connected" 4
.IX Item "strongly_connected"
.PD 0
.IP "is_strongly_connected" 4
.IX Item "is_strongly_connected"
.PD
.Vb 1
\&    $g\->is_strongly_connected
.Ve
.Sp
For a directed graph, return true is the directed graph is strongly
connected, false if not.
.Sp
See also \*(L"is_weakly_connected\*(R".
.Sp
For undirected graphs, see \*(L"is_connected\*(R", or \*(L"is_biconnected\*(R".
.IP "strongly_connected_component_by_vertex" 4
.IX Item "strongly_connected_component_by_vertex"
.Vb 1
\&    $i = $g\->strongly_connected_component_by_vertex($v)
.Ve
.Sp
For a directed graph, return an index identifying the strongly
connected component the vertex belongs to, the indexing starting from
zero.
.Sp
For the inverse, see \*(L"strongly_connected_component_by_index\*(R".
.Sp
See also \*(L"weakly_connected_component_by_vertex\*(R".
.Sp
For undirected graphs, see \*(L"connected_components\*(R" or
\&\*(L"biconnected_components\*(R".
.IP "strongly_connected_component_by_index" 4
.IX Item "strongly_connected_component_by_index"
.Vb 1
\&    @v = $g\->strongly_connected_component_by_index($i)
.Ve
.Sp
For a directed graph, return the vertices of the ith connected
component, the indexing starting from zero.  The order of vertices
within a component is undefined, while the order of the connected
components is the as from \fIstrongly_connected_components()\fR.
.Sp
For the inverse, see \*(L"strongly_connected_component_by_vertex\*(R".
.Sp
For undirected graphs, see \*(L"weakly_connected_component_by_index\*(R".
.IP "same_strongly_connected_components" 4
.IX Item "same_strongly_connected_components"
.Vb 1
\&    $g\->same_strongly_connected_components($u, $v, ...)
.Ve
.Sp
For a directed graph, return true if the vertices are in the same
strongly connected component.
.Sp
See also \*(L"same_weakly_connected_components\*(R".
.Sp
For undirected graphs, see \*(L"same_connected_components\*(R" or
\&\*(L"same_biconnected_components\*(R".
.IP "strong_connectivity_clear_cache" 4
.IX Item "strong_connectivity_clear_cache"
.Vb 1
\&    $g\->strong_connectivity_clear_cache
.Ve
.Sp
See \*(L"Clearing cached results\*(R".
.IP "weakly_connected" 4
.IX Item "weakly_connected"
.PD 0
.IP "is_weakly_connected" 4
.IX Item "is_weakly_connected"
.PD
.Vb 1
\&    $g\->is_weakly_connected
.Ve
.Sp
For a directed graph, return true is the directed graph is weakly
connected, false if not.
.Sp
Weakly connected graph is also known as \fIsemiconnected\fR graph.
.Sp
See also \*(L"is_strongly_connected\*(R".
.Sp
For undirected graphs, see \*(L"is_connected\*(R" or \*(L"is_biconnected\*(R".
.IP "weakly_connected_components" 4
.IX Item "weakly_connected_components"
.Vb 1
\&    @wcc = $g\->weakly_connected_components()
.Ve
.Sp
For a directed graph, returns the vertices of the weakly connected
components of the graph as a list of anonymous arrays.  The ordering
of the anonymous arrays or the ordering of the vertices inside the
anonymous arrays (the components) is undefined.
.Sp
See also \*(L"strongly_connected_components\*(R".
.Sp
For undirected graphs, see \*(L"connected_components\*(R" or
\&\*(L"biconnected_components\*(R".
.IP "weakly_connected_component_by_vertex" 4
.IX Item "weakly_connected_component_by_vertex"
.Vb 1
\&    $i = $g\->weakly_connected_component_by_vertex($v)
.Ve
.Sp
For a directed graph, return an index identifying the weakly connected
component the vertex belongs to, the indexing starting from zero.
.Sp
For the inverse, see \*(L"weakly_connected_component_by_index\*(R".
.Sp
For undirected graphs, see \*(L"connected_component_by_vertex\*(R"
and \*(L"biconnected_component_by_vertex\*(R".
.IP "weakly_connected_component_by_index" 4
.IX Item "weakly_connected_component_by_index"
.Vb 1
\&    @v = $g\->weakly_connected_component_by_index($i)
.Ve
.Sp
For a directed graph, return the vertices of the ith weakly connected
component, the indexing starting zero.  The order of vertices within
a component is undefined, while the order of the weakly connected
components is same as from \fIweakly_connected_components()\fR.
.Sp
For the inverse, see \*(L"weakly_connected_component_by_vertex\*(R".
.Sp
For undirected graphs, see connected_component_by_index
and biconnected_component_by_index.
.IP "same_weakly_connected_components" 4
.IX Item "same_weakly_connected_components"
.Vb 1
\&    $g\->same_weakly_connected_components($u, $v, ...)
.Ve
.Sp
Return true if the vertices are in the same weakly connected component.
.IP "weakly_connected_graph" 4
.IX Item "weakly_connected_graph"
.Vb 1
\&    $wcg = $g\->weakly_connected_graph
.Ve
.Sp
For a directed graph, return its weakly connected graph.
.Sp
For undirected graphs, see \*(L"connected_graph\*(R" and \*(L"biconnected_graph\*(R".
.IP "strongly_connected_components" 4
.IX Item "strongly_connected_components"
.Vb 1
\&   my @scc = $g\->strongly_connected_components;
.Ve
.Sp
For a directed graph, return the strongly connected components as a
list of anonymous arrays.  The elements in the anonymous arrays are
the vertices belonging to the strongly connected component; both the
elements and the components are in no particular order.
.Sp
Note that strongly connected components can have single-element
components even without self-loops: if a vertex is any of \fIisolated\fR,
\&\fIsink\fR, or a \fIsource\fR, the vertex is alone in its own strong component.
.Sp
See also \*(L"weakly_connected_components\*(R".
.Sp
For undirected graphs, see \*(L"connected_components\*(R",
or see \*(L"biconnected_components\*(R".
.IP "strongly_connected_graph" 4
.IX Item "strongly_connected_graph"
.Vb 1
\&   my $scg = $g\->strongly_connected_graph;
.Ve
.Sp
See \*(L"Connected Graphs and Their Components\*(R" for further discussion.
.Sp
Strongly connected graphs are also known as \fIkernel graphs\fR.
.Sp
See also \*(L"weakly_connected_graph\*(R".
.Sp
For undirected graphs, see \*(L"connected_graph\*(R", or \*(L"biconnected_graph\*(R".
.IP "is_sink_vertex" 4
.IX Item "is_sink_vertex"
.Vb 1
\&    $g\->is_sink_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR is a sink vertex, false if not.  A sink
vertex is defined as a vertex with predecessors but no successors:
this definition means that isolated vertices are not sink vertices.
If you want also isolated vertices, use \fIis_successorless_vertex()\fR.
.IP "is_source_vertex" 4
.IX Item "is_source_vertex"
.Vb 1
\&    $g\->is_source_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR is a source vertex, false if not.  A source
vertex is defined as a vertex with successors but no predecessors:
the definition means that isolated vertices are not source vertices.
If you want also isolated vertices, use \fIis_predecessorless_vertex()\fR.
.IP "is_successorless_vertex" 4
.IX Item "is_successorless_vertex"
.Vb 1
\&    $g\->is_successorless_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR has no succcessors (no edges
leaving the vertex), false if it has.
.Sp
Isolated vertices will return true: if you do not want this,
use \fIis_sink_vertex()\fR.
.IP "is_successorful_vertex" 4
.IX Item "is_successorful_vertex"
.Vb 1
\&    $g\->is_successorful_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR has successors, false if not.
.IP "is_predecessorless_vertex" 4
.IX Item "is_predecessorless_vertex"
.Vb 1
\&    $g\->is_predecessorless_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR has no predecessors (no edges
entering the vertex), false if it has.
.Sp
Isolated vertices will return true: if you do not want this,
use \fIis_source_vertex()\fR.
.IP "is_predecessorful_vertex" 4
.IX Item "is_predecessorful_vertex"
.Vb 1
\&    $g\->is_predecessorful_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR has predecessors, false if not.
.IP "is_isolated_vertex" 4
.IX Item "is_isolated_vertex"
.Vb 1
\&    $g\->is_isolated_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR is an isolated vertex: no successors
and no predecessors.
.IP "is_interior_vertex" 4
.IX Item "is_interior_vertex"
.Vb 1
\&    $g\->is_interior_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR is an interior vertex: both successors
and predecessors.
.IP "is_exterior_vertex" 4
.IX Item "is_exterior_vertex"
.Vb 1
\&    $g\->is_exterior_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR is an exterior vertex: has either no
successors or no predecessors, or neither.
.IP "is_self_loop_vertex" 4
.IX Item "is_self_loop_vertex"
.Vb 1
\&    $g\->is_self_loop_vertex($v)
.Ve
.Sp
Return true if the vertex \f(CW$v\fR is a self loop vertex: has an edge
from itself to itself.
.IP "sink_vertices" 4
.IX Item "sink_vertices"
.Vb 1
\&    @v = $g\->sink_vertices()
.Ve
.Sp
Return the sink vertices of the graph.
In scalar context return the number of sink vertices.
See \*(L"is_sink_vertex\*(R" for the definition of a sink vertex.
.IP "source_vertices" 4
.IX Item "source_vertices"
.Vb 1
\&    @v = $g\->source_vertices()
.Ve
.Sp
Return the source vertices of the graph.
In scalar context return the number of source vertices.
See \*(L"is_source_vertex\*(R" for the definition of a source vertex.
.IP "successorful_vertices" 4
.IX Item "successorful_vertices"
.Vb 1
\&    @v = $g\->successorful_vertices()
.Ve
.Sp
Return the successorful vertices of the graph.
In scalar context return the number of successorful vertices.
.IP "successorless_vertices" 4
.IX Item "successorless_vertices"
.Vb 1
\&    @v = $g\->successorless_vertices()
.Ve
.Sp
Return the successorless vertices of the graph.
In scalar context return the number of successorless vertices.
.IP "successors" 4
.IX Item "successors"
.Vb 1
\&    @s = $g\->successors($v)
.Ve
.Sp
Return the immediate successor vertices of the vertex.
.Sp
See also \*(L"all_successors\*(R", \*(L"all_neighbours\*(R", and \*(L"all_reachable\*(R".
.IP "all_successors" 4
.IX Item "all_successors"
.Vb 1
\&    @s = $g\->all_successors(@v)
.Ve
.Sp
For a directed graph, returns all successor vertices of the argument
vertices, recursively.
.Sp
For undirected graphs, see \*(L"all_neighbours\*(R" and \*(L"all_reachable\*(R".
.Sp
See also \*(L"successors\*(R".
.IP "neighbors" 4
.IX Item "neighbors"
.PD 0
.IP "neighbours" 4
.IX Item "neighbours"
.PD
.Vb 1
\&    @n = $g\->neighbours($v)
.Ve
.Sp
Return the neighboring/neighbouring vertices.  Also known as the
\&\fIadjacent vertices\fR.
.Sp
See also \*(L"all_neighbours\*(R" and \*(L"all_reachable\*(R".
.IP "all_neighbors" 4
.IX Item "all_neighbors"
.PD 0
.IP "all_neighbours" 4
.IX Item "all_neighbours"
.PD
.Vb 1
\&   @n = $g\->all_neighbours(@v)
.Ve
.Sp
Return the neighboring/neighbouring vertices of the argument vertices,
recursively.  For a directed graph, recurses up predecessors and down
successors.  For an undirected graph, returns all the vertices
reachable from the argument vertices: equivalent to \f(CW\*(C`all_reachable\*(C'\fR.
.Sp
See also \*(L"neighbours\*(R" and \*(L"all_reachable\*(R".
.IP "all_reachable" 4
.IX Item "all_reachable"
.Vb 1
\&    @r = $g\->all_reachable(@v)
.Ve
.Sp
Return all the vertices reachable from of the argument vertices,
recursively.  For a directed graph, equivalent to \f(CW\*(C`all_successors\*(C'\fR.
For an undirected graph, equivalent to \f(CW\*(C`all_neighbours\*(C'\fR.  The argument
vertices are not included in the results unless there are explicit
self-loops.
.Sp
See also \*(L"neighbours\*(R", \*(L"all_neighbours\*(R", and \*(L"all_successors\*(R".
.IP "predecessorful_vertices" 4
.IX Item "predecessorful_vertices"
.Vb 1
\&    @v = $g\->predecessorful_vertices()
.Ve
.Sp
Return the predecessorful vertices of the graph.
In scalar context return the number of predecessorful vertices.
.IP "predecessorless_vertices" 4
.IX Item "predecessorless_vertices"
.Vb 1
\&    @v = $g\->predecessorless_vertices()
.Ve
.Sp
Return the predecessorless vertices of the graph.
In scalar context return the number of predecessorless vertices.
.IP "predecessors" 4
.IX Item "predecessors"
.Vb 1
\&    @p = $g\->predecessors($v)
.Ve
.Sp
Return the immediate predecessor vertices of the vertex.
.Sp
See also \*(L"all_predecessors\*(R", \*(L"all_neighbours\*(R", and \*(L"all_reachable\*(R".
.IP "all_predecessors" 4
.IX Item "all_predecessors"
.Vb 1
\&    @p = $g\->all_predecessors(@v)
.Ve
.Sp
For a directed graph, returns all predecessor vertices of the argument
vertices, recursively.
.Sp
For undirected graphs, see \*(L"all_neighbours\*(R" and \*(L"all_reachable\*(R".
.Sp
See also \*(L"predecessors\*(R".
.IP "isolated_vertices" 4
.IX Item "isolated_vertices"
.Vb 1
\&    @v = $g\->isolated_vertices()
.Ve
.Sp
Return the isolated vertices of the graph.
In scalar context return the number of isolated vertices.
See \*(L"is_isolated_vertex\*(R" for the definition of an isolated vertex.
.IP "interior_vertices" 4
.IX Item "interior_vertices"
.Vb 1
\&    @v = $g\->interior_vertices()
.Ve
.Sp
Return the interior vertices of the graph.
In scalar context return the number of interior vertices.
See \*(L"is_interior_vertex\*(R" for the definition of an interior vertex.
.IP "exterior_vertices" 4
.IX Item "exterior_vertices"
.Vb 1
\&    @v = $g\->exterior_vertices()
.Ve
.Sp
Return the exterior vertices of the graph.
In scalar context return the number of exterior vertices.
See \*(L"is_exterior_vertex\*(R" for the definition of an exterior vertex.
.IP "self_loop_vertices" 4
.IX Item "self_loop_vertices"
.Vb 1
\&    @v = $g\->self_loop_vertices()
.Ve
.Sp
Return the self-loop vertices of the graph.
In scalar context return the number of self-loop vertices.
See \*(L"is_self_loop_vertex\*(R" for the definition of a self-loop vertex.
.SS "Connected Graphs and Their Components"
.IX Subsection "Connected Graphs and Their Components"
In this discussion \fIconnected graph\fR refers to any of
\&\fIconnected graphs\fR, \fIbiconnected graphs\fR, and \fIstrongly
connected graphs\fR.
.PP
\&\fB\s-1NOTE\s0\fR: if the vertices of the original graph are Perl objects,
(in other words, references, so you must be using \f(CW\*(C`refvertexed\*(C'\fR) 
the vertices of the \fIconnected graph\fR are \s-1NOT\s0 by default usable
as Perl objects because they are blessed into a package with
a rather unusable name.
.PP
By default, the vertex names of the \fIconnected graph\fR are formed from
the names of the vertices of the original graph by (alphabetically
sorting them and) concatenating their names with \f(CW\*(C`+\*(C'\fR.  The vertex
attribute \f(CW\*(C`subvertices\*(C'\fR is also used to store the list (as an array
reference) of the original vertices.  To change the 'supercomponent'
vertex names and the whole logic of forming these supercomponents
use the \f(CW\*(C`super_component\*(C'\fR) option to the method calls:
.PP
.Vb 3
\&  $g\->connected_graph(super_component => sub { ... })
\&  $g\->biconnected_graph(super_component => sub { ... })
\&  $g\->strongly_connected_graph(super_component => sub { ... })
.Ve
.PP
The subroutine reference gets the 'subcomponents' (the vertices of the
original graph) as arguments, and it is supposed to return the new
supercomponent vertex, the \*(L"stringified\*(R" form of which is used as the
vertex name.
.SS "Degree"
.IX Subsection "Degree"
A vertex has a degree based on the number of incoming and outgoing edges.
This really makes sense only for directed graphs.
.IP "degree" 4
.IX Item "degree"
.PD 0
.IP "vertex_degree" 4
.IX Item "vertex_degree"
.PD
.Vb 2
\&    $d = $g\->degree($v)
\&    $d = $g\->vertex_degree($v)
.Ve
.Sp
For directed graphs: the in-degree minus the out-degree at the vertex.
.Sp
For undirected graphs: the number of edges at the vertex  (identical to
\&\f(CW\*(C`in_degree()\*(C'\fR, \f(CW\*(C`out_degree()\*(C'\fR).
.IP "in_degree" 4
.IX Item "in_degree"
.Vb 1
\&    $d = $g\->in_degree($v)
.Ve
.Sp
For directed graphs: the number of incoming edges at the vertex.
.Sp
For undirected graphs: the number of edges at the vertex (identical to
\&\f(CW\*(C`out_degree()\*(C'\fR, \f(CW\*(C`degree()\*(C'\fR, \f(CW\*(C`vertex_degree()\*(C'\fR).
.IP "out_degree" 4
.IX Item "out_degree"
.Vb 1
\&    $o = $g\->out_degree($v)
.Ve
.Sp
For directed graphs: The number of outgoing edges at the vertex.
.Sp
For undirected graphs: the number of edges at the vertex (identical to
\&\f(CW\*(C`in_degree()\*(C'\fR, \f(CW\*(C`degree()\*(C'\fR, \f(CW\*(C`vertex_degree()\*(C'\fR).
.IP "average_degree" 4
.IX Item "average_degree"
.Vb 1
\&   my $ad = $g\->average_degree;
.Ve
.Sp
Return the average degree (as in \f(CW\*(C`degree()\*(C'\fR or \f(CW\*(C`vertex_degree()\*(C'\fR)
taken over all vertices.
.PP
Related methods are
.IP "edges_at" 4
.IX Item "edges_at"
.Vb 1
\&    @e = $g\->edges_at($v)
.Ve
.Sp
The union of edges from and edges to at the vertex.
.IP "edges_from" 4
.IX Item "edges_from"
.Vb 1
\&    @e = $g\->edges_from($v)
.Ve
.Sp
The edges leaving the vertex.
.IP "edges_to" 4
.IX Item "edges_to"
.Vb 1
\&    @e = $g\->edges_to($v)
.Ve
.Sp
The edges entering the vertex.
.PP
See also \*(L"average_degree\*(R".
.SS "Counted Vertices"
.IX Subsection "Counted Vertices"
\&\fICounted vertices\fR are vertices with more than one instance, normally
adding vertices is idempotent.  To enable counted vertices on a graph,
give the \f(CW\*(C`countvertexed\*(C'\fR parameter a true value
.PP
.Vb 2
\&    use Graph;
\&    my $g = Graph\->new(countvertexed => 1);
.Ve
.PP
To find out how many times the vertex has been added:
.IP "get_vertex_count" 4
.IX Item "get_vertex_count"
.Vb 1
\&    my $c = $g\->get_vertex_count($v);
.Ve
.Sp
Return the count of the vertex, or undef if the vertex does not exist.
.SS "Multiedges, Multivertices, Multigraphs"
.IX Subsection "Multiedges, Multivertices, Multigraphs"
\&\fIMultiedges\fR are edges with more than one \*(L"life\*(R", meaning that one
has to delete them as many times as they have been added.  Normally
adding edges is idempotent (in other words, adding edges more than
once makes no difference).
.PP
There are two kinds or degrees of creating multiedges and multivertices.
The two kinds are mutually exclusive.
.PP
The weaker kind is called \fIcounted\fR, in which the edge or vertex has
a count on it: add operations increase the count, and delete
operations decrease the count, and once the count goes to zero, the
edge or vertex is deleted.  If there are attributes, they all are
attached to the same vertex.  You can think of this as the graph
elements being \fIrefcounted\fR, or \fIreference counted\fR, if that sounds
more familiar.
.PP
The stronger kind is called (true) \fImulti\fR, in which the edge or vertex
really has multiple separate identities, so that you can for example
attach different attributes to different instances.
.PP
To enable multiedges on a graph:
.PP
.Vb 3
\&    use Graph;
\&    my $g0 = Graph\->new(countedged => 1);
\&    my $g0 = Graph\->new(multiedged => 1);
.Ve
.PP
Similarly for vertices
.PP
.Vb 3
\&    use Graph;
\&    my $g1 = Graph\->new(countvertexed => 1);
\&    my $g1 = Graph\->new(multivertexed => 1);
.Ve
.PP
You can test for these by
.IP "is_countedged" 4
.IX Item "is_countedged"
.PD 0
.IP "countedged" 4
.IX Item "countedged"
.PD
.Vb 2
\&    $g\->is_countedged
\&    $g\->countedged
.Ve
.Sp
Return true if the graph is countedged.
.IP "is_countvertexed" 4
.IX Item "is_countvertexed"
.PD 0
.IP "countvertexed" 4
.IX Item "countvertexed"
.PD
.Vb 2
\&    $g\->is_countvertexed
\&    $g\->countvertexed
.Ve
.Sp
Return true if the graph is countvertexed.
.IP "is_multiedged" 4
.IX Item "is_multiedged"
.PD 0
.IP "multiedged" 4
.IX Item "multiedged"
.PD
.Vb 2
\&    $g\->is_multiedged
\&    $g\->multiedged
.Ve
.Sp
Return true if the graph is multiedged.
.IP "is_multivertexed" 4
.IX Item "is_multivertexed"
.PD 0
.IP "multivertexed" 4
.IX Item "multivertexed"
.PD
.Vb 2
\&    $g\->is_multivertexed
\&    $g\->multivertexed
.Ve
.Sp
Return true if the graph is multivertexed.
.PP
A multiedged (either the weak kind or the strong kind) graph is
a \fImultigraph\fR, for which you can test with \f(CW\*(C`is_multi_graph()\*(C'\fR.
.PP
\&\fB\s-1NOTE\s0\fR: The various graph algorithms do not in general work well with
multigraphs (they often assume \fIsimple graphs\fR, that is, no
multiedges or loops), and no effort has been made to test the
algorithms with multigraphs.
.PP
\&\fIvertices()\fR and \fIedges()\fR will return the multiple elements: if you want
just the unique elements, use
.IP "unique_vertices" 4
.IX Item "unique_vertices"
.PD 0
.IP "unique_edges" 4
.IX Item "unique_edges"
.PD
.Vb 4
\&    @uv = $g\->unique_vertices; # unique
\&    @mv = $g\->vertices;        # possible multiples
\&    @ue = $g\->unique_edges;
\&    @me = $g\->edges;
.Ve
.PP
If you are using (the stronger kind of) multielements, you should use
the \fIby_id\fR variants:
.IP "add_vertex_by_id" 4
.IX Item "add_vertex_by_id"
.PD 0
.IP "has_vertex_by_id" 4
.IX Item "has_vertex_by_id"
.IP "delete_vertex_by_id" 4
.IX Item "delete_vertex_by_id"
.IP "add_edge_by_id" 4
.IX Item "add_edge_by_id"
.IP "has_edge_by_id" 4
.IX Item "has_edge_by_id"
.IP "delete_edge_by_id" 4
.IX Item "delete_edge_by_id"
.PD
.PP
.Vb 3
\&    $g\->add_vertex_by_id($v, $id)
\&    $g\->has_vertex_by_id($v, $id)
\&    $g\->delete_vertex_by_id($v, $id)
\&
\&    $g\->add_edge_by_id($u, $v, $id)
\&    $g\->has_edge_by_id($u, $v, $id)
\&    $g\->delete_edge_by_id($u, $v, $id)
.Ve
.PP
These interfaces only apply to multivertices and multiedges.
When you delete the last vertex/edge in a multivertex/edge, the whole
vertex/edge is deleted.  You can use \fIadd_vertex()\fR/\fIadd_edge()\fR on
a multivertex/multiedge graph, in which case an id is generated
automatically.  To find out which the generated id was, you need
to use
.IP "add_vertex_get_id" 4
.IX Item "add_vertex_get_id"
.PD 0
.IP "add_edge_get_id" 4
.IX Item "add_edge_get_id"
.PD
.PP
.Vb 2
\&    $idv = $g\->add_vertex_get_id($v)
\&    $ide = $g\->add_edge_get_id($u, $v)
.Ve
.PP
To return all the ids of vertices/edges in a multivertex/multiedge, use
.IP "get_multivertex_ids" 4
.IX Item "get_multivertex_ids"
.PD 0
.IP "get_multiedge_ids" 4
.IX Item "get_multiedge_ids"
.PD
.PP
.Vb 2
\&    $g\->get_multivertex_ids($v)
\&    $g\->get_multiedge_ids($u, $v)
.Ve
.PP
The ids are returned in random order.
.PP
To find out how many times the edge has been added (this works for
either kind of multiedges):
.IP "get_edge_count" 4
.IX Item "get_edge_count"
.Vb 1
\&    my $c = $g\->get_edge_count($u, $v);
.Ve
.Sp
Return the count (the \*(L"countedness\*(R") of the edge, or undef if the
edge does not exist.
.PP
The following multi-entity utility functions exist, mirroring
the non-multi vertices and edges:
.IP "add_weighted_edge_by_id" 4
.IX Item "add_weighted_edge_by_id"
.PD 0
.IP "add_weighted_edges_by_id" 4
.IX Item "add_weighted_edges_by_id"
.IP "add_weighted_path_by_id" 4
.IX Item "add_weighted_path_by_id"
.IP "add_weighted_vertex_by_id" 4
.IX Item "add_weighted_vertex_by_id"
.IP "add_weighted_vertices_by_id" 4
.IX Item "add_weighted_vertices_by_id"
.IP "delete_edge_weight_by_id" 4
.IX Item "delete_edge_weight_by_id"
.IP "delete_vertex_weight_by_id" 4
.IX Item "delete_vertex_weight_by_id"
.IP "get_edge_weight_by_id" 4
.IX Item "get_edge_weight_by_id"
.IP "get_vertex_weight_by_id" 4
.IX Item "get_vertex_weight_by_id"
.IP "has_edge_weight_by_id" 4
.IX Item "has_edge_weight_by_id"
.IP "has_vertex_weight_by_id" 4
.IX Item "has_vertex_weight_by_id"
.IP "set_edge_weight_by_id" 4
.IX Item "set_edge_weight_by_id"
.IP "set_vertex_weight_by_id" 4
.IX Item "set_vertex_weight_by_id"
.PD
.SS "Topological Sort"
.IX Subsection "Topological Sort"
.IP "topological_sort" 4
.IX Item "topological_sort"
.PD 0
.IP "toposort" 4
.IX Item "toposort"
.PD
.Vb 1
\&    my @ts = $g\->topological_sort;
.Ve
.Sp
Return the vertices of the graph sorted topologically.  Note that
there may be several possible topological orderings; one of them
is returned.
.Sp
If the graph contains a cycle, a fatal error is thrown, you
can either use \f(CW\*(C`eval\*(C'\fR to trap that, or supply the \f(CW\*(C`empty_if_cyclic\*(C'\fR
argument with a true value
.Sp
.Vb 1
\&    my @ts = $g\->topological_sort(empty_if_cyclic => 1);
.Ve
.Sp
in which case an empty array is returned if the graph is cyclic.
.SS "Minimum Spanning Trees (\s-1MST\s0)"
.IX Subsection "Minimum Spanning Trees (MST)"
Minimum Spanning Trees or MSTs are tree subgraphs derived from an
undirected graph.  MSTs \*(L"span the graph\*(R" (covering all the vertices)
using as lightly weighted (hence the \*(L"minimum\*(R") edges as possible.
.IP "MST_Kruskal" 4
.IX Item "MST_Kruskal"
.Vb 1
\&    $mstg = $g\->MST_Kruskal;
.Ve
.Sp
Returns the Kruskal \s-1MST\s0 of the graph.
.IP "MST_Prim" 4
.IX Item "MST_Prim"
.Vb 1
\&    $mstg = $g\->MST_Prim(%opt);
.Ve
.Sp
Returns the Prim \s-1MST\s0 of the graph.
.Sp
You can choose the first vertex with \f(CW$opt\fR{ first_root }.
.IP "MST_Dijkstra" 4
.IX Item "MST_Dijkstra"
.PD 0
.IP "minimum_spanning_tree" 4
.IX Item "minimum_spanning_tree"
.PD
.Vb 2
\&    $mstg = $g\->MST_Dijkstra;
\&    $mstg = $g\->minimum_spanning_tree;
.Ve
.Sp
Aliases for MST_Prim.
.SS "Single-Source Shortest Paths (\s-1SSSP\s0)"
.IX Subsection "Single-Source Shortest Paths (SSSP)"
Single-source shortest paths, also known as Shortest Path Trees
(SPTs).  For either a directed or an undirected graph, return a (tree)
subgraph that from a single start vertex (the \*(L"single source\*(R") travels
the shortest possible paths (the paths with the lightest weights) to
all the other vertices.  Note that the \s-1SSSP\s0 is neither reflexive (the
shortest paths do not include the zero-length path from the source
vertex to the source vertex) nor transitive (the shortest paths do not
include transitive closure paths).  If no weight is defined for an
edge, 1 (one) is assumed.
.IP "SPT_Dijkstra" 4
.IX Item "SPT_Dijkstra"
.Vb 2
\&    $sptg = $g\->SPT_Dijkstra($root)
\&    $sptg = $g\->SPT_Dijkstra(%opt)
.Ve
.Sp
Return as a graph the the single-source shortest paths of the graph
using Dijkstra's algorithm.  The graph cannot contain negative edges
(negative edges cause the algorithm to abort with an error message
\&\f(CW\*(C`Graph::SPT_Dijkstra: edge ... is negative\*(C'\fR).
.Sp
You can choose the first vertex of the result with either a single
vertex argument or with \f(CW$opt\fR{ first_root }, otherwise a random vertex
is chosen.
.Sp
\&\fB\s-1NOTE\s0\fR: note that all the vertices might not be reachable from the
selected (explicit or random) start vertex.
.Sp
\&\fB\s-1NOTE\s0\fR: after the first reachable tree from the first start vertex
has been finished, and if there still are unvisited vertices,
SPT_Dijkstra will keep on selecting unvisited vertices.
.Sp
The next roots (in case the first tree doesn't visit all the vertices)
can be chosen by setting one of the following options to true:
\&\f(CW\*(C`next_root\*(C'\fR, \f(CW\*(C`next_alphabetic\*(C'\fR, \f(CW\*(C`next_numeric\*(C'\fR, \f(CW\*(C`next_random\*(C'\fR.
.Sp
The \f(CW\*(C`next_root\*(C'\fR is the most customizable: the value needs to be
a subroutine reference which will receive the graph and the unvisited
vertices as hash reference.  If you want to only visit the first tree,
use \f(CW\*(C`next_root =\*(C'\fR sub { undef }>.  The rest of these options are
booleans.  If none of them are true, a random unvisited vertex will be
selected.
.Sp
The first start vertex is be available as the graph attribute
\&\f(CW\*(C`SPT_Dijkstra_root\*(C'\fR).
.Sp
The result weights of vertices can be retrieved from the result graph by
.Sp
.Vb 1
\&        my $w = $sptg\->get_vertex_attribute($v, \*(Aqweight\*(Aq);
.Ve
.Sp
The predecessor vertex of a vertex in the result graph
can be retrieved by
.Sp
.Vb 1
\&        my $u = $sptg\->get_vertex_attribute($v, \*(Aqp\*(Aq);
.Ve
.Sp
(\*(L"A successor vertex\*(R" cannot be retrieved as simply because a single
vertex can have several successors.  You can first find the
\&\f(CW\*(C`neighbors()\*(C'\fR vertices and then remove the predecessor vertex.)
.Sp
If you want to find the shortest path between two vertices,
see \*(L"SP_Dijkstra\*(R".
.IP "SSSP_Dijkstra" 4
.IX Item "SSSP_Dijkstra"
.PD 0
.IP "single_source_shortest_paths" 4
.IX Item "single_source_shortest_paths"
.PD
Aliases for SPT_Dijkstra.
.IP "SP_Dijkstra" 4
.IX Item "SP_Dijkstra"
.Vb 1
\&    @path = $g\->SP_Dijkstra($u, $v)
.Ve
.Sp
Return the vertices in the shortest path in the graph \f(CW$g\fR between the
two vertices \f(CW$u\fR, \f(CW$v\fR.  If no path can be found, an empty list is returned.
.Sp
Uses \fISPT_Dijkstra()\fR.
.IP "SPT_Dijkstra_clear_cache" 4
.IX Item "SPT_Dijkstra_clear_cache"
.Vb 1
\&    $g\->SPT_Dijkstra_clear_cache
.Ve
.Sp
See \*(L"Clearing cached results\*(R".
.IP "SPT_Bellman_Ford" 4
.IX Item "SPT_Bellman_Ford"
.Vb 1
\&    $sptg = $g\->SPT_Bellman_Ford(%opt)
.Ve
.Sp
Return as a graph the single-source shortest paths of the graph using
Bellman-Ford's algorithm.  The graph can contain negative edges but
not negative cycles (negative cycles cause the algorithm to abort
with an error message \f(CW\*(C`Graph::SPT_Bellman_Ford: negative cycle exists/\*(C'\fR).
.Sp
You can choose the start vertex of the result with either a single
vertex argument or with \f(CW$opt\fR{ first_root }, otherwise a random vertex
is chosen.
.Sp
\&\fB\s-1NOTE\s0\fR: note that all the vertices might not be reachable from the
selected (explicit or random) start vertex.
.Sp
The start vertex is be available as the graph attribute
\&\f(CW\*(C`SPT_Bellman_Ford_root\*(C'\fR).
.Sp
The result weights of vertices can be retrieved from the result graph by
.Sp
.Vb 1
\&        my $w = $sptg\->get_vertex_attribute($v, \*(Aqweight\*(Aq);
.Ve
.Sp
The predecessor vertex of a vertex in the result graph
can be retrieved by
.Sp
.Vb 1
\&        my $u = $sptg\->get_vertex_attribute($v, \*(Aqp\*(Aq);
.Ve
.Sp
(\*(L"A successor vertex\*(R" cannot be retrieved as simply because a single
vertex can have several successors.  You can first find the
\&\f(CW\*(C`neighbors()\*(C'\fR vertices and then remove the predecessor vertex.)
.Sp
If you want to find the shortes path between two vertices,
see \*(L"SP_Bellman_Ford\*(R".
.IP "SSSP_Bellman_Ford" 4
.IX Item "SSSP_Bellman_Ford"
Alias for SPT_Bellman_Ford.
.IP "SP_Bellman_Ford" 4
.IX Item "SP_Bellman_Ford"
.Vb 1
\&    @path = $g\->SP_Bellman_Ford($u, $v)
.Ve
.Sp
Return the vertices in the shortest path in the graph \f(CW$g\fR between the
two vertices \f(CW$u\fR, \f(CW$v\fR.  If no path can be found, an empty list is returned.
.Sp
Uses \fISPT_Bellman_Ford()\fR.
.IP "SPT_Bellman_Ford_clear_cache" 4
.IX Item "SPT_Bellman_Ford_clear_cache"
.Vb 1
\&    $g\->SPT_Bellman_Ford_clear_cache
.Ve
.Sp
See \*(L"Clearing cached results\*(R".
.SS "All-Pairs Shortest Paths (\s-1APSP\s0)"
.IX Subsection "All-Pairs Shortest Paths (APSP)"
For either a directed or an undirected graph, return the \s-1APSP\s0 object
describing all the possible paths between any two vertices of the
graph.  If no weight is defined for an edge, 1 (one) is assumed.
.PP
Note that weight of 0 (zero) does not mean do not use this edge, it
means essentially the opposite: an edge that has zero cost, an edge
that makes the vertices the same.
.IP "APSP_Floyd_Warshall" 4
.IX Item "APSP_Floyd_Warshall"
.PD 0
.IP "all_pairs_shortest_paths" 4
.IX Item "all_pairs_shortest_paths"
.PD
.Vb 1
\&    my $apsp = $g\->APSP_Floyd_Warshall(...);
.Ve
.Sp
Return the all-pairs shortest path object computed from the graph
using Floyd-Warshall's algorithm.  The length of a path between two
vertices is the sum of weight attribute of the edges along the
shortest path between the two vertices.  If no weight attribute name
is specified explicitly
.Sp
.Vb 1
\&    $g\->APSP_Floyd_Warshall(attribute_name => \*(Aqheight\*(Aq);
.Ve
.Sp
the attribute \f(CW\*(C`weight\*(C'\fR is assumed.
.Sp
\&\fBIf an edge has no defined weight attribute, the value of one is
assumed when getting the attribute.\fR
.Sp
Once computed, you can query the \s-1APSP\s0 object with
.RS 4
.IP "path_length" 8
.IX Item "path_length"
.Vb 1
\&    my $l = $apsp\->path_length($u, $v);
.Ve
.Sp
Return the length of the shortest path between the two vertices.
.IP "path_vertices" 8
.IX Item "path_vertices"
.Vb 1
\&    my @v = $apsp\->path_vertices($u, $v);
.Ve
.Sp
Return the list of vertices along the shortest path.
.IP "path_predecessor" 8
.IX Item "path_predecessor"
.Vb 1
\&   my $u = $apsp\->path_predecessor($v);
.Ve
.Sp
Returns the predecessor of vertex \f(CW$v\fR in the all-pairs shortest paths.
.RE
.RS 4
.IP "average_path_length" 8
.IX Item "average_path_length"
.Vb 1
\&    my $apl = $g\->average_path_length; # All vertex pairs.
\&
\&    my $apl = $g\->average_path_length($u); # From $u.
\&    my $apl = $g\->average_path_length($u, undef); # From $u.
\&
\&    my $apl = $g\->average_path_length($u, $v); # From $u to $v.
\&
\&    my $apl = $g\->average_path_length(undef, $v); # To $v.
.Ve
.Sp
Return the average (shortest) path length over all the vertex pairs of
the graph, from a vertex, between two vertices, and to a vertex.
.IP "longest_path" 8
.IX Item "longest_path"
.Vb 2
\&    my @lp = $g\->longest_path;
\&    my $lp = $g\->longest_path;
.Ve
.Sp
In scalar context return the \fIlongest shortest\fR path length over all
the vertex pairs of the graph.  In list context return the vertices
along a \fIlongest shortest\fR path.  Note that there might be more than
one such path; this interface returns a random one of them.
.Sp
\&\fB\s-1NOTE\s0\fR: this returns the \fIlongest shortest\fR path, \fBnot\fR the \fIlongest\fR path.
.IP "diameter" 8
.IX Item "diameter"
.PD 0
.IP "graph_diameter" 8
.IX Item "graph_diameter"
.PD
.Vb 1
\&    my $gd = $g\->diameter;
.Ve
.Sp
The longest path over all the vertex pairs is known as the
\&\fIgraph diameter\fR.
.Sp
For an unconnected graph, single-vertex, or empty graph, returns \f(CW\*(C`undef\*(C'\fR.
.IP "shortest_path" 8
.IX Item "shortest_path"
.Vb 2
\&    my @sp = $g\->shortest_path;
\&    my $sp = $g\->shortest_path;
.Ve
.Sp
In scalar context return the shortest length over all the vertex pairs
of the graph.  In list context return the vertices along a shortest
path.  Note that there might be more than one such path; this
interface returns a random one of them.
.Sp
For an unconnected, single-vertex, or empty graph, returns \f(CW\*(C`undef\*(C'\fR
or an empty list.
.IP "radius" 8
.IX Item "radius"
.Vb 1
\&    my $gr = $g\->radius;
.Ve
.Sp
The \fIshortest longest\fR path over all the vertex pairs is known as the
\&\fIgraph radius\fR.  See also \*(L"diameter\*(R".
.Sp
For an unconnected, single-vertex, or empty graph, returns Infinity.
.IP "center_vertices" 8
.IX Item "center_vertices"
.PD 0
.IP "centre_vertices" 8
.IX Item "centre_vertices"
.PD
.Vb 2
\&    my @c = $g\->center_vertices;
\&    my @c = $g\->center_vertices($delta);
.Ve
.Sp
The \fIgraph center\fR is the set of vertices for which the \fIvertex
eccentricity\fR is equal to the \fIgraph radius\fR.  The vertices are
returned in random order.  By specifying a delta value you can widen
the criterion from strict equality (handy for non-integer edge weights).
.Sp
For an unconnected, single-vertex, or empty graph, returns an empty list.
.IP "vertex_eccentricity" 8
.IX Item "vertex_eccentricity"
.Vb 1
\&    my $ve = $g\->vertex_eccentricity($v);
.Ve
.Sp
The longest path to a vertex is known as the \fIvertex eccentricity\fR.
.Sp
If the graph is unconnected, single-vertex, or empty graph, returns Inf.
.RE
.RS 4
.Sp
You can walk through the matrix of the shortest paths by using
.IP "for_shortest_paths" 4
.IX Item "for_shortest_paths"
.Vb 1
\&    $n = $g\->for_shortest_paths($callback)
.Ve
.Sp
The number of shortest paths is returned (this should be equal to V*V).
The \f(CW$callback\fR is a sub reference that receives four arguments:
the transitive closure object from Graph::TransitiveClosure, the two
vertices, and the index to the current shortest paths (0..V*V\-1).
.RE
.RS 4
.RE
.SS "Clearing cached results"
.IX Subsection "Clearing cached results"
For many graph algorithms there are several different but equally valid
results.  (Pseudo)Randomness is used internally by the Graph module to
for example pick a random starting vertex, and to select random edges
from a vertex.
.PP
For efficiency the computed result is often cached to avoid
recomputing the potentially expensive operation, and this also gives
additional determinism (once a correct result has been computed, the
same result will always be given).
.PP
However, sometimes the exact opposite is desireable, and the possible
alternative results are wanted (within the limits of the pseudorandomness:
not all the possible solutions are guaranteed to be returned, usually only
a subset is retuned).  To undo the caching, the following methods are
available:
.IP "\(bu" 4
connectivity_clear_cache
.Sp
Affects \*(L"connected_components\*(R", \*(L"connected_component_by_vertex\*(R",
\&\*(L"connected_component_by_index\*(R", \*(L"same_connected_components\*(R",
\&\*(L"connected_graph\*(R", \*(L"is_connected\*(R", \*(L"is_weakly_connected\*(R",
\&\*(L"weakly_connected_components\*(R", \*(L"weakly_connected_component_by_vertex\*(R",
\&\*(L"weakly_connected_component_by_index\*(R", \*(L"same_weakly_connected_components\*(R",
\&\*(L"weakly_connected_graph\*(R".
.IP "\(bu" 4
biconnectivity_clear_cache
.Sp
Affects \*(L"biconnected_components\*(R",
\&\*(L"biconnected_component_by_vertex\*(R",
\&\*(L"biconnected_component_by_index\*(R", \*(L"is_edge_connected\*(R",
\&\*(L"is_edge_separable\*(R", \*(L"articulation_points\*(R", \*(L"cut_vertices\*(R",
\&\*(L"is_biconnected\*(R", \*(L"biconnected_graph\*(R",
\&\*(L"same_biconnected_components\*(R", \*(L"bridges\*(R".
.IP "\(bu" 4
strong_connectivity_clear_cache
.Sp
Affects \*(L"strongly_connected_components\*(R",
\&\*(L"strongly_connected_component_by_vertex\*(R",
\&\*(L"strongly_connected_component_by_index\*(R",
\&\*(L"same_strongly_connected_components\*(R", \*(L"is_strongly_connected\*(R",
\&\*(L"strongly_connected\*(R", \*(L"strongly_connected_graph\*(R".
.IP "\(bu" 4
SPT_Dijkstra_clear_cache
.Sp
Affects \*(L"SPT_Dijkstra\*(R", \*(L"SSSP_Dijkstra\*(R", \*(L"single_source_shortest_paths\*(R",
\&\*(L"SP_Dijkstra\*(R".
.IP "\(bu" 4
SPT_Bellman_Ford_clear_cache
.Sp
Affects \*(L"SPT_Bellman_Ford\*(R", \*(L"SSSP_Bellman_Ford\*(R", \*(L"SP_Bellman_Ford\*(R".
.PP
Note that any such computed and cached results are of course always
automatically discarded whenever the graph is modified.
.SS "Random"
.IX Subsection "Random"
You can either ask for random elements of existing graphs or create
random graphs.
.IP "random_vertex" 4
.IX Item "random_vertex"
.Vb 1
\&    my $v = $g\->random_vertex;
.Ve
.Sp
Return a random vertex of the graph, or undef if there are no vertices.
.IP "random_edge" 4
.IX Item "random_edge"
.Vb 1
\&    my $e = $g\->random_edge;
.Ve
.Sp
Return a random edge of the graph as an array reference having the
vertices as elements, or undef if there are no edges.
.IP "random_successor" 4
.IX Item "random_successor"
.Vb 1
\&    my $v = $g\->random_successor($v);
.Ve
.Sp
Return a random successor of the vertex in the graph, or undef if there
are no successors.
.IP "random_predecessor" 4
.IX Item "random_predecessor"
.Vb 1
\&    my $u = $g\->random_predecessor($v);
.Ve
.Sp
Return a random predecessor of the vertex in the graph, or undef if there
are no predecessors.
.IP "random_graph" 4
.IX Item "random_graph"
.Vb 1
\&    my $g = Graph\->random_graph(%opt);
.Ve
.Sp
Construct a random graph.  The \fI\f(CI%opt\fI\fR \fBmust\fR contain the \f(CW\*(C`vertices\*(C'\fR
argument
.Sp
.Vb 1
\&    vertices => vertices_def
.Ve
.Sp
where the \fIvertices_def\fR is one of
.RS 4
.IP "\(bu" 8
an array reference where the elements of the array reference are the
vertices
.IP "\(bu" 8
a number N in which case the vertices will be integers 0..N\-1
.RE
.RS 4
.RE
.PP
The \f(CW%opt\fR may have either of the argument \f(CW\*(C`edges\*(C'\fR or the argument
\&\f(CW\*(C`edges_fill\*(C'\fR.  Both are used to define how many random edges to
add to the graph; \f(CW\*(C`edges\*(C'\fR is an absolute number, while \f(CW\*(C`edges_fill\*(C'\fR
is a relative number (relative to the number of edges in a complete
graph, C).  The number of edges can be larger than C, but only if the
graph is countedged.  The random edges will not include self-loops.
If neither \f(CW\*(C`edges\*(C'\fR nor \f(CW\*(C`edges_fill\*(C'\fR is specified, an \f(CW\*(C`edges_fill\*(C'\fR
of 0.5 is assumed.
.PP
If you want repeatable randomness (what is an oxymoron?)
you can use the \f(CW\*(C`random_seed\*(C'\fR option:
.PP
.Vb 1
\&    $g = Graph\->random_graph(vertices => 10, random_seed => 1234);
.Ve
.PP
As this uses the standard Perl \fIsrand()\fR, the usual caveat applies:
use it sparingly, and consider instead using a single \fIsrand()\fR call
at the top level of your application.
.PP
The default random distribution of edges is flat, that is, any pair of
vertices is equally likely to appear.  To define your own distribution,
use the \f(CW\*(C`random_edge\*(C'\fR option:
.PP
.Vb 1
\&    $g = Graph\->random_graph(vertices => 10, random_edge => \e&d);
.Ve
.PP
where \f(CW\*(C`d\*(C'\fR is a code reference receiving \fI($g, \f(CI$u\fI, \f(CI$v\fI, \f(CI$p\fI)\fR as
parameters, where the \fI\f(CI$g\fI\fR is the random graph, \fI\f(CI$u\fI\fR and \fI\f(CI$v\fI\fR are
the vertices, and the \fI\f(CI$p\fI\fR is the probability ([0,1]) for a flat
distribution.  It must return a probability ([0,1]) that the vertices
\&\fI\f(CI$u\fI\fR and \fI\f(CI$v\fI\fR have an edge between them.  Note that returning one
for a particular pair of vertices doesn't guarantee that the edge will
be present in the resulting graph because the required number of edges
might be reached before that particular pair is tested for the
possibility of an edge.  Be very careful to adjust also \f(CW\*(C`edges\*(C'\fR
or \f(CW\*(C`edges_fill\*(C'\fR so that there is a possibility of the filling process
terminating.
.PP
\&\fB\s-1NOTE\s0\fR: a known problem with randomness in openbsd pre\-perl\-5.20 is that
using a seed does not give you deterministic randomness. This affects any
Perl code, not just Graph.
.SS "Attributes"
.IX Subsection "Attributes"
You can attach free-form attributes (key-value pairs, in effect a full
Perl hash) to each vertex, edge, and the graph itself.
.PP
Note that attaching attributes does slow down some other operations
on the graph by a factor of three to ten.  For example adding edge
attributes does slow down anything that walks through all the edges.
.PP
For vertex attributes:
.IP "set_vertex_attribute" 4
.IX Item "set_vertex_attribute"
.Vb 1
\&    $g\->set_vertex_attribute($v, $name, $value)
.Ve
.Sp
Set the named vertex attribute.
.Sp
If the vertex does not exist, the set_...() will create it, and the
other vertex attribute methods will return false or empty.
.Sp
\&\fB\s-1NOTE:\s0 any attributes beginning with an underscore/underline (_)
are reserved for the internal use of the Graph module.\fR
.IP "get_vertex_attribute" 4
.IX Item "get_vertex_attribute"
.Vb 1
\&    $value = $g\->get_vertex_attribute($v, $name)
.Ve
.Sp
Return the named vertex attribute.
.IP "has_vertex_attribute" 4
.IX Item "has_vertex_attribute"
.Vb 1
\&    $g\->has_vertex_attribute($v, $name)
.Ve
.Sp
Return true if the vertex has an attribute, false if not.
.IP "delete_vertex_attribute" 4
.IX Item "delete_vertex_attribute"
.Vb 1
\&    $g\->delete_vertex_attribute($v, $name)
.Ve
.Sp
Delete the named vertex attribute.
.IP "set_vertex_attributes" 4
.IX Item "set_vertex_attributes"
.Vb 1
\&    $g\->set_vertex_attributes($v, $attr)
.Ve
.Sp
Set all the attributes of the vertex from the anonymous hash \f(CW$attr\fR.
.Sp
\&\fB\s-1NOTE\s0\fR: any attributes beginning with an underscore (\f(CW\*(C`_\*(C'\fR) are
reserved for the internal use of the Graph module.
.IP "get_vertex_attributes" 4
.IX Item "get_vertex_attributes"
.Vb 1
\&    $attr = $g\->get_vertex_attributes($v)
.Ve
.Sp
Return all the attributes of the vertex as an anonymous hash.
.IP "get_vertex_attribute_names" 4
.IX Item "get_vertex_attribute_names"
.Vb 1
\&    @name = $g\->get_vertex_attribute_names($v)
.Ve
.Sp
Return the names of vertex attributes.
.IP "get_vertex_attribute_values" 4
.IX Item "get_vertex_attribute_values"
.Vb 1
\&    @value = $g\->get_vertex_attribute_values($v)
.Ve
.Sp
Return the values of vertex attributes.
.IP "has_vertex_attributes" 4
.IX Item "has_vertex_attributes"
.Vb 1
\&    $g\->has_vertex_attributes($v)
.Ve
.Sp
Return true if the vertex has any attributes, false if not.
.IP "delete_vertex_attributes" 4
.IX Item "delete_vertex_attributes"
.Vb 1
\&    $g\->delete_vertex_attributes($v)
.Ve
.Sp
Delete all the attributes of the named vertex.
.PP
If you are using multivertices, use the \fIby_id\fR variants:
.IP "set_vertex_attribute_by_id" 4
.IX Item "set_vertex_attribute_by_id"
.PD 0
.IP "get_vertex_attribute_by_id" 4
.IX Item "get_vertex_attribute_by_id"
.IP "has_vertex_attribute_by_id" 4
.IX Item "has_vertex_attribute_by_id"
.IP "delete_vertex_attribute_by_id" 4
.IX Item "delete_vertex_attribute_by_id"
.IP "set_vertex_attributes_by_id" 4
.IX Item "set_vertex_attributes_by_id"
.IP "get_vertex_attributes_by_id" 4
.IX Item "get_vertex_attributes_by_id"
.IP "get_vertex_attribute_names_by_id" 4
.IX Item "get_vertex_attribute_names_by_id"
.IP "get_vertex_attribute_values_by_id" 4
.IX Item "get_vertex_attribute_values_by_id"
.IP "has_vertex_attributes_by_id" 4
.IX Item "has_vertex_attributes_by_id"
.IP "delete_vertex_attributes_by_id" 4
.IX Item "delete_vertex_attributes_by_id"
.PD
.Vb 10
\&    $g\->set_vertex_attribute_by_id($v, $id, $name, $value)
\&    $g\->get_vertex_attribute_by_id($v, $id, $name)
\&    $g\->has_vertex_attribute_by_id($v, $id, $name)
\&    $g\->delete_vertex_attribute_by_id($v, $id, $name)
\&    $g\->set_vertex_attributes_by_id($v, $id, $attr)
\&    $g\->get_vertex_attributes_by_id($v, $id)
\&    $g\->get_vertex_attribute_values_by_id($v, $id)
\&    $g\->get_vertex_attribute_names_by_id($v, $id)
\&    $g\->has_vertex_attributes_by_id($v, $id)
\&    $g\->delete_vertex_attributes_by_id($v, $id)
.Ve
.PP
For edge attributes:
.IP "set_edge_attribute" 4
.IX Item "set_edge_attribute"
.Vb 1
\&    $g\->set_edge_attribute($u, $v, $name, $value)
.Ve
.Sp
Set the named edge attribute.
.Sp
If the edge does not exist, the set_...() will create it, and the other
edge attribute methods will return false or empty.
.Sp
\&\fB\s-1NOTE\s0\fR: any attributes beginning with an underscore (\f(CW\*(C`_\*(C'\fR) are
reserved for the internal use of the Graph module.
.IP "get_edge_attribute" 4
.IX Item "get_edge_attribute"
.Vb 1
\&    $value = $g\->get_edge_attribute($u, $v, $name)
.Ve
.Sp
Return the named edge attribute.
.IP "has_edge_attribute" 4
.IX Item "has_edge_attribute"
.Vb 1
\&    $g\->has_edge_attribute($u, $v, $name)
.Ve
.Sp
Return true if the edge has an attribute, false if not.
.IP "delete_edge_attribute" 4
.IX Item "delete_edge_attribute"
.Vb 1
\&    $g\->delete_edge_attribute($u, $v, $name)
.Ve
.Sp
Delete the named edge attribute.
.IP "set_edge_attributes" 4
.IX Item "set_edge_attributes"
.Vb 1
\&    $g\->set_edge_attributes($u, $v, $attr)
.Ve
.Sp
Set all the attributes of the edge from the anonymous hash \f(CW$attr\fR.
.Sp
\&\fB\s-1NOTE\s0\fR: any attributes beginning with an underscore (\f(CW\*(C`_\*(C'\fR) are
reserved for the internal use of the Graph module.
.IP "get_edge_attributes" 4
.IX Item "get_edge_attributes"
.Vb 1
\&    $attr = $g\->get_edge_attributes($u, $v)
.Ve
.Sp
Return all the attributes of the edge as an anonymous hash.
.IP "get_edge_attribute_names" 4
.IX Item "get_edge_attribute_names"
.Vb 1
\&    @name = $g\->get_edge_attribute_names($u, $v)
.Ve
.Sp
Return the names of edge attributes.
.IP "get_edge_attribute_values" 4
.IX Item "get_edge_attribute_values"
.Vb 1
\&    @value = $g\->get_edge_attribute_values($u, $v)
.Ve
.Sp
Return the values of edge attributes.
.IP "has_edge_attributes" 4
.IX Item "has_edge_attributes"
.Vb 1
\&    $g\->has_edge_attributes($u, $v)
.Ve
.Sp
Return true if the edge has any attributes, false if not.
.IP "delete_edge_attributes" 4
.IX Item "delete_edge_attributes"
.Vb 1
\&    $g\->delete_edge_attributes($u, $v)
.Ve
.Sp
Delete all the attributes of the named edge.
.PP
If you are using multiedges, use the \fIby_id\fR variants:
.IP "set_edge_attribute_by_id" 4
.IX Item "set_edge_attribute_by_id"
.PD 0
.IP "get_edge_attribute_by_id" 4
.IX Item "get_edge_attribute_by_id"
.IP "has_edge_attribute_by_id" 4
.IX Item "has_edge_attribute_by_id"
.IP "delete_edge_attribute_by_id" 4
.IX Item "delete_edge_attribute_by_id"
.IP "set_edge_attributes_by_id" 4
.IX Item "set_edge_attributes_by_id"
.IP "get_edge_attributes_by_id" 4
.IX Item "get_edge_attributes_by_id"
.IP "get_edge_attribute_names_by_id" 4
.IX Item "get_edge_attribute_names_by_id"
.IP "get_edge_attribute_values_by_id" 4
.IX Item "get_edge_attribute_values_by_id"
.IP "has_edge_attributes_by_id" 4
.IX Item "has_edge_attributes_by_id"
.IP "delete_edge_attributes_by_id" 4
.IX Item "delete_edge_attributes_by_id"
.PD
.Vb 10
\&    $g\->set_edge_attribute_by_id($u, $v, $id, $name, $value)
\&    $g\->get_edge_attribute_by_id($u, $v, $id, $name)
\&    $g\->has_edge_attribute_by_id($u, $v, $id, $name)
\&    $g\->delete_edge_attribute_by_id($u, $v, $id, $name)
\&    $g\->set_edge_attributes_by_id($u, $v, $id, $attr)
\&    $g\->get_edge_attributes_by_id($u, $v, $id)
\&    $g\->get_edge_attribute_values_by_id($u, $v, $id)
\&    $g\->get_edge_attribute_names_by_id($u, $v, $id)
\&    $g\->has_edge_attributes_by_id($u, $v, $id)
\&    $g\->delete_edge_attributes_by_id($u, $v, $id)
.Ve
.PP
For graph attributes:
.IP "set_graph_attribute" 4
.IX Item "set_graph_attribute"
.Vb 1
\&    $g\->set_graph_attribute($name, $value)
.Ve
.Sp
Set the named graph attribute.
.Sp
\&\fB\s-1NOTE\s0\fR: any attributes beginning with an underscore (\f(CW\*(C`_\*(C'\fR) are
reserved for the internal use of the Graph module.
.IP "get_graph_attribute" 4
.IX Item "get_graph_attribute"
.Vb 1
\&    $value = $g\->get_graph_attribute($name)
.Ve
.Sp
Return the named graph attribute.
.IP "has_graph_attribute" 4
.IX Item "has_graph_attribute"
.Vb 1
\&    $g\->has_graph_attribute($name)
.Ve
.Sp
Return true if the graph has an attribute, false if not.
.IP "delete_graph_attribute" 4
.IX Item "delete_graph_attribute"
.Vb 1
\&    $g\->delete_graph_attribute($name)
.Ve
.Sp
Delete the named graph attribute.
.IP "set_graph_attributes" 4
.IX Item "set_graph_attributes"
.Vb 1
\&    $g\->get_graph_attributes($attr)
.Ve
.Sp
Set all the attributes of the graph from the anonymous hash \f(CW$attr\fR.
.Sp
\&\fB\s-1NOTE\s0\fR: any attributes beginning with an underscore (\f(CW\*(C`_\*(C'\fR) are
reserved for the internal use of the Graph module.
.IP "get_graph_attributes" 4
.IX Item "get_graph_attributes"
.Vb 1
\&    $attr = $g\->get_graph_attributes()
.Ve
.Sp
Return all the attributes of the graph as an anonymous hash.
.IP "get_graph_attribute_names" 4
.IX Item "get_graph_attribute_names"
.Vb 1
\&    @name = $g\->get_graph_attribute_names()
.Ve
.Sp
Return the names of graph attributes.
.IP "get_graph_attribute_values" 4
.IX Item "get_graph_attribute_values"
.Vb 1
\&    @value = $g\->get_graph_attribute_values()
.Ve
.Sp
Return the values of graph attributes.
.IP "has_graph_attributes" 4
.IX Item "has_graph_attributes"
.Vb 1
\&    $g\->has_graph_attributes()
.Ve
.Sp
Return true if the graph has any attributes, false if not.
.IP "delete_graph_attributes" 4
.IX Item "delete_graph_attributes"
.Vb 1
\&    $g\->delete_graph_attributes()
.Ve
.Sp
Delete all the attributes of the named graph.
.SS "Weighted"
.IX Subsection "Weighted"
As convenient shortcuts the following methods add, query, and
manipulate the attribute \f(CW\*(C`weight\*(C'\fR with the specified value to the
respective Graph elements.
.IP "add_weighted_edge" 4
.IX Item "add_weighted_edge"
.Vb 1
\&    $g\->add_weighted_edge($u, $v, $weight)
.Ve
.IP "add_weighted_edges" 4
.IX Item "add_weighted_edges"
.Vb 1
\&    $g\->add_weighted_edges($u1, $v1, $weight1, ...)
.Ve
.IP "add_weighted_path" 4
.IX Item "add_weighted_path"
.Vb 1
\&    $g\->add_weighted_path($v1, $weight1, $v2, $weight2, $v3, ...)
.Ve
.IP "add_weighted_vertex" 4
.IX Item "add_weighted_vertex"
.Vb 1
\&    $g\->add_weighted_vertex($v, $weight)
.Ve
.IP "add_weighted_vertices" 4
.IX Item "add_weighted_vertices"
.Vb 1
\&    $g\->add_weighted_vertices($v1, $weight1, $v2, $weight2, ...)
.Ve
.IP "delete_edge_weight" 4
.IX Item "delete_edge_weight"
.Vb 1
\&    $g\->delete_edge_weight($u, $v)
.Ve
.IP "delete_vertex_weight" 4
.IX Item "delete_vertex_weight"
.Vb 1
\&    $g\->delete_vertex_weight($v)
.Ve
.IP "get_edge_weight" 4
.IX Item "get_edge_weight"
.Vb 1
\&    $g\->get_edge_weight($u, $v)
.Ve
.IP "get_vertex_weight" 4
.IX Item "get_vertex_weight"
.Vb 1
\&    $g\->get_vertex_weight($v)
.Ve
.IP "has_edge_weight" 4
.IX Item "has_edge_weight"
.Vb 1
\&    $g\->has_edge_weight($u, $v)
.Ve
.IP "has_vertex_weight" 4
.IX Item "has_vertex_weight"
.Vb 1
\&    $g\->has_vertex_weight($v)
.Ve
.IP "set_edge_weight" 4
.IX Item "set_edge_weight"
.Vb 1
\&    $g\->set_edge_weight($u, $v, $weight)
.Ve
.IP "set_vertex_weight" 4
.IX Item "set_vertex_weight"
.Vb 1
\&    $g\->set_vertex_weight($v, $weight)
.Ve
.SS "Isomorphism"
.IX Subsection "Isomorphism"
Two graphs being \fIisomorphic\fR means that they are structurally the
same graph, the difference being that the vertices might have been
\&\fIrenamed\fR or \fIsubstituted\fR.  For example in the below example \f(CW$g0\fR
and \f(CW$g1\fR are isomorphic: the vertices \f(CW\*(C`b c d\*(C'\fR have been renamed as
\&\f(CW\*(C`z x y\*(C'\fR.
.PP
.Vb 4
\&        $g0 = Graph\->new;
\&        $g0\->add_edges(qw(a b a c c d));
\&        $g1 = Graph\->new;
\&        $g1\->add_edges(qw(a x x y a z));
.Ve
.PP
In the general case determining isomorphism is \fINP-hard\fR, in other
words, really hard (time-consuming), no other ways of solving the problem
are known than brute force check of of all the possibilities (with possible
optimization tricks, of course, but brute force still rules at the end of
the day).
.PP
A \fBvery rough guess\fR at whether two graphs \fBcould\fR be isomorphic
is possible via the method
.IP "could_be_isomorphic" 4
.IX Item "could_be_isomorphic"
.Vb 1
\&    $g0\->could_be_isomorphic($g1)
.Ve
.PP
If the graphs do not have the same number of vertices and edges, false
is returned.  If the distribution of \fIin-degrees\fR and \fIout-degrees\fR
at the vertices of the graphs does not match, false is returned.
Otherwise, true is returned.
.PP
What is actually returned is the maximum number of possible isomorphic
graphs between the two graphs, after the above sanity checks have been
conducted.  It is basically the product of the factorials of the
absolute values of in-degrees and out-degree pairs at each vertex,
with the isolated vertices ignored (since they could be reshuffled and
renamed arbitrarily).  Note that for large graphs the product of these
factorials can overflow the maximum presentable number (the floating
point number) in your computer (in Perl) and you might get for example
\&\fIInfinity\fR as the result.
.SS "Miscellaneous"
.IX Subsection "Miscellaneous"
.IP "betweenness" 4
.IX Item "betweenness"
.Vb 1
\&    %b = $g\->betweenness
.Ve
.Sp
Returns a map of vertices to their Freeman's betweennesses:
.Sp
.Vb 1
\&  C_b(v) = \esum_{s \eneq v \eneq t \ein V} \efrac{\esigma_{s,t}(v)}{\esigma_{s,t}}
.Ve
.Sp
It is described in:
.Sp
.Vb 1
\&    Freeman, A set of measures of centrality based on betweenness, http://arxiv.org/pdf/cond\-mat/0309045
.Ve
.Sp
and based on the algorithm from:
.Sp
.Vb 1
\&    "A Faster Algorithm for Betweenness Centrality"
.Ve
.IP "clustering_coefficient" 4
.IX Item "clustering_coefficient"
.Vb 2
\&    $gamma = $g\->clustering_coefficient()
\&    ($gamma, %clustering) = $g\->clustering_coefficient()
.Ve
.Sp
Returns the clustering coefficient gamma as described in
.Sp
.Vb 1
\&    Duncan J. Watts and Steven Strogatz, Collective dynamics of \*(Aqsmall\-world\*(Aq networks, http://audiophile.tam.cornell.edu/SS_nature_smallworld.pdf
.Ve
.Sp
In scalar context returns just the average gamma, in list context
returns the average gamma and a hash of vertices to clustering
coefficients.
.IP "subgraph_by_radius" 4
.IX Item "subgraph_by_radius"
.Vb 1
\&    $s = $g\->subgraph_by_radius($n, $radius);
.Ve
.Sp
Returns a subgraph representing the ball of \f(CW$radius\fR around node \f(CW$n\fR
(breadth-first search).
.PP
The \*(L"expect\*(R" methods can be used to test a graph and croak if the
graph call is not as expected.
.IP "expect_acyclic" 4
.IX Item "expect_acyclic"
.PD 0
.IP "expect_dag" 4
.IX Item "expect_dag"
.IP "expect_directed" 4
.IX Item "expect_directed"
.IP "expect_hyperedged" 4
.IX Item "expect_hyperedged"
.IP "expect_hypervertexed" 4
.IX Item "expect_hypervertexed"
.IP "expect_multiedged" 4
.IX Item "expect_multiedged"
.IP "expect_multivertexed" 4
.IX Item "expect_multivertexed"
.IP "expect_no_args" 4
.IX Item "expect_no_args"
.IP "expect_non_multiedged" 4
.IX Item "expect_non_multiedged"
.IP "expect_non_multivertexed" 4
.IX Item "expect_non_multivertexed"
.IP "expect_non_unionfind" 4
.IX Item "expect_non_unionfind"
.IP "expect_undirected" 4
.IX Item "expect_undirected"
.PD
.PP
In many algorithms it is useful to have a value representing the
infinity.  The Graph provides (and itself uses):
.IP "Infinity" 4
.IX Item "Infinity"
(Not exported, use Graph::Infinity explicitly)
.SS "Size Requirements"
.IX Subsection "Size Requirements"
A graph takes up at least 1172 bytes of memory.
.PP
A vertex takes up at least 100 bytes of memory.
.PP
An edge takes up at least 400 bytes of memory.
.PP
(A Perl scalar value takes 16 bytes, or 12 bytes if it's a reference.)
.PP
These size approximations are \fBvery\fR approximate and optimistic
(they are based on \fItotal_size()\fR of Devel::Size).  In real life many
factors affect these numbers, for example how Perl is configured.
The numbers are for a 32\-bit platform and for Perl 5.8.8.
.PP
Roughly, the above numbers mean that in a megabyte of memory you can
fit for example a graph of about 1000 vertices and about 2500 edges.
.SS "Hyperedges, hypervertices, hypergraphs"
.IX Subsection "Hyperedges, hypervertices, hypergraphs"
\&\fB\s-1BEWARE\s0\fR: this is a rather thinly tested feature, and the theory
is even less so.  Do not expect this to stay as it is (or at all)
in future releases.
.PP
\&\fB\s-1NOTE\s0\fR: most usual graph algorithms (and basic concepts) break
horribly (or at least will look funny) with these hyperthingies.
Caveat emptor.
.PP
Hyperedges are edges that connect a number of vertices different
from the usual two.
.PP
Hypervertices are vertices that consist of a number of vertices
different from the usual one.
.PP
Note that for hypervertices there is an asymmetry: when adding
hypervertices, the single vertices are also implicitly added.
.PP
Hypergraphs are graphs with hyperedges.
.PP
To enable hyperness when constructing Graphs use the \f(CW\*(C`hyperedged\*(C'\fR
and \f(CW\*(C`hypervertexed\*(C'\fR attributes:
.PP
.Vb 1
\&   my $h = Graph\->new(hyperedged => 1, hypervertexed => 1);
.Ve
.PP
To add hypervertexes, either explicitly use more than one vertex (or,
indeed, \fIno\fR vertices) when using \fIadd_vertex()\fR
.PP
.Vb 2
\&   $h\->add_vertex("a", "b")
\&   $h\->add_vertex()
.Ve
.PP
or implicitly with array references when using \fIadd_edge()\fR
.PP
.Vb 2
\&   $h\->add_edge(["a", "b"], "c")
\&   $h\->add_edge()
.Ve
.PP
Testing for existence and deletion of hypervertices and hyperedges
works similarly.
.PP
To test for hyperness of a graph use the
.IP "is_hypervertexed" 4
.IX Item "is_hypervertexed"
.PD 0
.IP "hypervertexed" 4
.IX Item "hypervertexed"
.PD
.Vb 2
\&    $g\->is_hypervertexed
\&    $g\->hypervertexed
.Ve
.IP "is_hyperedged" 4
.IX Item "is_hyperedged"
.PD 0
.IP "hyperedged" 4
.IX Item "hyperedged"
.PD
.Vb 2
\&    $g\->is_hyperedged
\&    $g\->hyperedged
.Ve
.PP
Since hypervertices consist of more than one vertex:
.IP "vertices_at" 4
.IX Item "vertices_at"
.Vb 1
\&    $g\->vertices_at($v)
.Ve
.PP
Return the vertices at the vertex.  This may return just the vertex
or also other vertices.
.PP
To go with the concept of undirected in normal (non-hyper) graphs,
there is a similar concept of omnidirected \fI(this is my own coinage,
\&\*(L"all-directions\*(R")\fR for hypergraphs, and you can naturally test for it by
.IP "is_omnidirected" 4
.IX Item "is_omnidirected"
.PD 0
.IP "omnidirected" 4
.IX Item "omnidirected"
.IP "is_omniedged" 4
.IX Item "is_omniedged"
.IP "omniedged" 4
.IX Item "omniedged"
.PD
.Vb 1
\&   $g\->is_omniedged
\&
\&   $g\->omniedged
\&
\&   $g\->is_omnidirected
\&
\&   $g\->omnidirected
.Ve
.Sp
Return true if the graph is omnidirected (edges have no direction),
false if not.
.PP
You may be wondering why on earth did I make up this new concept, why
didn't the \*(L"undirected\*(R" work for me?  Well, because of this:
.PP
.Vb 1
\&   $g = Graph\->new(hypervertexed => 1, omnivertexed => 1);
.Ve
.PP
That's right, vertices can be omni, too \- and that is indeed the
default.  You can turn it off and then \f(CW$g\fR\->add_vertex(qw(a b)) no
more means adding also the (hyper)vertex qw(b a).  In other words,
the \*(L"directivity\*(R" is orthogonal to (or independent of) the number of
vertices in the vertex/edge.
.IP "is_omnivertexed" 4
.IX Item "is_omnivertexed"
.PD 0
.IP "omnivertexed" 4
.IX Item "omnivertexed"
.PD
.PP
Another oddity that fell out of the implementation is the uniqueness
attribute, that comes naturally in \f(CW\*(C`uniqedged\*(C'\fR and \f(CW\*(C`uniqvertexed\*(C'\fR
flavours.  It does what it sounds like, to unique or not the vertices
participating in edges and vertices (is the hypervertex qw(a b a) the
same as the hypervertex qw(a b), for example).  Without too much
explanation:
.IP "is_uniqedged" 4
.IX Item "is_uniqedged"
.PD 0
.IP "uniqedged" 4
.IX Item "uniqedged"
.IP "is_uniqvertexed" 4
.IX Item "is_uniqvertexed"
.IP "uniqvertexed" 4
.IX Item "uniqvertexed"
.PD
.SS "Backward compatibility with Graph 0.2"
.IX Subsection "Backward compatibility with Graph 0.2"
The Graph 0.2 (and 0.2xxxx) had the following features
.IP "\(bu" 4
\&\fIvertices()\fR always sorted the vertex list, which most of the time is
unnecessary and wastes \s-1CPU.\s0
.IP "\(bu" 4
\&\fIedges()\fR returned a flat list where the begin and end vertices of the
edges were intermingled: every even index had an edge begin vertex,
and every odd index had an edge end vertex.  This had the unfortunate
consequence of \f(CW\*(C`scalar(@e = edges)\*(C'\fR being twice the number of edges,
and complicating any algorithm walking through the edges.
.IP "\(bu" 4
The vertex list returned by \fIedges()\fR was sorted, the primary key being
the edge begin vertices, and the secondary key being the edge end vertices.
.IP "\(bu" 4
The attribute \s-1API\s0 was oddly position dependent and dependent
on the number of arguments.  Use ...\fI_graph_attribute()\fR,
\&...\fI_vertex_attribute()\fR, ...\fI_edge_attribute()\fR instead.
.PP
\&\fBIn future releases of Graph (any release after 0.50) the 0.2xxxx
compatibility will be removed.  Upgrade your code now.\fR
.PP
If you want to continue using these (mis)features you can use the
\&\f(CW\*(C`compat02\*(C'\fR flag when creating a graph:
.PP
.Vb 1
\&    my $g = Graph\->new(compat02 => 1);
.Ve
.PP
This will change the \fIvertices()\fR and \fIedges()\fR appropriately.  This,
however, is not recommended, since it complicates all the code using
\&\fIvertices()\fR and \fIedges()\fR.  Instead it is recommended that the
\&\fIvertices02()\fR and \fIedges02()\fR methods are used.  The corresponding new
style (unsorted, and \fIedges()\fR returning a list of references) methods
are called \fIvertices05()\fR and \fIedges05()\fR.
.PP
To test whether a graph has the compatibility turned on
.IP "is_compat02" 4
.IX Item "is_compat02"
.PD 0
.IP "compat02" 4
.IX Item "compat02"
.PD
.Vb 2
\&    $g\->is_compat02
\&    $g\->compat02
.Ve
.PP
The following are not backward compatibility methods, strictly
speaking, because they did not exist before.
.IP "edges02" 4
.IX Item "edges02"
Return the edges as a flat list of vertices, elements at even indices
being the start vertices and elements at odd indices being the end
vertices.
.IP "edges05" 4
.IX Item "edges05"
Return the edges as a list of array references, each element
containing the vertices of each edge.  (This is not a backward
compatibility interface as such since it did not exist before.)
.IP "vertices02" 4
.IX Item "vertices02"
Return the vertices in sorted order.
.IP "vertices05" 4
.IX Item "vertices05"
Return the vertices in random order.
.PP
For the attributes the recommended way is to use the new \s-1API.\s0
.PP
Do not expect new methods to work for compat02 graphs.
.PP
The following compatibility methods exist:
.IP "has_attribute" 4
.IX Item "has_attribute"
.PD 0
.IP "has_attributes" 4
.IX Item "has_attributes"
.IP "get_attribute" 4
.IX Item "get_attribute"
.IP "get_attributes" 4
.IX Item "get_attributes"
.IP "set_attribute" 4
.IX Item "set_attribute"
.IP "set_attributes" 4
.IX Item "set_attributes"
.IP "delete_attribute" 4
.IX Item "delete_attribute"
.IP "delete_attributes" 4
.IX Item "delete_attributes"
.PD
Do not use the above, use the new attribute interfaces instead.
.IP "vertices_unsorted" 4
.IX Item "vertices_unsorted"
Alias for \fIvertices()\fR (or rather, \fIvertices05()\fR) since the \fIvertices()\fR
now always returns the vertices in an unsorted order.  You can also
use the unsorted_vertices import, but only with a true value (false
values will cause an error).
.IP "density_limits" 4
.IX Item "density_limits"
.Vb 1
\&    my ($sparse, $dense, $complete) = $g\->density_limits;
.Ve
.Sp
Return the \*(L"density limits\*(R" used to classify graphs as \*(L"sparse\*(R" or \*(L"dense\*(R".
The first limit is C/4 and the second limit is 3C/4, where C is the number
of edges in a complete graph (the last \*(L"limit\*(R").
.IP "density" 4
.IX Item "density"
.Vb 1
\&    my $density = $g\->density;
.Ve
.Sp
Return the density of the graph, the ratio of the number of edges to the
number of edges in a complete graph.
.IP "vertex" 4
.IX Item "vertex"
.Vb 1
\&    my $v = $g\->vertex($v);
.Ve
.Sp
Return the vertex if the graph has the vertex, undef otherwise.
.IP "out_edges" 4
.IX Item "out_edges"
.PD 0
.IP "in_edges" 4
.IX Item "in_edges"
.IP "edges($v)" 4
.IX Item "edges($v)"
.PD
This is now called edges_at($v).
.SS "\s-1DIAGNOSTICS\s0"
.IX Subsection "DIAGNOSTICS"
.IP "\(bu" 4
Graph::...Map...: arguments X expected Y ...
.Sp
If you see these (more user-friendly error messages should have been
triggered above and before these) please report any such occurrences,
but in general you should be happy to see these since it means that an
attempt to call something with a wrong number of arguments was caught
in time.
.IP "\(bu" 4
Graph::add_edge: graph is not hyperedged ...
.Sp
Maybe you used \fIadd_weighted_edge()\fR with only the two vertex arguments.
.IP "\(bu" 4
Not an \s-1ARRAY\s0 reference at lib/Graph.pm ...
.Sp
One possibility is that you have code based on Graph 0.2xxxx that
assumes Graphs being blessed hash references, possibly also assuming
that certain hash keys are available to use for your own purposes.
In Graph 0.50 none of this is true.  Please do not expect any
particular internal implementation of Graphs.  Use inheritance
and graph/vertex/edge attributes instead.
.Sp
Another possibility is that you meant to have objects (blessed
references) as graph vertices, but forgot to use \f(CW\*(C`refvertexed\*(C'\fR
(see \*(L"refvertexed\*(R") when creating the graph.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
All bad terminology, bugs, and inefficiencies are naturally mine, all
mine, and not the fault of the below.
.PP
Thanks to Nathan Goodman and Andras Salamon for bravely betatesting my
pre\-0.50 code.  If they missed something, that was only because of my
fiendish code.
.PP
The following literature for algorithms and some test cases:
.IP "\(bu" 4
Algorithms in C, Third Edition, Part 5, Graph Algorithms, Robert Sedgewick, Addison Wesley
.IP "\(bu" 4
Introduction to Algorithms, First Edition, Cormen-Leiserson-Rivest, McGraw Hill
.IP "\(bu" 4
Graphs, Networks and Algorithms, Dieter Jungnickel, Springer
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Persistent/Serialized graphs?  You want to read/write Graphs?  See the
Graph::Reader and Graph::Writer in \s-1CPAN.\s0
.SH "REPOSITORY"
.IX Header "REPOSITORY"
<https://github.com/neilbowers/Graph>
.SH "AUTHOR"
.IX Header "AUTHOR"
Jarkko Hietaniemi \fIjhi@iki.fi\fR
.PP
Now being maintained by Neil Bowers <neilb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 1998\-2014 Jarkko Hietaniemi.  All rights reserved.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
